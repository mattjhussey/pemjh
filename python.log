
D:\Development\pemjh>flake8 pemjh --show-source --show-pep8 
pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
def testFunction(id, func, knownAnswer):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\main.py:13:15: E261 at least two spaces before inline comment
    result = 2 # 0 = correct, 1 = wrong, 2 = not known
              ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
    if not knownAnswer == None:
                       ^
    Comparison to singletons should use "is" or "is not".

    Comparisons to singletons like None should always be done
    with "is" or "is not", never the equality operators.

    Okay: if arg is not None:
    E711: if arg != None:
    E712: if arg == True:

    Also, beware of writing if x when you really mean if x is not None --
    e.g. when testing whether a variable or argument that defaults to None was
    set to some other value.  The other value might have a type (such as a
    container) that could be false in a boolean context!
pemjh\main.py:32:18: W291 trailing whitespace
failures = list()
                 ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\main.py:42:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\main.py:58:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
def challenge001():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
    return sum(filter(lambda a: (a % 3 == 0) or (a % 5 == 0), xrange(1, upper)))
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge001\challenge001.py:9:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1
def challenge002():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge003\challenge003.py:1:1: F401 'math' imported but unused
import math
^
pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
def challenge003():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
    #Loop from 2 until the target number is 1
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
    #Loop until target is 1
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
        #Loop until the mod of target divided by current is not 0
        ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
        if (target == 1): break
                        ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge003\challenge003.py:28:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
            if (potential_palindrome <= highest_palindrome): break
                                                           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
            #Convert the potential to a string
            ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge004\challenge004.py:36:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
            if n == 1: break
                     ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge005\challenge005.py:39:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge006\challenge006.py:23:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
def challenge007():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge007\challenge007.py:24:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge008\challenge008.py:44:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
    for a in range(1,(max / 3)):
                    ^
    Each comma, semicolon or colon should be followed by whitespace.

    Okay: [a, b]
    Okay: (3,)
    Okay: a[1:4]
    Okay: a[:4]
    Okay: a[1:]
    Okay: a[1:4:2]
    E231: ['a','b']
    E231: foo(bar,baz)
    E231: [{'a':'b'}]
pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
        for b in range((a + 1),(a + 1 + (remainder / 2))):
                              ^
    Each comma, semicolon or colon should be followed by whitespace.

    Okay: [a, b]
    Okay: (3,)
    Okay: a[1:4]
    Okay: a[:4]
    Okay: a[1:]
    Okay: a[1:4:2]
    E231: ['a','b']
    E231: foo(bar,baz)
    E231: [{'a':'b'}]
pemjh\challenge009\challenge009.py:21:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge010\challenge010.py:1:1: F401 'ifilter' imported but unused
from itertools import ifilter
^
pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
def challenge010():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge010\challenge010.py:18:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
    data = "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48"
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
                if total > highest: highest = total
                                  ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
                if row < (len(rows) -3):
                                     ^
    Surround operators with a single space on either side.

    - Always surround these binary operators with a single space on
      either side: assignment (=), augmented assignment (+=, -= etc.),
      comparisons (==, <, >, !=, <=, >=, in, not in, is, is not),
      Booleans (and, or, not).

    - If operators with different priorities are used, consider adding
      whitespace around the operators with the lowest priorities.

    Okay: i = i + 1
    Okay: submitted += 1
    Okay: x = x * 2 - 1
    Okay: hypot2 = x * x + y * y
    Okay: c = (a + b) * (a - b)
    Okay: foo(bar, key='word', *args, **kwargs)
    Okay: alpha[:-i]

    E225: i=i+1
    E225: submitted +=1
    E225: x = x /2 - 1
    E225: z = x **y
    E226: c = (a+b) * (a-b)
    E226: hypot2 = x*x + y*y
    E227: c = a|b
    E228: msg = fmt%(errno, errmsg)
pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
                    if total > highest: highest = total
                                      ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
                    if total > highest: highest = total
                                      ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
                if total > highest: highest = total
                                  ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
    return highest
    ^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge011\challenge011.py:61:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
from math import sqrt
^
pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
def triangles():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
def triangleDivisors():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
def challenge012():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)
        if i > limit: break
                    ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
    numbers = [37107287533902102798797998220837590246510135740250, \
                                                                   ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
                   46376937677490009712648124896970078050417018260538, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
                   46376937677490009712648124896970078050417018260538, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
                   74324986199524741059474233309513058123726617309629, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
                   74324986199524741059474233309513058123726617309629, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
                   91942213363574161572522430563301811072406154908250, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
                   91942213363574161572522430563301811072406154908250, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
                   23067588207539346171171980310421047513778063246676, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
                   23067588207539346171171980310421047513778063246676, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
                   89261670696623633820136378418383684178734361726757, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
                   89261670696623633820136378418383684178734361726757, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
                   28112879812849979408065481931592621691275889832738, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
                   28112879812849979408065481931592621691275889832738, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
                   44274228917432520321923589422876796487670272189318, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
                   44274228917432520321923589422876796487670272189318, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
                   47451445736001306439091167216856844588711603153276, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
                   47451445736001306439091167216856844588711603153276, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
                   70386486105843025439939619828917593665686757934951, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
                   70386486105843025439939619828917593665686757934951, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
                   62176457141856560629502157223196586755079324193331, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
                   62176457141856560629502157223196586755079324193331, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
                   64906352462741904929101432445813822663347944758178, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
                   64906352462741904929101432445813822663347944758178, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
                   92575867718337217661963751590579239728245598838407, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
                   92575867718337217661963751590579239728245598838407, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
                   58203565325359399008402633568948830189458628227828, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
                   58203565325359399008402633568948830189458628227828, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
                   80181199384826282014278194139940567587151170094390, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
                   80181199384826282014278194139940567587151170094390, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
                   35398664372827112653829987240784473053190104293586, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
                   35398664372827112653829987240784473053190104293586, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
                   86515506006295864861532075273371959191420517255829, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
                   86515506006295864861532075273371959191420517255829, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
                   71693888707715466499115593487603532921714970056938, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
                   71693888707715466499115593487603532921714970056938, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
                   54370070576826684624621495650076471787294438377604, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
                   54370070576826684624621495650076471787294438377604, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
                   53282654108756828443191190634694037855217779295145, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
                   53282654108756828443191190634694037855217779295145, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
                   36123272525000296071075082563815656710885258350721, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
                   36123272525000296071075082563815656710885258350721, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
                   45876576172410976447339110607218265236877223636045, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
                   45876576172410976447339110607218265236877223636045, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
                   17423706905851860660448207621209813287860733969412, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
                   17423706905851860660448207621209813287860733969412, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
                   81142660418086830619328460811191061556940512689692, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
                   81142660418086830619328460811191061556940512689692, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
                   51934325451728388641918047049293215058642563049483, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
                   51934325451728388641918047049293215058642563049483, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
                   62467221648435076201727918039944693004732956340691, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
                   62467221648435076201727918039944693004732956340691, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
                   15732444386908125794514089057706229429197107928209, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
                   15732444386908125794514089057706229429197107928209, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
                   55037687525678773091862540744969844508330393682126, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
                   55037687525678773091862540744969844508330393682126, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
                   18336384825330154686196124348767681297534375946515, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
                   18336384825330154686196124348767681297534375946515, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
                   80386287592878490201521685554828717201219257766954, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
                   80386287592878490201521685554828717201219257766954, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
                   78182833757993103614740356856449095527097864797581, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
                   78182833757993103614740356856449095527097864797581, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
                   16726320100436897842553539920931837441497806860984, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
                   16726320100436897842553539920931837441497806860984, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
                   48403098129077791799088218795327364475675590848030, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
                   48403098129077791799088218795327364475675590848030, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
                   87086987551392711854517078544161852424320693150332, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
                   87086987551392711854517078544161852424320693150332, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
                   59959406895756536782107074926966537676326235447210, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
                   59959406895756536782107074926966537676326235447210, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
                   69793950679652694742597709739166693763042633987085, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
                   69793950679652694742597709739166693763042633987085, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
                   41052684708299085211399427365734116182760315001271, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
                   41052684708299085211399427365734116182760315001271, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
                   65378607361501080857009149939512557028198746004375, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
                   65378607361501080857009149939512557028198746004375, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
                   35829035317434717326932123578154982629742552737307, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
                   35829035317434717326932123578154982629742552737307, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
                   94953759765105305946966067683156574377167401875275, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
                   94953759765105305946966067683156574377167401875275, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
                   88902802571733229619176668713819931811048770190271, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
                   88902802571733229619176668713819931811048770190271, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
                   25267680276078003013678680992525463401061632866526, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
                   25267680276078003013678680992525463401061632866526, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
                   36270218540497705585629946580636237993140746255962, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
                   36270218540497705585629946580636237993140746255962, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
                   24074486908231174977792365466257246923322810917141, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
                   24074486908231174977792365466257246923322810917141, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
                   91430288197103288597806669760892938638285025333403, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
                   91430288197103288597806669760892938638285025333403, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
                   34413065578016127815921815005561868836468420090470, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
                   34413065578016127815921815005561868836468420090470, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
                   23053081172816430487623791969842487255036638784583, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
                   23053081172816430487623791969842487255036638784583, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
                   11487696932154902810424020138335124462181441773470, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
                   11487696932154902810424020138335124462181441773470, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
                   63783299490636259666498587618221225225512486764533, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
                   63783299490636259666498587618221225225512486764533, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
                   67720186971698544312419572409913959008952310058822, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
                   67720186971698544312419572409913959008952310058822, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
                   95548255300263520781532296796249481641953868218774, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
                   95548255300263520781532296796249481641953868218774, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
                   76085327132285723110424803456124867697064507995236, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
                   76085327132285723110424803456124867697064507995236, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
                   37774242535411291684276865538926205024910326572967, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
                   37774242535411291684276865538926205024910326572967, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
                   23701913275725675285653248258265463092207058596522, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
                   23701913275725675285653248258265463092207058596522, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
                   29798860272258331913126375147341994889534765745501, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
                   29798860272258331913126375147341994889534765745501, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
                   18495701454879288984856827726077713721403798879715, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
                   18495701454879288984856827726077713721403798879715, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
                   38298203783031473527721580348144513491373226651381, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
                   38298203783031473527721580348144513491373226651381, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
                   34829543829199918180278916522431027392251122869539, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
                   34829543829199918180278916522431027392251122869539, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
                   40957953066405232632538044100059654939159879593635, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
                   40957953066405232632538044100059654939159879593635, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
                   29746152185502371307642255121183693803580388584903, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
                   29746152185502371307642255121183693803580388584903, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
                   41698116222072977186158236678424689157993532961922, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
                   41698116222072977186158236678424689157993532961922, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
                   62467957194401269043877107275048102390895523597457, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
                   62467957194401269043877107275048102390895523597457, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
                   23189706772547915061505504953922979530901129967519, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
                   23189706772547915061505504953922979530901129967519, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
                   86188088225875314529584099251203829009407770775672, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
                   86188088225875314529584099251203829009407770775672, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
                   11306739708304724483816533873502340845647058077308, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
                   11306739708304724483816533873502340845647058077308, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
                   82959174767140363198008187129011875491310547126581, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
                   82959174767140363198008187129011875491310547126581, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
                   97623331044818386269515456334926366572897563400500, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
                   97623331044818386269515456334926366572897563400500, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
                   42846280183517070527831839425882145521227251250327, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
                   42846280183517070527831839425882145521227251250327, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
                   55121603546981200581762165212827652751691296897789, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
                   55121603546981200581762165212827652751691296897789, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
                   32238195734329339946437501907836945765883352399886, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
                   32238195734329339946437501907836945765883352399886, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
                   75506164965184775180738168837861091527357929701337, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
                   75506164965184775180738168837861091527357929701337, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
                   62177842752192623401942399639168044983993173312731, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
                   62177842752192623401942399639168044983993173312731, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
                   32924185707147349566916674687634660915035914677504, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
                   32924185707147349566916674687634660915035914677504, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
                   99518671430235219628894890102423325116913619626622, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
                   99518671430235219628894890102423325116913619626622, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
                   73267460800591547471830798392868535206946944540724, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
                   73267460800591547471830798392868535206946944540724, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
                   76841822524674417161514036427982273348055556214818, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
                   76841822524674417161514036427982273348055556214818, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
                   97142617910342598647204516893989422179826088076852, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
                   97142617910342598647204516893989422179826088076852, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
                   87783646182799346313767754307809363333018982642090, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
                   87783646182799346313767754307809363333018982642090, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
                   10848802521674670883215120185883543223812876952786, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
                   10848802521674670883215120185883543223812876952786, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
                   71329612474782464538636993009049310363619763878039, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
                   71329612474782464538636993009049310363619763878039, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
                   62184073572399794223406235393808339651327408011116, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
                   62184073572399794223406235393808339651327408011116, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
                   66627891981488087797941876876144230030984490851411, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
                   66627891981488087797941876876144230030984490851411, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
                   60661826293682836764744779239180335110989069790714, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
                   60661826293682836764744779239180335110989069790714, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
                   85786944089552990653640447425576083659976645795096, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
                   85786944089552990653640447425576083659976645795096, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
                   66024396409905389607120198219976047599490197230297, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
                   66024396409905389607120198219976047599490197230297, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
                   64913982680032973156037120041377903785566085089252, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
                   64913982680032973156037120041377903785566085089252, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
                   16730939319872750275468906903707539413042652315011, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
                   16730939319872750275468906903707539413042652315011, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
                   94809377245048795150954100921645863754710598436791, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
                   94809377245048795150954100921645863754710598436791, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
                   78639167021187492431995700641917969777599028300699, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
                   78639167021187492431995700641917969777599028300699, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
                   15368713711936614952811305876380278410754449733078, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
                   15368713711936614952811305876380278410754449733078, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
                   40789923115535562561142322423255033685442488917353, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
                   40789923115535562561142322423255033685442488917353, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
                   44889911501440648020369068063960672322193204149535, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
                   44889911501440648020369068063960672322193204149535, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
                   41503128880339536053299340368006977710650566631954, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
                   41503128880339536053299340368006977710650566631954, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
                   81234880673210146739058568557934581403627822703280, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
                   81234880673210146739058568557934581403627822703280, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
                   82616570773948327592232845941706525094512325230608, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
                   82616570773948327592232845941706525094512325230608, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
                   22918802058777319719839450180888072429661980811197, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
                   22918802058777319719839450180888072429661980811197, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
                   77158542502016545090413245809786882778948721859617, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
                   77158542502016545090413245809786882778948721859617, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
                   72107838435069186155435662884062257473692284509516, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
                   72107838435069186155435662884062257473692284509516, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
                   20849603980134001723930671666823555245252804609722, \
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
                   20849603980134001723930671666823555245252804609722, \
                                                                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
                   53503534226472524250874054075591789781264330331690]
                   ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge013\challenge013.py:114:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
def challenge014():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
def multiplierGen(n = 0):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
def multiplierGen(n = 0):
                   ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
def multiplierGen(n = 0):
                     ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
def getRoutes(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
def challenge015():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge016\challenge016.py:17:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
        if known.has_key(tempN):
                ^
    The {}.has_key() method is removed in Python 3: use the 'in' operator.

    Okay: if "alph" in d:\n    print d["alph"]
    W601: assert d.has_key('alph')
pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
    known[n] = numberRepresentation
                                   ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
def challenge017():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
    known = {0: "", \
                    ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
                 1: "one", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
                 1: "one", \
                           ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
                 2: "two", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
                 2: "two", \
                           ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
                 3: "three", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
                 3: "three", \
                             ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
                 4: "four", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
                 4: "four", \
                            ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
                 5: "five", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
                 5: "five", \
                            ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
                 6: "six", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
                 6: "six", \
                           ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
                 7: "seven", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
                 7: "seven", \
                             ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
                 8: "eight", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
                 8: "eight", \
                             ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
                 9: "nine", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
                 9: "nine", \
                            ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
                 10: "ten", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
                 10: "ten", \
                            ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
                 11: "eleven", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
                 11: "eleven", \
                               ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
                 12: "twelve", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
                 12: "twelve", \
                               ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
                 13: "thirteen", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
                 13: "thirteen", \
                                 ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
                 14: "fourteen", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
                 14: "fourteen", \
                                 ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
                 15: "fifteen", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
                 15: "fifteen", \
                                ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
                 16: "sixteen", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
                 16: "sixteen", \
                                ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
                 17: "seventeen", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
                 17: "seventeen", \
                                  ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
                 18: "eighteen", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
                 18: "eighteen", \
                                 ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
                 19: "nineteen", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
                 19: "nineteen", \
                                 ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
                 20: "twenty", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
                 20: "twenty", \
                               ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
                 30: "thirty", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
                 30: "thirty", \
                               ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
                 40: "forty", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
                 40: "forty", \
                              ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
                 50: "fifty", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
                 50: "fifty", \
                              ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
                 60: "sixty", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
                 60: "sixty", \
                              ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
                 70: "seventy", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
                 70: "seventy", \
                                ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
                 80: "eighty", \
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
                 80: "eighty", \
                               ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
                 90: "ninety"}
                 ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge017\challenge017.py:70:5: F841 local variable 'knownInts' is assigned to but never used
    knownInts = {0: 0, \
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
    knownInts = {0: 0, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
                 1: 3, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
                 2: 3, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
                 3: 5, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
                 4: 4, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
                 5: 4, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
                 6: 3, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
                 7: 5, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
                 8: 5, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
                 9: 4, \
                       ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
                 10: 3, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
                 11: 6, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
                 12: 6, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
                 13: 8, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
                 14: 8, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
                 15: 7, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
                 16: 7, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
                 17: 9, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
                 18: 8, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
                 19: 8, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
                 20: 6, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
                 30: 6, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
                 40: 5, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
                 50: 5, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
                 60: 5, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
                 70: 7, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
                 80: 6, \
                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge017\challenge017.py:100:5: F841 local variable 'endLine' is assigned to but never used
    endLine = 0
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge017\challenge017.py:109:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
def challenge018():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge018\challenge018.py:30:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
def getYearDays(y):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
def getFirstJan(y):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
def monthStartDays(y):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
def challenge019():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge019\challenge019.py:45:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
def challenge020():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge020\challenge020.py:21:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
def challenge021():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
        if a != b:
                  ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'
            if dict.has_key(b):
                   ^
    The {}.has_key() method is removed in Python 3: use the 'in' operator.

    Okay: if "alph" in d:\n    print d["alph"]
    W601: assert d.has_key('alph')
pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
def getNames(fp):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
def scoredNames(f):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge022\challenge022.py:37:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
def sumOfDivisors(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
def isSum(i, abundants):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1
def challenge023():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
def challenge024():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
    millionth = [n for n, i in zip(permutations, xrange(1000000)) if i == 999999]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge024\challenge024.py:17:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1
def challenge025():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge026\challenge026.py:1:1: F401 'string' imported but unused
import string
^
pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
def challenge026():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
#            print "%d(%d): %s" % (d, newSize, string.join([str(n) for n in numerators], ", "))
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
    return biggestD
    ^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge026\challenge026.py:28:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge027\challenge027.py:6:1: F401 'sqrt' imported but unused
from math import sqrt
^
pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
def challenge027():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
                if not isPrime(f): break
                                 ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge027\challenge027.py:35:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge028\challenge028.py:18:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge029\challenge029.py:17:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge030\challenge030.py:21:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
answer = 73682
              ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
def challenge031():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge031\challenge031.py:22:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
def challenge032():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge032\challenge032.py:26:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
def challenge033():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
#                        print "2/3: %s / %s = %g = %g / %g" % (num, den, fract, n2, d3)
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
#                        print "2/3: %s / %s = %g = %g / %g" % (num, den, fract, n2, d3)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
#                        print "1/4: %s / %s = %g = %g / %g" % (num, den, fract, n1, d4)
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
#                        print "1/4: %s / %s = %g = %g / %g" % (num, den, fract, n1, d4)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge033\challenge033.py:47:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
def getLimit():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
        if factSum < digits: break
                           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1
def challenge034():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge034\challenge034.py:45:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge035\challenge035.py:5:1: F401 'fact' imported but unused
from utils.numbers import sievedPrimes, fact
^
pemjh\challenge035\challenge035.py:5:1: F401 'sievedPrimes' imported but unused
from utils.numbers import sievedPrimes, fact
^
pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
def circulars(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
def challenge035():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
              if b == True and
              ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
              if b == True and
                   ^
    Comparison to singletons should use "is" or "is not".

    Comparisons to singletons like None should always be done
    with "is" or "is not", never the equality operators.

    Okay: if arg is not None:
    E711: if arg != None:
    E712: if arg == True:

    Also, beware of writing if x when you really mean if x is not None --
    e.g. when testing whether a variable or argument that defaults to None was
    set to some other value.  The other value might have a type (such as a
    container) that could be false in a boolean context!
pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
              ((p < 10) or not any(c in str(p) for c in disallowedChars))])
              ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge035\challenge035.py:58:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
def challenge036():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge036\challenge036.py:11:5: F841 local variable 'limit' is assigned to but never used
    limit = 1000000
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge036\challenge036.py:14:5: F841 local variable 'binary' is assigned to but never used
    binary = []
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge036\challenge036.py:29:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
def isTruncPrime(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
        if trunc <= 0: break
                     ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
        if trunc == 1 or not isPrime(trunc): return False
                                           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
        if trunc == 1 or not isPrime(n % divisor): return False
                                                 ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
def challenge037():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
def isPandigital(s):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
def challenge038():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge038\challenge038.py:26:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
           c = n - a - b
           ^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
           if (a**2 + b**2) == (c**2):
           ^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
def challenge039():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge039\challenge039.py:39:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
        total *= int (str(currentValue)[index - currentN - 1])
                    ^
    Avoid extraneous whitespace.

    Avoid extraneous whitespace in the following situations:
    - before the open parenthesis that starts the argument list of a
      function call.
    - before the open parenthesis that starts an indexing or slicing.

    Okay: spam(1)
    E211: spam (1)

    Okay: dict['key'] = list[index]
    E211: dict ['key'] = list[index]
    E211: dict['key'] = list [index]
pemjh\challenge040\challenge040.py:18:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
def challenge041():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
            if potential > highest: highest = potential
                                  ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge041\challenge041.py:22:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
def scoreWord(w):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
def challenge042():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge042\challenge042.py:41:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
def challenge043():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
    for n in [int(n) for n in permutate(source) \
                                                ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
                  if int(n) >= 1000000000 and \
                  ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
                  if int(n) >= 1000000000 and \
                                              ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
                  int(n[1:4]) % 2 == 0 and \
                  ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
                  int(n[1:4]) % 2 == 0 and \
                                           ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
                  int(n[2:5]) % 3 == 0 and \
                  ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
                  int(n[2:5]) % 3 == 0 and \
                                           ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
                  int(n[3:6]) % 5 == 0 and \
                  ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
                  int(n[3:6]) % 5 == 0 and \
                                           ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
                  int(n[4:7]) % 7 == 0 and \
                  ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
                  int(n[4:7]) % 7 == 0 and \
                                           ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
                  int(n[5:8]) % 11 == 0 and \
                  ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
                  int(n[5:8]) % 11 == 0 and \
                                            ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
                  int(n[6:9]) % 13 == 0 and \
                  ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
                  int(n[6:9]) % 13 == 0 and \
                                            ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
                  int(n[7:10]) % 17 == 0]:
                  ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge043\challenge043.py:26:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
def pent(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
def isPent(p):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
def challenge044():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
            if diff > 0 and diff < diffPkPj: break
                                           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
        if not performedOneStep: break
                               ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge044\challenge044.py:34:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
def hex(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
def pentAndHex():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
def challenge045():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge045\challenge045.py:34:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
def hasCriteria(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
    return False
                ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
def challenge046():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
        while n == 1 or isPrime(n): n += 2
                                  ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge046\challenge046.py:31:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
from itertools import count
^
pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
def numPrimeFactors(nPrimes):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
        n += 1
              ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
def hasNumPrimes(n, num):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
        if len(primes) > num: return False
                            ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
def challenge047():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
    count = 0
    ^
pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge048\challenge048.py:8:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
def challenge049():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
        if permutationPrimes.has_key(chars):
                            ^
    The {}.has_key() method is removed in Python 3: use the 'in' operator.

    Okay: if "alph" in d:\n    print d["alph"]
    W601: assert d.has_key('alph')
pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
    permutationPrimes = dict([(c, p) for c, p in permutationPrimes.iteritems() if len(p) > 2])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge049\challenge049.py:31:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge050\challenge050.py:4:1: F401 'isPrime' imported but unused
from utils.numbers import sievedPrimes, isPrime
^
pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
def challenge050():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
            if total >= limit: break
                             ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge050\challenge050.py:29:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
def substitutePrimes(n, substitute, checker):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
def has3SameDigits(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
    return False
                ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1
def challenge051():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
def challenge052():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
answer = 142857
               ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge052\challenge052.py:27:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
def challenge053():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge053\challenge053.py:19:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
def getDuplicateCounts(hand):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
        if valCounts.has_key(val):
                    ^
    The {}.has_key() method is removed in Python 3: use the 'in' operator.

    Okay: if "alph" in d:\n    print d["alph"]
    W601: assert d.has_key('alph')
pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
    return dict([[val, count] for val, count in valCounts.iteritems() if count > 1])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
def isStraight(hand):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
def isFlush(hand):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
def scoreHand(hand):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
def compareHands(handOne, handTwo):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
        for c1, c2 in [[c1[:2], c2[:2]] for c1, c2 in zip(reversed(handOne), reversed(handTwo))]:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
    faceConvert = {"2": "02", "3": "03", "4": "04", "5": "05", \
                                                               ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
                       "6": "06", "7": "07", "8": "08", "9": "09", "T": "10", \
                       ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
                       "6": "06", "7": "07", "8": "08", "9": "09", "T": "10", \
                                                                              ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
            cards = list(faceConvert[c[0]] + c[1] for c in l.strip().split(" "))
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
    return nHandOneWins
                       ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace
answer = 376
            ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
    workingN = `n`
               ^
    Backticks are removed in Python 3: use repr() instead.

    Okay: val = repr(1 + 2)
    W604: val = `1 + 2`
pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1
def challenge055():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge055\challenge055.py:26:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge056\challenge056.py:16:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge057\challenge057.py:20:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
from utils.numbers import isPrime, PrimeChecker
^
pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
def challenge058():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
    total = 1
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
def decrypt(key, code):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
def challenge059():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge059\challenge059.py:48:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
def getNumLength(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
def concat(m, n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
def isConcatPrime(new, existing):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
    #newFirst = concat(new, existing)
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
    #newLast = concat(existing, new)
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
def getPrimePairs(primes):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
def nextDigits(found, nToFind, primes, limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
        #print "%s\t%d\t%d" % (found, i, limit)
        ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
                foundSolution = nextDigits(found + [i], nToFind - 1, [p for p in primes if p > i], currentSolutionSum)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
    return currentSolution
                          ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
def nextDigitsDict(found, nToFind, pairs, limit, potential):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
        #print "%s\t%d\t%d" % (found, p, limit)
        ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
            # For potential, find the current entry in pairs and do a intersection with the potential and the pairs set to get new potentials
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
    return currentSolution
    ^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
def challenge060():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
#    primes = [1, 3, 7, 37, 73, 109, 673, 1093, 1097, 3109, 3673, 6733, 6737, 7109, 7673, 109673, 673109]
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
#    primes = [1, 3, 7, 37, 73, 109, 673, 1093, 1097, 3109, 3673, 6733, 6737, 7109, 7673, 109673, 673109]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace
#    primes = [1, 3, 7, 37, 73, 109, 673, 1093, 1097, 3109, 3673, 6733, 6737, 7109, 7673, 109673, 673109]
                                                                                                         ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
def hasDuplicates(nums):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
def eachInList(nums, lists):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
def challenge061():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'
        if (not suffix in d) or (suffix == prefix):
            ^
    Negative comparison should be done using "not in" and "is not".

    Okay: if x not in y:\n    pass
    Okay: assert (X in Y or X is Z)
    Okay: if not (X in Y):\n    pass
    Okay: zz = x is not y
    E713: Z = not X in Y
    E713: if not X.B in Y:\n    pass
    E714: if not X is Y:\n    pass
    E714: Z = not X.B is Y
pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
def challenge062():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
        if cubes.has_key(cubed):
                ^
    The {}.has_key() method is removed in Python 3: use the 'in' operator.

    Okay: if "alph" in d:\n    print d["alph"]
    W601: assert d.has_key('alph')
pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
def challenge063():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
        if highest == 10: highest -= 1
                        ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
        if lowest > highest: break
                           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge063\challenge063.py:27:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
def getPeriodLength(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
def challenge064():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
        length = len(list(continueGenerator(n))) - 1 #getPeriodLength(n)
                                                    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '
        length = len(list(continueGenerator(n))) - 1 #getPeriodLength(n)
                                                     ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge065\challenge065.py:4:1: F401 'divisors' imported but unused
from utils.numbers import divisors
^
pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
def challenge065():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
def isSquare(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
def diophantineX(d):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
def challenge066():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)
    solutions = [[d, diophantineX(d)] for d in xrange(1, limit + 1) if not isSquare(d)]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
def challenge067():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge067\challenge067.py:24:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
def getSpokes(score, start, startIndex, choice, nSpokes):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
def challenge068():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)
                solution.extend([[left[0], solution[limit - 2][2], solution[0][1]]])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1
def challenge069():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
import string
^
pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
def isPermutation(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1
def challenge070():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
def challenge071():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)
                if num / targetNum == den / targetDen: continue
                                                     ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1
def challenge072():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
def shareDivisors(n1, n2):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
def challenge073():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
        lowerLimit = int(lowerLimit + 1 if lowerLimit % 1 == 0 else \
                                                                    ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
                             ceil(lowerLimit))
                             ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
        upperLimit = int(upperLimit - 1 if upperLimit % 1 == 0 else \
                                                                    ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
                             floor(upperLimit))
                             ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge073\challenge073.py:31:9: F841 local variable 'rangeLimits' is assigned to but never used
        rangeLimits = [lowerLimit, upperLimit]
        ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
    facts = {"0": 1, "1": 1, "2": 2, "3": 6, "4": 24, "5": 120, "6": 720, "7": 5040, "8": 40320, "9": 362880}
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
def chainSize(n, known):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
    while not w in route:
          ^
    Negative comparison should be done using "not in" and "is not".

    Okay: if x not in y:\n    pass
    Okay: assert (X in Y or X is Z)
    Okay: if not (X in Y):\n    pass
    Okay: zz = x is not y
    E713: Z = not X in Y
    E713: if not X.B in Y:\n    pass
    E714: if not X is Y:\n    pass
    E714: Z = not X.B is Y
pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
def challenge074():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge074\challenge074.py:27:5: F841 local variable 'target' is assigned to but never used
    target = 60
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
def challenge075():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
    for total, a, b, c in [(a + b + c, a, b, c) for a, b, c in getPrimitiveTriples(limit)]:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
    if known.has_key(n):
            ^
    The {}.has_key() method is removed in Python 3: use the 'in' operator.

    Okay: if "alph" in d:\n    print d["alph"]
    W601: assert d.has_key('alph')
pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
        if known[n].has_key(last):
                   ^
    The {}.has_key() method is removed in Python 3: use the 'in' operator.

    Okay: if "alph" in d:\n    print d["alph"]
    W601: assert d.has_key('alph')
pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
def challenge076():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
def challenge077():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)
            for abSums in [sorted(aSum + bSum) for aSum in nums[a] for bSum in nums[b]]:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
	j, k, s = 1, 1, 0
^
    Never mix tabs and spaces.

    The most popular way of indenting Python is with spaces only.  The
    second-most popular way is with tabs only.  Code indented with a mixture
    of tabs and spaces should be converted to using spaces exclusively.  When
    invoking the Python command line interpreter with the -t option, it issues
    warnings about code that illegally mixes tabs and spaces.  When using -tt
    these warnings become errors.  These options are highly recommended!

    Okay: if a == 0:\n        a = 1\n        b = 1
    E101: if a == 0:\n        a = 1\n\tb = 1
pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
	j, k, s = 1, 1, 0
^
    For new projects, spaces-only are strongly recommended over tabs.

    Okay: if True:\n    return
    W191: if True:\n\treturn
pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
	while j > 0:
^
    For new projects, spaces-only are strongly recommended over tabs.

    Okay: if True:\n    return
    W191: if True:\n\treturn
pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
            j = i - (3 * k * k - k) // 2
^
    Never mix tabs and spaces.

    The most popular way of indenting Python is with spaces only.  The
    second-most popular way is with tabs only.  Code indented with a mixture
    of tabs and spaces should be converted to using spaces exclusively.  When
    invoking the Python command line interpreter with the -t option, it issues
    warnings about code that illegally mixes tabs and spaces.  When using -tt
    these warnings become errors.  These options are highly recommended!

    Okay: if a == 0:\n        a = 1\n        b = 1
    E101: if a == 0:\n        a = 1\n\tb = 1
pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
	p[i] = s
^
    Never mix tabs and spaces.

    The most popular way of indenting Python is with spaces only.  The
    second-most popular way is with tabs only.  Code indented with a mixture
    of tabs and spaces should be converted to using spaces exclusively.  When
    invoking the Python command line interpreter with the -t option, it issues
    warnings about code that illegally mixes tabs and spaces.  When using -tt
    these warnings become errors.  These options are highly recommended!

    Okay: if a == 0:\n        a = 1\n        b = 1
    E101: if a == 0:\n        a = 1\n\tb = 1
pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
	p[i] = s
^
    For new projects, spaces-only are strongly recommended over tabs.

    Okay: if True:\n    return
    W191: if True:\n\treturn
pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs

^
    Never mix tabs and spaces.

    The most popular way of indenting Python is with spaces only.  The
    second-most popular way is with tabs only.  Code indented with a mixture
    of tabs and spaces should be converted to using spaces exclusively.  When
    invoking the Python command line interpreter with the -t option, it issues
    warnings about code that illegally mixes tabs and spaces.  When using -tt
    these warnings become errors.  These options are highly recommended!

    Okay: if a == 0:\n        a = 1\n        b = 1
    E101: if a == 0:\n        a = 1\n\tb = 1
pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge079\challenge079.py:2:1: F401 'string' imported but unused
import string
^
pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
def challenge079():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
    # Looked at each pair and tried to find any answers that show values between
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge079\challenge079.py:14:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
def buildRoot(sq, n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
    for i in xrange(n):
                       ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
def challenge080():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
def addRows(rows):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1
def challenge081():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge082\challenge082.py:3:1: F401 'izip' imported but unused
from itertools import izip
^
pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
def combineColumns(c1, c2):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
        if previous != None:
                    ^
    Comparison to singletons should use "is" or "is not".

    Comparisons to singletons like None should always be done
    with "is" or "is not", never the equality operators.

    Okay: if arg is not None:
    E711: if arg != None:
    E712: if arg == True:

    Also, beware of writing if x when you really mean if x is not None --
    e.g. when testing whether a variable or argument that defaults to None was
    set to some other value.  The other value might have a type (such as a
    container) that could be false in a boolean context!
pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
        if previous != None:
                    ^
    Comparison to singletons should use "is" or "is not".

    Comparisons to singletons like None should always be done
    with "is" or "is not", never the equality operators.

    Okay: if arg is not None:
    E711: if arg != None:
    E712: if arg == True:

    Also, beware of writing if x when you really mean if x is not None --
    e.g. when testing whether a variable or argument that defaults to None was
    set to some other value.  The other value might have a type (such as a
    container) that could be false in a boolean context!
pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1
def challenge082():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
def getGrid():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
def compareToProcess(m, n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
def challenge083():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
    grid = map(lambda row: map(lambda square: [square, None, False], row), grid)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge083\challenge083.py:40:5: F841 local variable 'processed' is assigned to but never used
    processed = set()
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
                      if nx >= 0 and nx < width and \
                                                    ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
                          ny >= 0 and ny < height and \
                          ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
                          ny >= 0 and ny < height and \
                                                      ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
                          grid[ny][nx][2] == False]
                          ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'
                          grid[ny][nx][2] == False]
                                          ^
    Comparison to singletons should use "is" or "is not".

    Comparisons to singletons like None should always be done
    with "is" or "is not", never the equality operators.

    Okay: if arg is not None:
    E711: if arg != None:
    E712: if arg == True:

    Also, beware of writing if x when you really mean if x is not None --
    e.g. when testing whether a variable or argument that defaults to None was
    set to some other value.  The other value might have a type (such as a
    container) that could be false in a boolean context!
pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
def rollDice():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
def chanceCardMove(current, prev = [0]):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
def chanceCardMove(current, prev = [0]):
                                ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
def chanceCardMove(current, prev = [0]):
                                  ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
def communityChestCardMove(current, prev = [0]):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
def communityChestCardMove(current, prev = [0]):
                                        ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
def communityChestCardMove(current, prev = [0]):
                                          ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
def challenge084():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
            # Reduce double count by 1 to allow for the next throw to do the same
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace
            current = chanceCardMove(current)
                                             ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
def challenge085():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
    closest = target # ie 0
                    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment
                    break # Cannot improve
                         ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
def isInt(a, msq, sqLib, found = list()):
                              ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
def isInt(a, msq, sqLib, found = list()):
                                ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
def getNumPairs(pairSum, limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
def getStepSize(m, sqLib):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
    return sum(getNumPairs(a, m) for a in range(2, (2 * m) + 1) if isInt(a, msq, sqLib))
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1
def challenge086():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge087\challenge087.py:5:1: F401 'sqrt' imported but unused
from math import sqrt
^
pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1
def challenge087():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge088\challenge088.py:1:1: F401 'ceil' imported but unused
from math import ceil
^
pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
def findPossibleProducts(limit, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
def findPossibleProducts(limit, known = dict()):
                                     ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
def findPossibleProducts(limit, known = dict()):
                                       ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
def challenge088():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace
    found = [2 * i for i in xrange(limit + 1)]
                                              ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
#    1. Only I, X, and C can be used as the leading numeral in part of a subtractive pair.
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
def convertChar(c):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
def decypherNumeral(s):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
def getNumeral(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
                [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'],
                                                          ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
def getRomanNumeralSaving(s):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1
def challenge089():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
def get6Combs(cube):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
    else: # 2
         ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
def fillRemaining(cube):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
def validAddition(cube, newFace):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
def amendCubesForSquare(cube0, cube1, square):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
def buildCubes(cube0, cube1, squaresLeft):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
#    print cube0, cube1, squaresLeft
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
def challenge090():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge090\challenge090.py:119:5: F841 local variable 'possibleNumbers' is assigned to but never used
    possibleNumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1
def challenge091():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
def getDigits(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
def challenge092old():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
                for d in [int(m) for m in str(workingN)]:#getDigits(workingN):
                                                         ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
                for d in [int(m) for m in str(workingN)]:#getDigits(workingN):
                                                         ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
def challenge092b():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:42:9: F841 local variable 'route' is assigned to but never used
        route = list()
        ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
            for i, c in enumerate(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]):
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
def buildNumber():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
def numbers(current, start, end, digits):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
def permutations(digits):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
def squareVal(num):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
def is89(num):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
def challenge092():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge092\challenge092.py:123:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
def combinations(left):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
def equate(a, b, op):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
def selection(l, left):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
def equatedNumbers(a, b, c, d, operators):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
        try: nums.append(ops[2](ops[1](ops[0](a, b), c), d))
           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
        except: pass
              ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
        try: nums.append(ops[2](ops[0](a, ops[1](b, c)), d))
           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
        except: pass
              ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
        try: nums.append(ops[1](ops[0](a, b), ops[2](c, d)))
           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
        except: pass
              ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
        try: nums.append(ops[0](a, ops[2](ops[1](b, c), d)))
           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
        except: pass
              ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
        try: nums.append(ops[0](a, ops[1](b, ops[2](c, d))))
           ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
        except: pass
              ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
def challenge093():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
                        for n in equatedNumbers(com[0], com[1], com[2], com[3], operators):
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1
def process(limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
#    yield 0
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
#        yield nums[root]
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
def chainLengths(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1
def challenge095():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge096\challenge096.py:3:1: F401 'sys' imported but unused
import sys
^
pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
def sortSquareLengths(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
class SGrid:
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
        #for r in xrange(9):
        ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
        self.__removeValueFromList([self.__rows[i][c] for i in xrange(9)], value)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
        blocks.extend([[self.__rows[i][j] for i in xrange(9)] for j in xrange(9)])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
        # Cycle through the rows and find any single value squares that aren't True
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
                    self.__setValue(self.__rows.index(r), r.index(sq), sq[0][0])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
        # Loop through each block (row, column, box) and check for sets of numbers that are the same. Remove these numbers from all others in the list
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
                    # If count matches length then remove the values from all non-matching squares
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
        return True
                   ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
def challenge096():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
    #puzzle = [
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
    #ans = SGrid(puzzle)
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '
    #print ans
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge097\challenge097.py:7:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
def getMap(word, square):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
def uniqueRight(map):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
def mapWord(word, map):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
def challenge098():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
    groupedWords = dict([(key, groupedWords[key]) for key in groupedWords if len(groupedWords[key]) > 1])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
                # Make sure the word maps onto word1 (duplicate letters/numbers etc)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)
#                            print word1, word2, potentialSquare, mapWord(word2, map)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
def challenge099():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge099\challenge099.py:19:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
    sequence = [1 - i + i**2 - i**3 + i**4 - i**5 + i**6 - i**7 + i**8 - i**9 + i**10 for i in xrange(1, highestPower + 2)]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
def enclosesOrigin(x1, y1, x2, y2, x3, y3):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
def getYIntercept(x1, y1, x2, y2):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
def challenge102():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block
#    print enclosesOrigin(162.0, 570.0, 628.0, 485.0, -807.0, -896.0)
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
def valid(l):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
def challenge103():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
        if sum(newSet) < sumAns or sumAns == None:
                                          ^
    Comparison to singletons should use "is" or "is not".

    Comparisons to singletons like None should always be done
    with "is" or "is not", never the equality operators.

    Okay: if arg is not None:
    E711: if arg != None:
    E712: if arg == True:

    Also, beware of writing if x when you really mean if x is not None --
    e.g. when testing whether a variable or argument that defaults to None was
    set to some other value.  The other value might have a type (such as a
    container) that could be false in a boolean context!
pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge104\challenge104.py:1:1: F401 'fibo' imported but unused
from utils.numbers import fibo
^
pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
def myEnumerate(seq, start=0):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
def fiboTrunc(trunc):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
def challenge104():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment
    lowerLimit = 123456788 # Must be at least greater than this
                          ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
def sizedSubsets(l, size):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
def checkForDuplicateSetSums(l):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
def valid(l):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
    # Get the largest set from small numbers and the smaller set from large numbers
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
def challenge105():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
#    import profile
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block
#    print profile.run("print challenge105()")
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
def allSubsets(size):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
def score(l):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
def getRequiredCompares(size):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
    # Filter out those with size 1 subsets, we already know these cannot be equal
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
def challenge106():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

^
    Trailing blank lines are superfluous.

    Okay: spam(1)
    W391: spam(1)\n

    However the last line should end with a new line (warning W292).
pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
def skimNetwork(grid):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
    availableConnections = sorted([(l, 0, i) for i, l in enumerate(grid[0]) if l > 0])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
        availableConnections = [link for link in availableConnections if link[2] not in connectedRows]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
        availableConnections.extend([(l, shortest[2], i) for i, l in enumerate(grid[shortest[2]]) if (l > 0) and not (i in connectedRows)])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
def scoreGrid(grid):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
def challenge107():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)
            grid.append([int(link) if link != "-" else 0 for link in line.strip().split(",")])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                              ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                         ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                           ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
#            print "over", mult, answer
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
            next = mult * primeIndices(target // index, index - 1, primes, primeIndex + 1, answer)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1
def challenge108():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
def getNonDoubleOuts(n, darts, nums, known = dict()):
                                          ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
def getNonDoubleOuts(n, darts, nums, known = dict()):
                                            ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
def getDoubleOuts(n, nums, doubles):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1
def challenge109():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                              ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                         ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                           ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
#            print "over", mult, answer
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
            next = mult * primeIndices(target // index, index - 1, primes, primeIndex + 1, answer)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
def challenge110():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

^
    Trailing blank lines are superfluous.

    Okay: spam(1)
    W391: spam(1)\n

    However the last line should end with a new line (warning W292).
pemjh\challenge111\challenge111.py:1:1: F401 'roughPrimes' imported but unused
from utils.numbers import PrimeChecker, roughPrimes
^
pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
def isPrime(p, pc = PrimeChecker()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
def isPrime(p, pc = PrimeChecker()):
                 ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
def isPrime(p, pc = PrimeChecker()):
                   ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
def buildNums(repeated, other):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
def challenge111():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
        for m in [list(("%0" + str(10 - M[i]) + "d") % m) for m in xrange(0, 10**(10 - M[i]))]:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)
                for b in [int("".join(b)) for b in buildNums([str(i)] * M[i], m)]:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
def challenge112():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)
        if (currentBouncy / currentNumber) >= target: break
                                                    ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1
def challenge113():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tileSizes, known = dict()):
                                          ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tileSizes, known = dict()):
                                            ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
def process(blocks):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1
def challenge114():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, minimum, tileSizes, known = dict()):
                                                   ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, minimum, tileSizes, known = dict()):
                                                     ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
def f(minimum, blocks):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1
def challenge115():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                       ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                         ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                                     ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                                       ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
def process(blocks):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1
def challenge116():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tileSizes, known = dict()):
                                          ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tileSizes, known = dict()):
                                            ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
def process(blocks):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1
def challenge117():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
def too_long(current_length, last_length):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
def valid(num):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
def build_sets(existing, left, lExist = 0):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
def build_sets(existing, left, lExist = 0):
                                     ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
def build_sets(existing, left, lExist = 0):
                                       ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
def challenge118():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
        perms.extend([l for l in permutations("123456789", size) if l[-1] != 2 and l[-1] != "5"])
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1
def challenge118_2():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
def an(target):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1
def challenge119():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1
def challenge120():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
def winChance(probs, losses): # probs are always 1 in...
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
def winChance(probs, losses): # probs are always 1 in...
                             ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
def play(turns):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1
def challenge121():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
def getRemainder(p, n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1
def challenge123():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
def sort124(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
        ((a[0] == b[0]) and (a[1] > b[1]))):
    ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
        ((a[0] == b[0]) and (a[1] < b[1]))):
        ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1
def challenge124():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
    return (x * y + x * z + y * z) * 2 + (x + y + z + layer - 2) * 4 * (layer - 1)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
    return (x * y + x * z + y * z) * 2 + (x + y + z + layer - 2) * 4 * (layer - 1)
                                                                                  ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
def challenge126():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
            while(surroundingCubes(a, maximumB, 1, depth) < maximumResult and maximumB <= a):
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)
                while(surroundingCubes(a, b, maximumC, depth) < maximumResult and maximumC <= b):
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
def challenge127():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','
    rads = [1,] * maximum
             ^
    Each comma, semicolon or colon should be followed by whitespace.

    Okay: [a, b]
    Okay: (3,)
    Okay: a[1:4]
    Okay: a[:4]
    Okay: a[1:]
    Okay: a[1:4:2]
    E231: ['a','b']
    E231: foo(bar,baz)
    E231: [{'a':'b'}]
pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
def nPrimes(primes, s):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
def challenge128():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
        if nPrimes(primes, [end - current, 6 * layer + 1, 6 * layer + (6 * (layer + 1)) - 1]) == 3:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)
        if nPrimes(primes, [end - current, 6 * layer + 6 * (layer - 1) - 1, 6 * (layer + 1) - 1]) == 3:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1
def challenge129():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
def A(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
def challenge130():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
    limit = 14702 # Optimised value
                 ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)
    for n in [n for n in xrange(5, limit, 2) if (n % 5 != 0) and n not in primes]:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1
def challenge131():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
def R(k):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
            if len(facts) == 40: break
                               ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1
def challenge132():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
def divs_repunit(n, limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
def challenge133():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)
    divs = [prime for prime in list(sievedPrimes(100000))[1:] if not divs_repunit(prime, limit)]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
def jumpSize(t, c, s):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
def f(target, current, step):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
def challenge134():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block
#    print f(101, 103, 103), slowWay(101, 103)
^
    Use 4 spaces per indentation level.

    For really old code that you don't want to mess up, you can continue to
    use 8-space tabs.

    Okay: a = 1
    Okay: if a == 0:\n    a = 1
    E111:   a = 1

    Okay: for item in items:\n    pass
    E112: for item in items:\npass

    Okay: a = 1\nb = 2
    E113: a = 1\n    b = 2
pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1
def challenge135():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
def getNumTarget(limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
                total += 1
                          ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1
def challenge136():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
def a(n, known = {0: 0, 1: 2, 2: 15}):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
def a(n, known = {0: 0, 1: 2, 2: 15}):
              ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
def a(n, known = {0: 0, 1: 2, 2: 15}):
                ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1
def challenge137():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
def challenge138():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)
            b1.next(); b2.next()
                     ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1
def challenge139():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
def valid(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
def challenge142():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)
                    intersect = set(highest[first]).intersection(set(matches[matches.index(first) + 1:]))
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
def solveQuadratic(a, b, c):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
def reflect(x, y, gradient):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
def nextStep(start):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
def exiting(point):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1
def challenge144():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
def is_pseudo_prime(n, known = {1: True, 2: True}):
                            ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
def is_pseudo_prime(n, known = {1: True, 2: True}):
                              ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
def test(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
def challenge146():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
    ns = [n for n in range(10, maximum, 30) + range(20, maximum, 30) if \
                                                                        ^
    Avoid explicit line join between brackets.

    The preferred way of wrapping long lines is by using Python's implied line
    continuation inside parentheses, brackets and braces.  Long lines can be
    broken over multiple lines by wrapping expressions in parentheses.  These
    should be used in preference to using a backslash for line continuation.

    E502: aaa = [123, \\n       123]
    E502: aaa = ("bbb " \\n       "ccc")

    Okay: aaa = [123,\n       123]
    Okay: aaa = ("bbb "\n       "ccc")
    Okay: aaa = "bbb " \\n    "ccc"
pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent
              n % 7 == 3 or n % 7 == 4]
              ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
def get_non_7s(row):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
    return get_non_7s(complete_rows) * big_triangle + incomplete_triangles * get_non_7s(extra_rows)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1
def challenge148():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
def sk2(sk24, sk55):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
def snake(l):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1
def challenge149():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1
def challenge151():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
    total = sum(15 * 16**(n - 1) + 41 * 14**(n - 1) - (43 * 15**(n - 1) + 13**n)for n in xrange(3, 17))
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
def numLosses(size, previousThree, useZero, known = dict()):
                                                 ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
def numLosses(size, previousThree, useZero, known = dict()):
                                                   ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
                                     (previousThree[1], previousThree[2], next),
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
                                            sq[7] = side_total - sq[4] - sq[5] - sq[6]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
                                                sq10min = side_total - sq[8] - sq[9] + 1
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
                                                sq10min = sq10min if sq10min < 10 else 10
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
                                                for sq[10] in xrange(0, sq10min):
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
                                                    sq[11] = side_total - sq[8] - sq[9] - sq[10]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
                                                    if sq[11] >= 0 and sq[11] < 10:
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
                                                        sq[13] = side_total - sq[1] - sq[5] - sq[9]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
                                                        sq[14] = side_total - sq[2] - sq[6] - sq[10]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
                                                        sq[15] = side_total - sq[12] - sq[13] - sq[14]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)
                                                                (sq[5] + sq[10] + sq[15]) == (side_total - sq[0]):
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
def challenge173():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
def getDivisors(n, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
def getDivisors(n, known = dict()):
                        ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
def getDivisors(n, known = dict()):
                          ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
def getNumEvenDivisors(n, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
def getNumEvenDivisors(n, known = dict()):
                               ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
def getNumEvenDivisors(n, known = dict()):
                                 ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
def challenge174():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1
def challenge179():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
def pf(n, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
def pf(n, known = dict()):
               ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
def pf(n, known = dict()):
                 ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
def factPower(b, f, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
def factPower(b, f, known = dict()):
                         ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
def factPower(b, f, known = dict()):
                           ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
def terminates(n, d):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
    # Loop through denominator factors and cancel out any in the numerator or any terminating denominators
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
    dFacts = [fact for fact in dFacts if fact not in termDen and (factPower(d, fact) > factPower(n, fact))]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
def M(N):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
def SD(limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
def challenge183():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

^
    Trailing blank lines are superfluous.

    Okay: spam(1)
    W391: spam(1)\n

    However the last line should end with a new line (warning W292).
pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
def semiprimes(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1
def challenge187():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1
def challenge188():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1
def challenge190():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
def numLosses(days, previousThree, latesLeft, known = dict()):
                                                   ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
def numLosses(days, previousThree, latesLeft, known = dict()):
                                                     ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
            nVariations += numLosses(days - 1,
                                              ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
                                     (previousThree[1], previousThree[2], next),
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
                                                             ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
                                                               ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
                nVariations += numVariations(blocks - 1, ["0", "1", "2"], losingPatterns)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
                        nVariations += numVariations(blocks - lTilePattern, tilePatterns, losingPatterns)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
                        nVariations += numVariations(blocks - lPattern, tilePatterns, losses)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1
def challenge191():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
def challenge197():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge197\challenge197.py:10:5: F841 local variable 'odd' is assigned to but never used
    odd = 0
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
def challenge203():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
            if n%p == 0:
                ^
    Surround operators with a single space on either side.

    - Always surround these binary operators with a single space on
      either side: assignment (=), augmented assignment (+=, -= etc.),
      comparisons (==, <, >, !=, <=, >=, in, not in, is, is not),
      Booleans (and, or, not).

    - If operators with different priorities are used, consider adding
      whitespace around the operators with the lowest priorities.

    Okay: i = i + 1
    Okay: submitted += 1
    Okay: x = x * 2 - 1
    Okay: hypot2 = x * x + y * y
    Okay: c = (a + b) * (a - b)
    Okay: foo(bar, key='word', *args, **kwargs)
    Okay: alpha[:-i]

    E225: i=i+1
    E225: submitted +=1
    E225: x = x /2 - 1
    E225: z = x **y
    E226: c = (a+b) * (a-b)
    E226: hypot2 = x*x + y*y
    E227: c = a|b
    E228: msg = fmt%(errno, errmsg)
pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
def getHams(current, limit, primes):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
def hamNums(maxPrime, limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge204\challenge204.py:23:5: F841 local variable 'found' is assigned to but never used
    found = set()
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1
def challenge204():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
        return iter(((),)) # yield tuple()
                          ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
    return (items + (item,)
                           ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
def diceRolls(nDice, nSides):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
def challenge205():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge206\challenge206.py:1:1: F401 'floor' imported but unused
from math import sqrt, ceil, floor
^
pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
def splice(mask, values):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
def hasMask(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
def challenge206():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)
            if root == current: root += 1
                              ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge211\challenge211.py:2:1: F401 'takewhile' imported but unused
from itertools import takewhile
^
pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
def squareSum(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
def slowButRight(limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
    return [n for sq, n in ((squareSum(n), n) for n in xrange(limit, 0, -1) if n not in primes) if isSquare(sq)]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
def sigma2(n, primes):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
def working(limit):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
def challenge211(calc = False):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
def challenge211(calc = False):
                     ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
def challenge211(calc = False):
                       ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
        return sum(ans) #, sum(ans2)
                       ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '
        return sum(ans) #, sum(ans2)
                        ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge214\challenge214.py:1:1: F401 'phi' imported but unused
from utils.numbers import sievedPrimes, primeFactors, phi
^
pemjh\challenge214\challenge214.py:1:1: F401 'primeFactors' imported but unused
from utils.numbers import sievedPrimes, primeFactors, phi
^
pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
def totients(n, primes = None):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
def totients(n, primes = None):
                      ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
def totients(n, primes = None):
                        ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
    if primes == None:
              ^
    Comparison to singletons should use "is" or "is not".

    Comparisons to singletons like None should always be done
    with "is" or "is not", never the equality operators.

    Okay: if arg is not None:
    E711: if arg != None:
    E712: if arg == True:

    Also, beware of writing if x when you really mean if x is not None --
    e.g. when testing whether a variable or argument that defaults to None was
    set to some other value.  The other value might have a type (such as a
    container) that could be false in a boolean context!
pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
def totientChainLength(n, current, limit, steps, known = dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
def totientChainLength(n, current, limit, steps, known = dict()):
                                                      ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
def totientChainLength(n, current, limit, steps, known = dict()):
                                                        ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
def challenge214():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
    #phi(40000000)
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '
    #totients(40000000)
    ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
    return options
                  ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
def runningCrack(row1, row2):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
def W(startRow, depth, data, known=dict()):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
    if not key in known:
       ^
    Negative comparison should be done using "not in" and "is not".

    Okay: if x not in y:\n    pass
    Okay: assert (X in Y or X is Z)
    Okay: if not (X in Y):\n    pass
    Okay: zz = x is not y
    E713: Z = not X in Y
    E713: if not X.B in Y:\n    pass
    E714: if not X is Y:\n    pass
    E714: Z = not X.B is Y
pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
def challenge215():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)
        linked = list(subRow for subRow in rows if not runningCrack(row, subRow))
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
def l(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
def sq(a, p):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
def challenge216(skip = True):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
def challenge216(skip = True):
                     ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
def challenge216(skip = True):
                       ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
    primes[0:2] = [False,False]
                        ^
    Each comma, semicolon or colon should be followed by whitespace.

    Okay: [a, b]
    Okay: (3,)
    Okay: a[1:4]
    Okay: a[:4]
    Okay: a[1:]
    Okay: a[1:4:2]
    E231: ['a','b']
    E231: foo(bar,baz)
    E231: [{'a':'b'}]
pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
    t[0:2] = [False,False]
                   ^
    Each comma, semicolon or colon should be followed by whitespace.

    Okay: [a, b]
    Okay: (3,)
    Okay: a[1:4]
    Okay: a[:4]
    Okay: a[1:]
    Okay: a[1:4:2]
    E231: ['a','b']
    E231: foo(bar,baz)
    E231: [{'a':'b'}]
pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
    c = [0,1]
          ^
    Each comma, semicolon or colon should be followed by whitespace.

    Okay: [a, b]
    Okay: (3,)
    Okay: a[1:4]
    Okay: a[:4]
    Okay: a[1:]
    Okay: a[1:4:2]
    E231: ['a','b']
    E231: foo(bar,baz)
    E231: [{'a':'b'}]
pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
    c2 = [-c2[1],c2[0]]
                ^
    Each comma, semicolon or colon should be followed by whitespace.

    Okay: [a, b]
    Okay: (3,)
    Okay: a[1:4]
    Okay: a[:4]
    Okay: a[1:]
    Okay: a[1:4:2]
    E231: ['a','b']
    E231: foo(bar,baz)
    E231: [{'a':'b'}]
pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1
def challenge220():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)
    # Prime factors cycle, wait until back to 1, 1, 1 and there is no answer, else the answer has been found
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge230\challenge230.py:2:5: F841 local variable 'size' is assigned to but never used
    size = len(a)
    ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
def challenge230():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
    a = "1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
    b = "8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196"
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge230\challenge230.py:52:5: F401 'sys' imported but unused
    import sys
    ^
pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
def getFirstMultipleOnOrAfter(target, divisor):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
def getFirstMultipleOnOrBefore(target, divisor):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
def numInRange(start, end, step):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
def challenge231():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge231\challenge231.py:36:9: F841 local variable 'index' is assigned to but never used
        index = 1
        ^
    Indicates that a variable has been explicity assigned to but not actually
    used.
pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace
            numRange = (getFirstMultipleOnOrAfter(n - k + 1, current),
                                                                      ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
def myrange(low, high, step):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
def challenge234():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
        lows = set(myrange(current**2 + current,
                                                ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
                          next**2 if next**2 < limit + 1 else limit + 1,
                          ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent
                          current))
                          ^
    Continuation lines indentation.

    Continuation lines should align wrapped elements either vertically
    using Python's implicit line joining inside parentheses, brackets
    and braces, or using a hanging indent.

    When using a hanging indent these considerations should be applied:
    - there should be no arguments on the first line, and
    - further indentation should be used to clearly distinguish itself as a
      continuation line.

    Okay: a = (\n)
    E123: a = (\n    )

    Okay: a = (\n    42)
    E121: a = (\n   42)
    E122: a = (\n42)
    E123: a = (\n    42\n    )
    E124: a = (24,\n     42\n)
    E125: if (\n    b):\n    pass
    E126: a = (\n        42)
    E127: a = (24,\n      42)
    E128: a = (24,\n    42)
    E129: if (a or\n    b):\n    pass
    E131: a = (\n    42\n 24)
pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
def prime_factors(number, primes):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
def phi(number, primes):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
def challenge243():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
        if prime == 1: continue
                     ^
    Compound statements (on the same line) are generally discouraged.

    While sometimes it's okay to put an if/for/while with a small body
    on the same line, never do this for multi-clause statements.
    Also avoid folding such long lines!

    Okay: if foo == 'blah':\n    do_blah_thing()
    Okay: do_one()
    Okay: do_two()
    Okay: do_three()

    E701: if foo == 'blah': do_blah_thing()
    E701: for x in lst: total += x
    E701: while t < 10: t = delay()
    E701: if foo == 'blah': do_blah_thing()
    E701: else: do_non_blah_thing()
    E701: try: something()
    E701: finally: cleanup()
    E701: if foo == 'blah': one(); two(); three()

    E702: do_one(); do_two(); do_three()
    E703: do_four();  # useless semicolon
pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
                    d = found * m
                                 ^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
                    ratio = float(phi(d, primes))/ float(d - 1)
                                                 ^
    Surround operators with a single space on either side.

    - Always surround these binary operators with a single space on
      either side: assignment (=), augmented assignment (+=, -= etc.),
      comparisons (==, <, >, !=, <=, >=, in, not in, is, is not),
      Booleans (and, or, not).

    - If operators with different priorities are used, consider adding
      whitespace around the operators with the lowest priorities.

    Okay: i = i + 1
    Okay: submitted += 1
    Okay: x = x * 2 - 1
    Okay: hypot2 = x * x + y * y
    Okay: c = (a + b) * (a - b)
    Okay: foo(bar, key='word', *args, **kwargs)
    Okay: alpha[:-i]

    E225: i=i+1
    E225: submitted +=1
    E225: x = x /2 - 1
    E225: z = x **y
    E226: c = (a+b) * (a-b)
    E226: hypot2 = x*x + y*y
    E227: c = a|b
    E228: msg = fmt%(errno, errmsg)
pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

^
    Trailing blank lines are superfluous.

    Okay: spam(1)
    W391: spam(1)\n

    However the last line should end with a new line (warning W292).
pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
            # Each space is the number of itself, + the number that can become it
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
            mods = [(mods[k] + mods[(k - i) % 250]) % 10**16 for k in xrange(250)]
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1
def challenge250():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
def tidy(a):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
def add(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
def sub(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
def mul(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
def div(a, b):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
def get_totals(start, end, known = {}):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
def get_totals(start, end, known = {}):
                                ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
def get_totals(start, end, known = {}):
                                  ^
    Don't use spaces around the '=' sign in function arguments.

    Don't use spaces around the '=' sign when used to indicate a
    keyword argument or a default parameter value.

    Okay: def complex(real, imag=0.0):
    Okay: return magic(r=real, i=imag)
    Okay: boolean(a == b)
    Okay: boolean(a != b)
    Okay: boolean(a <= b)
    Okay: boolean(a >= b)

    E251: def complex(real, imag = 0.0):
    E251: return magic(r = real, i = imag)
pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
def challenge259(skip=True):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)
    return sum(x[0] for x in get_totals(lower, limit) if x[1] == 1 and x[0] > 0)
                                                                               ^
    Limit all lines to a maximum of 79 characters.

    There are still many devices around that are limited to 80 character
    lines; plus, limiting windows to 80 characters makes it possible to have
    several windows side-by-side.  The default wrapping on such devices looks
    ugly.  Therefore, please limit all lines to a maximum of 79 characters.
    For flowing long blocks of text (docstrings or comments), limiting the
    length to 72 characters is recommended.

    Reports error E501.
pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
def binary(n, d):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
def digits(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
def getSequences(prefix, remaining):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
        return [""] # Don't return the final 0
                   ^
    Separate inline comments by at least two spaces.

    An inline comment is a comment on the same line as a statement.  Inline
    comments should be separated by at least two spaces from the statement.
    They should start with a # and a single space.

    Each line of a block comment starts with a # and a single space
    (unless it is indented text inside the comment).

    Okay: x = x + 1  # Increment x
    Okay: x = x + 1    # Increment x
    Okay: # Block comment
    E261: x = x + 1 # Increment x
    E262: x = x + 1  #Increment x
    E262: x = x + 1  #  Increment x
    E265: #Block comment
pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
def S(n):
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12
pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
def challenge265():
^
    Separate top-level function and class definitions with two blank lines.

    Method definitions inside a class are separated by a single blank line.

    Extra blank lines may be used (sparingly) to separate groups of related
    functions.  Blank lines may be omitted between a bunch of related
    one-liners (e.g. a set of dummy implementations).

    Use blank lines in functions, sparingly, to indicate logical sections.

    Okay: def a():\n    pass\n\n\ndef b():\n    pass
    Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass

    E301: class Foo:\n    b = 0\n    def bar():\n        pass
    E302: def a():\n    pass\n\ndef b(n):\n    pass
    E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass
    E303: def a():\n\n\n\n    pass
    E304: @decorator\n\ndef a():\n    pass
pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace

^
    Trailing whitespace is superfluous.

    The warning returned varies on whether the line itself is blank, for easier
    filtering for those who want to indent their blank lines.

    Okay: spam(1)\n#
    W291: spam(1) \n#
    W293: class Foo(object):\n    \n    bang = 12

D:\Development\pemjh>pylint pemjh 
************* 
F:  1, 0: error while code parsing: Unable to load file 'pemjh\\__init__.py' ([Errno 2] No such file or directory: 'pemjh\\__init__.py') (parse-error)
No config file found, using default configuration

D:\Development\pemjh>py.test pemjh --showlocals --full-trace --durations=0 --doctest-modules  --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100 
============================= test session starts =============================
platform win32 -- Python 2.7.10 -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh\pemjh, inifile: 
plugins: cov, timeout
collected 0 items / 64 errors

=================================== ERRORS ====================================
________________ ERROR collecting challenge002/challenge002.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge002/challenge002.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge002/challenge002.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003978828>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003B28FC8>)
function   = <function <lambda> at 0x0000000003978828>
self       = <DoctestModule 'challenge002/challenge002.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge002/challenge002.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge002/challenge002.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge002\challenge002.py:5: ImportError
________________ ERROR collecting challenge012/challenge012.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge012/challenge012.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge012/challenge012.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C8B0B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003A62D48>)
function   = <function <lambda> at 0x0000000003C8B0B8>
self       = <DoctestModule 'challenge012/challenge012.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge012/challenge012.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge012/challenge012.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge012\challenge012.py:6: ImportError
________________ ERROR collecting challenge015/challenge015.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge015/challenge015.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge015/challenge015.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C8BF98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000040EB0C8>)
function   = <function <lambda> at 0x0000000003C8BF98>
self       = <DoctestModule 'challenge015/challenge015.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge015/challenge015.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge015/challenge015.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge015\challenge015.py:5: ImportError
________________ ERROR collecting challenge018/challenge018.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge018/challenge018.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge018/challenge018.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003B59EB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003D62F48>)
function   = <function <lambda> at 0x0000000003B59EB8>
self       = <DoctestModule 'challenge018/challenge018.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge018/challenge018.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge018/challenge018.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge018\challenge018.py:4: ImportError
________________ ERROR collecting challenge021/challenge021.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge021/challenge021.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge021/challenge021.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000004066438>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004006508>)
function   = <function <lambda> at 0x0000000004066438>
self       = <DoctestModule 'challenge021/challenge021.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge021/challenge021.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge021/challenge021.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge021\challenge021.py:5: ImportError
________________ ERROR collecting challenge024/challenge024.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge024/challenge024.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge024/challenge024.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000004066CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000003F97A48>)
function   = <function <lambda> at 0x0000000004066CF8>
self       = <DoctestModule 'challenge024/challenge024.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge024/challenge024.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge024/challenge024.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge024\challenge024.py:5: ImportError
________________ ERROR collecting challenge025/challenge025.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge025/challenge025.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge025/challenge025.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003F900B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003BC14C8>)
function   = <function <lambda> at 0x0000000003F900B8>
self       = <DoctestModule 'challenge025/challenge025.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge025/challenge025.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge025/challenge025.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge025\challenge025.py:4: ImportError
________________ ERROR collecting challenge027/challenge027.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge027/challenge027.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge027/challenge027.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003F90668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003BBAB88>)
function   = <function <lambda> at 0x0000000003F90668>
self       = <DoctestModule 'challenge027/challenge027.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge027/challenge027.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge027/challenge027.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge027\challenge027.py:5: ImportError
________________ ERROR collecting challenge032/challenge032.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge032/challenge032.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge032/challenge032.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003F90BA8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000003C23B88>)
function   = <function <lambda> at 0x0000000003F90BA8>
self       = <DoctestModule 'challenge032/challenge032.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge032/challenge032.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge032/challenge032.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge032\challenge032.py:5: ImportError
________________ ERROR collecting challenge033/challenge033.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge033/challenge033.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge033/challenge033.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003E5C358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003FCFE48>)
function   = <function <lambda> at 0x0000000003E5C358>
self       = <DoctestModule 'challenge033/challenge033.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge033/challenge033.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge033/challenge033.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import lowestCommonTerms
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge033\challenge033.py:5: ImportError
________________ ERROR collecting challenge034/challenge034.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge034/challenge034.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge034/challenge034.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003E5C898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003BC2348>)
function   = <function <lambda> at 0x0000000003E5C898>
self       = <DoctestModule 'challenge034/challenge034.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge034/challenge034.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge034/challenge034.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge034\challenge034.py:5: ImportError
________________ ERROR collecting challenge035/challenge035.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge035/challenge035.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge035/challenge035.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003E5CCF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004056588>)
function   = <function <lambda> at 0x0000000003E5CCF8>
self       = <DoctestModule 'challenge035/challenge035.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge035/challenge035.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge035/challenge035.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge035\challenge035.py:5: ImportError
________________ ERROR collecting challenge037/challenge037.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge037/challenge037.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge037/challenge037.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C94F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003BDC188>)
function   = <function <lambda> at 0x0000000003C94F98>
self       = <DoctestModule 'challenge037/challenge037.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge037/challenge037.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge037/challenge037.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge037\challenge037.py:5: ImportError
________________ ERROR collecting challenge041/challenge041.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge041/challenge041.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge041/challenge041.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C94208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000040A2188>)
function   = <function <lambda> at 0x0000000003C94208>
self       = <DoctestModule 'challenge041/challenge041.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge041/challenge041.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge041/challenge041.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge041\challenge041.py:5: ImportError
________________ ERROR collecting challenge043/challenge043.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge043/challenge043.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge043/challenge043.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C94A58>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000004063748>)
function   = <function <lambda> at 0x0000000003C94A58>
self       = <DoctestModule 'challenge043/challenge043.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge043/challenge043.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge043/challenge043.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge043\challenge043.py:4: ImportError
________________ ERROR collecting challenge046/challenge046.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge046/challenge046.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge046/challenge046.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C91F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000040FB488>)
function   = <function <lambda> at 0x0000000003C91F98>
self       = <DoctestModule 'challenge046/challenge046.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge046/challenge046.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge046/challenge046.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import sqrt
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge046\challenge046.py:6: ImportError
________________ ERROR collecting challenge047/challenge047.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge047/challenge047.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge047/challenge047.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C91668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003D74EC8>)
function   = <function <lambda> at 0x0000000003C91668>
self       = <DoctestModule 'challenge047/challenge047.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge047/challenge047.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge047/challenge047.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
count      = None

pemjh\challenge047\challenge047.py:6: ImportError
________________ ERROR collecting challenge049/challenge049.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge049/challenge049.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge049/challenge049.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C91CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004116448>)
function   = <function <lambda> at 0x0000000003C91CF8>
self       = <DoctestModule 'challenge049/challenge049.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge049/challenge049.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge049/challenge049.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import string
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
string     = None

pemjh\challenge049\challenge049.py:6: ImportError
________________ ERROR collecting challenge050/challenge050.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge050/challenge050.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge050/challenge050.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C91E48>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003E178C8>)
function   = <function <lambda> at 0x0000000003C91E48>
self       = <DoctestModule 'challenge050/challenge050.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge050/challenge050.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge050/challenge050.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge050\challenge050.py:4: ImportError
________________ ERROR collecting challenge051/challenge051.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge051/challenge051.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge051/challenge051.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C4EEB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000405ABC8>)
function   = <function <lambda> at 0x0000000003C4EEB8>
self       = <DoctestModule 'challenge051/challenge051.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge051/challenge051.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge051/challenge051.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import cycle
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
cycle      = None

pemjh\challenge051\challenge051.py:6: ImportError
________________ ERROR collecting challenge053/challenge053.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge053/challenge053.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge053/challenge053.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C4E278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004022E08>)
function   = <function <lambda> at 0x0000000003C4E278>
self       = <DoctestModule 'challenge053/challenge053.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge053/challenge053.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge053/challenge053.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge053\challenge053.py:4: ImportError
________________ ERROR collecting challenge058/challenge058.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge058/challenge058.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge058/challenge058.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C4EA58>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003D7F388>)
function   = <function <lambda> at 0x0000000003C4EA58>
self       = <DoctestModule 'challenge058/challenge058.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge058/challenge058.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge058/challenge058.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge058\challenge058.py:4: ImportError
________________ ERROR collecting challenge060/challenge060.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge060/challenge060.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge060/challenge060.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003D65358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003CC8AC8>)
function   = <function <lambda> at 0x0000000003D65358>
self       = <DoctestModule 'challenge060/challenge060.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge060/challenge060.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge060/challenge060.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge060\challenge060.py:5: ImportError
________________ ERROR collecting challenge064/challenge064.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge064/challenge064.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge064/challenge064.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003D65908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004083CC8>)
function   = <function <lambda> at 0x0000000003D65908>
self       = <DoctestModule 'challenge064/challenge064.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge064/challenge064.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge064/challenge064.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import continueGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge064\challenge064.py:1: ImportError
________________ ERROR collecting challenge065/challenge065.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge065/challenge065.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge065/challenge065.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003BB6208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003E87CC8>)
function   = <function <lambda> at 0x0000000003BB6208>
self       = <DoctestModule 'challenge065/challenge065.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge065/challenge065.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge065/challenge065.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge065\challenge065.py:4: ImportError
________________ ERROR collecting challenge066/challenge066.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge066/challenge066.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge066/challenge066.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003BB6358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EA27C8>)
function   = <function <lambda> at 0x0000000003BB6358>
self       = <DoctestModule 'challenge066/challenge066.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge066/challenge066.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge066/challenge066.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import rootConvergentGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge066\challenge066.py:1: ImportError
________________ ERROR collecting challenge067/challenge067.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge067/challenge067.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge067/challenge067.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003BB69E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003FFA588>)
function   = <function <lambda> at 0x0000000003BB69E8>
self       = <DoctestModule 'challenge067/challenge067.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge067/challenge067.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge067/challenge067.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import with_statement
    from os.path import dirname, abspath
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
abspath    = None
dirname    = None
with_statement = None

pemjh\challenge067\challenge067.py:9: ImportError
________________ ERROR collecting challenge069/challenge069.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge069/challenge069.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge069/challenge069.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003BB6F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003090208>)
function   = <function <lambda> at 0x0000000003BB6F98>
self       = <DoctestModule 'challenge069/challenge069.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge069/challenge069.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge069/challenge069.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge069\challenge069.py:4: ImportError
________________ ERROR collecting challenge070/challenge070.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge070/challenge070.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge070/challenge070.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003BD5198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003D69048>)
function   = <function <lambda> at 0x0000000003BD5198>
self       = <DoctestModule 'challenge070/challenge070.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge070/challenge070.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge070/challenge070.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge070\challenge070.py:4: ImportError
________________ ERROR collecting challenge072/challenge072.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge072/challenge072.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge072/challenge072.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003BD5748>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003F977C8>)
function   = <function <lambda> at 0x0000000003BD5748>
self       = <DoctestModule 'challenge072/challenge072.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge072/challenge072.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge072/challenge072.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge072\challenge072.py:5: ImportError
________________ ERROR collecting challenge073/challenge073.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge073/challenge073.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge073/challenge073.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003BD5CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EA78C8>)
function   = <function <lambda> at 0x0000000003BD5CF8>
self       = <DoctestModule 'challenge073/challenge073.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge073/challenge073.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge073/challenge073.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import ceil, floor
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
ceil       = None
floor      = None

pemjh\challenge073\challenge073.py:6: ImportError
________________ ERROR collecting challenge075/challenge075.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge075/challenge075.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge075/challenge075.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000004062CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003E80E08>)
function   = <function <lambda> at 0x0000000004062CF8>
self       = <DoctestModule 'challenge075/challenge075.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge075/challenge075.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge075/challenge075.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge075\challenge075.py:1: ImportError
________________ ERROR collecting challenge077/challenge077.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge077/challenge077.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge077/challenge077.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000004062358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003DD6548>)
function   = <function <lambda> at 0x0000000004062358>
self       = <DoctestModule 'challenge077/challenge077.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge077/challenge077.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge077/challenge077.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge077\challenge077.py:1: ImportError
________________ ERROR collecting challenge087/challenge087.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge087/challenge087.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge087/challenge087.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000004062978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004045AC8>)
function   = <function <lambda> at 0x0000000004062978>
self       = <DoctestModule 'challenge087/challenge087.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge087/challenge087.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge087/challenge087.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge087\challenge087.py:4: ImportError
________________ ERROR collecting challenge092/challenge092.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge092/challenge092.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge092/challenge092.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003C41DD8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000407F188>)
function   = <function <lambda> at 0x0000000003C41DD8>
self       = <DoctestModule 'challenge092/challenge092.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge092/challenge092.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge092/challenge092.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge092\challenge092.py:4: ImportError
________________ ERROR collecting challenge104/challenge104.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge104/challenge104.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge104/challenge104.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003F95C18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003EC2E08>)
function   = <function <lambda> at 0x0000000003F95C18>
self       = <DoctestModule 'challenge104/challenge104.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge104/challenge104.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge104/challenge104.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge104\challenge104.py:1: ImportError
________________ ERROR collecting challenge108/challenge108.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge108/challenge108.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge108/challenge108.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003E499E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000420E608>)
function   = <function <lambda> at 0x0000000003E499E8>
self       = <DoctestModule 'challenge108/challenge108.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge108/challenge108.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge108/challenge108.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge108\challenge108.py:1: ImportError
________________ ERROR collecting challenge110/challenge110.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge110/challenge110.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge110/challenge110.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000040FC6D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004202788>)
function   = <function <lambda> at 0x00000000040FC6D8>
self       = <DoctestModule 'challenge110/challenge110.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge110/challenge110.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge110/challenge110.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge110\challenge110.py:1: ImportError
________________ ERROR collecting challenge111/challenge111.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge111/challenge111.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge111/challenge111.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000040FCDD8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003DD5588>)
function   = <function <lambda> at 0x00000000040FCDD8>
self       = <DoctestModule 'challenge111/challenge111.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge111/challenge111.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge111/challenge111.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, roughPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge111\challenge111.py:1: ImportError
________________ ERROR collecting challenge113/challenge113.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge113/challenge113.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge113/challenge113.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000040B4CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000041D4508>)
function   = <function <lambda> at 0x00000000040B4CF8>
self       = <DoctestModule 'challenge113/challenge113.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge113/challenge113.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge113/challenge113.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import polytopicNumbers
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge113\challenge113.py:4: ImportError
________________ ERROR collecting challenge118/challenge118.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge118/challenge118.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge118/challenge118.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000040B4278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003F8CE08>)
function   = <function <lambda> at 0x00000000040B4278>
self       = <DoctestModule 'challenge118/challenge118.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge118/challenge118.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge118/challenge118.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge118\challenge118.py:1: ImportError
________________ ERROR collecting challenge121/challenge121.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge121/challenge121.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge121/challenge121.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030AA0B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003CB0BC8>)
function   = <function <lambda> at 0x00000000030AA0B8>
self       = <DoctestModule 'challenge121/challenge121.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge121/challenge121.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge121/challenge121.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge121\challenge121.py:1: ImportError
________________ ERROR collecting challenge123/challenge123.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge123/challenge123.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge123/challenge123.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030AA898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000030CBEC8>)
function   = <function <lambda> at 0x00000000030AA898>
self       = <DoctestModule 'challenge123/challenge123.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge123/challenge123.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge123/challenge123.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge123\challenge123.py:1: ImportError
________________ ERROR collecting challenge124/challenge124.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge124/challenge124.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge124/challenge124.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030AADD8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003D6B788>)
function   = <function <lambda> at 0x00000000030AADD8>
self       = <DoctestModule 'challenge124/challenge124.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge124/challenge124.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge124/challenge124.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge124\challenge124.py:1: ImportError
________________ ERROR collecting challenge127/challenge127.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge127/challenge127.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge127/challenge127.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030B2F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003E7BC08>)
function   = <function <lambda> at 0x00000000030B2F98>
self       = <DoctestModule 'challenge127/challenge127.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge127/challenge127.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge127/challenge127.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import gcd, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge127\challenge127.py:1: ImportError
________________ ERROR collecting challenge128/challenge128.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge128/challenge128.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge128/challenge128.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030B2358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003DB6DC8>)
function   = <function <lambda> at 0x00000000030B2358>
self       = <DoctestModule 'challenge128/challenge128.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge128/challenge128.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge128/challenge128.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge128\challenge128.py:1: ImportError
________________ ERROR collecting challenge130/challenge130.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge130/challenge130.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge130/challenge130.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030B2978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003093908>)
function   = <function <lambda> at 0x00000000030B2978>
self       = <DoctestModule 'challenge130/challenge130.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge130/challenge130.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge130/challenge130.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge130\challenge130.py:1: ImportError
________________ ERROR collecting challenge131/challenge131.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge131/challenge131.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge131/challenge131.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030B4F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004056B48>)
function   = <function <lambda> at 0x00000000030B4F28>
self       = <DoctestModule 'challenge131/challenge131.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge131/challenge131.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge131/challenge131.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge131\challenge131.py:1: ImportError
________________ ERROR collecting challenge132/challenge132.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge132/challenge132.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge132/challenge132.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030B4EB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003D819C8>)
function   = <function <lambda> at 0x00000000030B4EB8>
self       = <DoctestModule 'challenge132/challenge132.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge132/challenge132.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge132/challenge132.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge132\challenge132.py:1: ImportError
________________ ERROR collecting challenge133/challenge133.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge133/challenge133.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge133/challenge133.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030B42E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F19848>)
function   = <function <lambda> at 0x00000000030B42E8>
self       = <DoctestModule 'challenge133/challenge133.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge133/challenge133.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge133/challenge133.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge133\challenge133.py:1: ImportError
________________ ERROR collecting challenge134/challenge134.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge134/challenge134.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge134/challenge134.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030B4898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000041F3508>)
function   = <function <lambda> at 0x00000000030B4898>
self       = <DoctestModule 'challenge134/challenge134.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge134/challenge134.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge134/challenge134.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge134\challenge134.py:1: ImportError
________________ ERROR collecting challenge136/challenge136.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge136/challenge136.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge136/challenge136.py'>, attrname = '_collected'
function = <function <lambda> at 0x00000000030B4CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000042113C8>)
function   = <function <lambda> at 0x00000000030B4CF8>
self       = <DoctestModule 'challenge136/challenge136.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge136/challenge136.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge136/challenge136.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge136\challenge136.py:1: ImportError
________________ ERROR collecting challenge138/challenge138.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge138/challenge138.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge138/challenge138.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002ED2908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003C32988>)
function   = <function <lambda> at 0x0000000002ED2908>
self       = <DoctestModule 'challenge138/challenge138.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge138/challenge138.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge138/challenge138.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge138\challenge138.py:1: ImportError
________________ ERROR collecting challenge139/challenge139.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge139/challenge139.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge139/challenge139.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002ED27B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003DA6848>)
function   = <function <lambda> at 0x0000000002ED27B8>
self       = <DoctestModule 'challenge139/challenge139.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge139/challenge139.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge139/challenge139.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge139\challenge139.py:1: ImportError
________________ ERROR collecting challenge174/challenge174.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge174/challenge174.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge174/challenge174.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002ED2C18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000042B2BC8>)
function   = <function <lambda> at 0x0000000002ED2C18>
self       = <DoctestModule 'challenge174/challenge174.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge174/challenge174.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge174/challenge174.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge174\challenge174.py:1: ImportError
________________ ERROR collecting challenge183/challenge183.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge183/challenge183.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge183/challenge183.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002EAB278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004015748>)
function   = <function <lambda> at 0x0000000002EAB278>
self       = <DoctestModule 'challenge183/challenge183.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge183/challenge183.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge183/challenge183.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge183\challenge183.py:1: ImportError
________________ ERROR collecting challenge187/challenge187.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge187/challenge187.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge187/challenge187.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002EAB748>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003BB8C88>)
function   = <function <lambda> at 0x0000000002EAB748>
self       = <DoctestModule 'challenge187/challenge187.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge187/challenge187.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge187/challenge187.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge187\challenge187.py:1: ImportError
________________ ERROR collecting challenge203/challenge203.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge203/challenge203.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge203/challenge203.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002EABBA8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003DC7688>)
function   = <function <lambda> at 0x0000000002EABBA8>
self       = <DoctestModule 'challenge203/challenge203.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge203/challenge203.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge203/challenge203.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge203\challenge203.py:1: ImportError
________________ ERROR collecting challenge204/challenge204.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge204/challenge204.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge204/challenge204.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003CB1438>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000042E7608>)
function   = <function <lambda> at 0x0000000003CB1438>
self       = <DoctestModule 'challenge204/challenge204.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge204/challenge204.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge204/challenge204.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge204\challenge204.py:1: ImportError
________________ ERROR collecting challenge211/challenge211.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge211/challenge211.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge211/challenge211.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003CB1828>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003DBE788>)
function   = <function <lambda> at 0x0000000003CB1828>
self       = <DoctestModule 'challenge211/challenge211.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge211/challenge211.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge211/challenge211.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge211\challenge211.py:1: ImportError
________________ ERROR collecting challenge214/challenge214.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge214/challenge214.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge214/challenge214.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002F4F0B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F23F88>)
function   = <function <lambda> at 0x0000000002F4F0B8>
self       = <DoctestModule 'challenge214/challenge214.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge214/challenge214.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge214/challenge214.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes, primeFactors, phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge214\challenge214.py:1: ImportError
________________ ERROR collecting challenge231/challenge231.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge231/challenge231.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge231/challenge231.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002F4F278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004379C08>)
function   = <function <lambda> at 0x0000000002F4F278>
self       = <DoctestModule 'challenge231/challenge231.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge231/challenge231.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge231/challenge231.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge231\challenge231.py:1: ImportError
________________ ERROR collecting challenge234/challenge234.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge234/challenge234.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge234/challenge234.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002F78F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F30408>)
function   = <function <lambda> at 0x0000000002F78F28>
self       = <DoctestModule 'challenge234/challenge234.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge234/challenge234.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge234/challenge234.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge234\challenge234.py:1: ImportError
________________ ERROR collecting challenge243/challenge243.py ________________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge243/challenge243.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge243/challenge243.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000002F78278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002ED5A88>)
function   = <function <lambda> at 0x0000000002F78278>
self       = <DoctestModule 'challenge243/challenge243.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'challenge243/challenge243.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27\v2.7.10_64\lib\doctest.pyc'>
self       = <DoctestModule 'challenge243/challenge243.py'>

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge243\challenge243.py:1: ImportError
--------------- coverage: platform win32, python 2.7.10-final-0 ---------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge001\challenge001       7      3      4      3    45%   4, 9-10
pemjh\challenge002\challenge002      12     10      8      7    15%   2-3, 6-16
pemjh\challenge003\challenge003      17     13     10      5    33%   5-23, 28-29
pemjh\challenge004\challenge004      19     16     10      9    14%   5-31, 36-37
pemjh\challenge005\challenge005      24     21     18     17    10%   2-34, 39-40
pemjh\challenge006\challenge006      13     10      4      3    24%   2-18, 23-24
pemjh\challenge007\challenge007      18     13      9      8    22%   5-19, 24-25
pemjh\challenge008\challenge008      16     13     10      9    15%   2-39, 44-45
pemjh\challenge009\challenge009      14     11      8      7    18%   4-16, 21-22
pemjh\challenge010\challenge010      14      9     10      9    25%   6-13, 18-19
pemjh\challenge011\challenge011      39     36     26     25     6%   2-56, 61-62
pemjh\challenge012\challenge012      31     28     14      9    18%   2-3, 7-44
pemjh\challenge013\challenge013      11      8      4      3    27%   2-109, 114-115
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      8      5    17%   2-3, 7-32
pemjh\challenge016\challenge016      12      9      4      3    25%   2-12, 17-18
pemjh\challenge017\challenge017      33     29     16     15    10%   2-39, 42-104, 109-110
pemjh\challenge018\challenge018      26     24      4      3    10%   2-3, 6-31
pemjh\challenge019\challenge019      32     25     18     17    16%   2, 6-9, 12-15, 19-28, 33-40, 45-46
pemjh\challenge020\challenge020      16     12      6      5    23%   2-5, 9-16, 21-22
pemjh\challenge021\challenge021      21     19     14     13     9%   2-3, 7-33
pemjh\challenge022\challenge022      28     21     10      9    21%   5-14, 17-24, 28-32, 37-38
pemjh\challenge023\challenge023      24     18     16     14    20%   2-3, 7-21, 24, 27-29, 34
pemjh\challenge024\challenge024      14     12      6      5    15%   2-3, 7-18
pemjh\challenge025\challenge025      15     13     10      9    12%   2-3, 5-19
pemjh\challenge026\challenge026      21     17     10      9    16%   4-23, 28-29
pemjh\challenge027\challenge027      27     25     14     11    12%   2-3, 6-36
pemjh\challenge028\challenge028      14     11      4      3    22%   2-13, 18-19
pemjh\challenge029\challenge029      14     11      6      5    20%   2-12, 17-18
pemjh\challenge030\challenge030      19     16     10      9    14%   3-16, 21-22
pemjh\challenge031\challenge031      16     12      6      5    23%   2-14, 19, 22-23
pemjh\challenge032\challenge032      20     18     10      9    10%   2-3, 7-27
pemjh\challenge033\challenge033      33     31     18     17     6%   2-3, 7-48
pemjh\challenge034\challenge034      30     28     14     11    11%   2-3, 7-46
pemjh\challenge035\challenge035      38     36     24     23     5%   2-3, 6-59
pemjh\challenge036\challenge036      22     18     10      9    16%   2-7, 11-24, 29-30
pemjh\challenge037\challenge037      27     25     18     15    11%   2-3, 7-36
pemjh\challenge038\challenge038      20     15     10      9    20%   4, 7-21, 26-27
pemjh\challenge039\challenge039      27     23     14     13    12%   2-23, 26-34, 39-40
pemjh\challenge040\challenge040      15     12      6      5    19%   2-13, 18-19
pemjh\challenge041\challenge041      17     15      8      7    12%   2-3, 6-23
pemjh\challenge042\challenge042      30     24     14     13    16%   5-9, 12-36, 41-42
pemjh\challenge043\challenge043      14     12      6      5    15%   2-3, 6-27
pemjh\challenge044\challenge044      27     21     14     13    17%   4, 7-11, 14-29, 34-35
pemjh\challenge045\challenge045      25     19     12      7    30%   2, 5, 9-21, 24-29, 34-35
pemjh\challenge046\challenge046      23     20     12      9    17%   4-5, 8-32
pemjh\challenge047\challenge047      37     34     22     19    10%   4-5, 8-50
pemjh\challenge048\challenge048       7      4      2      1    44%   2-3, 8-10
pemjh\challenge049\challenge049      24     21     16     15    10%   4-5, 8-32
pemjh\challenge050\challenge050      24     22     12     11     8%   2-3, 6-30
pemjh\challenge051\challenge051      38     35     24     21    10%   4-5, 8-50
pemjh\challenge052\challenge052      20     16      8      7    18%   2, 5-22, 27-28
pemjh\challenge053\challenge053      16     14     10      9    12%   2-3, 6-20
pemjh\challenge054\challenge054      71     61     44     43    10%   5-12, 16-19, 22-24, 39-93, 98-111, 115-131, 136
pemjh\challenge055\challenge055      23     19     12      9    20%   2-12, 15-21, 26-27
pemjh\challenge056\challenge056      14     11      8      7    18%   2-11, 16-17
pemjh\challenge057\challenge057      15     12      8      7    17%   2-15, 20-21
pemjh\challenge058\challenge058      26     24     12      9    13%   2-3, 6-38
pemjh\challenge059\challenge059      29     22     19     18    17%   6-21, 27-45, 48-49
pemjh\challenge060\challenge060      75     73     37     36     3%   2-3, 7-119
pemjh\challenge061\challenge061      65     59     42     41     7%   4, 7-22, 28-99, 104
pemjh\challenge062\challenge062      23     19      8      5    23%   4-29, 34
pemjh\challenge063\challenge063      18     14      6      3    29%   4-22, 27-28
pemjh\challenge064\challenge064      24     23      8      8     3%   3-39
pemjh\challenge065\challenge065      20     18      8      7    11%   2-3, 6-37
pemjh\challenge066\challenge066      15     14      8      8     4%   5-23
pemjh\challenge067\challenge067      17     13      6      5    22%   5-6, 11-25
pemjh\challenge068\challenge068      48     43     32     31     8%   2-5, 8-21, 24-65, 70
pemjh\challenge069\challenge069      20     18     10      9    10%   2-3, 6-24
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
pemjh\challenge071\challenge071      25     21     12     11    14%   4-27, 32
pemjh\challenge072\challenge072      10      8      4      3    21%   2-3, 7-14
pemjh\challenge073\challenge073      31     28     16     15     9%   4-5, 8-42
pemjh\challenge074\challenge074      33     28     10      9    14%   2-3, 6-23, 26-36, 41
pemjh\challenge075\challenge075      16     15      8      8     4%   3-27
pemjh\challenge076\challenge076      20     16     10      9    17%   2-17, 30-32, 37
pemjh\challenge077\challenge077      20     19     12     10     9%   3-34
pemjh\challenge078\challenge078      20     17     12     11    13%   2-19, 24
pemjh\challenge079\challenge079       8      3      2      1    60%   9, 14-15
pemjh\challenge080\challenge080      26     21     12     11    16%   5-26, 29-34, 39
pemjh\challenge081\challenge081      32     26     13     12    16%   5-17, 20-41, 46
pemjh\challenge082\challenge082      34     27     12     11    17%   7-37, 41-48, 53
pemjh\challenge083\challenge083      45     38     20     19    12%   6-14, 17-25, 29-75, 80
pemjh\challenge084\challenge084      74     67     48     47     7%   4-6, 10-50, 54-66, 69-109, 114
pemjh\challenge085\challenge085      34     30     16     11    18%   3-10, 13-46, 51
pemjh\challenge086\challenge086      32     26     14     11    20%   2, 6-17, 20-25, 28-39, 44
pemjh\challenge087\challenge087      30     28     14     13     7%   2-3, 5-40
pemjh\challenge088\challenge088      24     19     12     11    17%   5-19, 22-31, 36
pemjh\challenge089\challenge089      51     42     26     25    13%   18-31, 35-51, 54-65, 69-79, 83-85, 90
pemjh\challenge090\challenge090      78     68     50     49     9%   5-18, 21-27, 30-33, 36-69, 74-114, 117-127, 132
pemjh\challenge091\challenge091      23     19     20     19    12%   2-30, 33-35, 40
pemjh\challenge092\challenge092      96     94     50     45     5%   2-3, 6-124
pemjh\challenge093\challenge093      67     59     50     49     8%   4-10, 14-24, 27-32, 35-58, 61-97, 102
pemjh\challenge094\challenge094      35     30     12     11    13%   2-7, 11-48, 54
pemjh\challenge095\challenge095      35     30     22     21    11%   3-10, 14-48, 51-56, 61
pemjh\challenge096\challenge096     181    155    116    115     9%   7-14, 22-34, 40-44, 47-59, 62-69, 73-94, 97-105, 108-115, 118-146, 150-155, 158-174, 178-181, 184-221, 224-228, 231-235, 238-241, 244-254, 257-277, 294
pemjh\challenge097\challenge097       6      3      2      1    50%   2, 7-8
pemjh\challenge098\challenge098      62     54     34     33     9%   5-13, 16-23, 26-30, 33-93, 98
pemjh\challenge099\challenge099      17     12      7      6    25%   5-14, 19-20
pemjh\challenge100\challenge100       9      6      4      3    31%   2-6, 11
pemjh\challenge101\challenge101      26     23     18     17     9%   2-38, 43
pemjh\challenge102\challenge102      34     27     14     13    17%   9-31, 35-41, 45-53, 59
pemjh\challenge103\challenge103      40     35     30     29     9%   3-12, 16-34, 37-56, 61
pemjh\challenge104\challenge104      34     33     15     15     2%   3-50
pemjh\challenge105\challenge105      40     32     22     21    15%   5-19, 22-28, 32-47, 51-58, 65
pemjh\challenge106\challenge106      37     30     16     15    15%   2-14, 17-26, 29-46, 49-60, 63, 68
pemjh\challenge107\challenge107      38     31     12     11    16%   6-34, 37-45, 48-65, 70
pemjh\challenge108\challenge108      35     34     16     16     2%   3-59
pemjh\challenge109\challenge109      37     32     18     17    11%   2-19, 23-29, 32-45, 50
pemjh\challenge110\challenge110      35     34     16     16     2%   3-59
pemjh\challenge111\challenge111      38     37     31     31     1%   3-54
pemjh\challenge112\challenge112      32     28     20     17    13%   2-27, 30-43, 48
pemjh\challenge113\challenge113      16     14      6      5    14%   2-3, 6-61
pemjh\challenge114\challenge114      24     19     12     11    17%   2-24, 27-28, 31-32, 37
pemjh\challenge115\challenge115      30     25     14     13    14%   2-25, 28-29, 32-38, 43
pemjh\challenge116\challenge116      24     19     10      9    18%   2-22, 25-28, 31-32, 37
pemjh\challenge117\challenge117      21     16     10      9    19%   2-20, 23-24, 27-28, 33
pemjh\challenge118\challenge118      36     35     14     14     2%   2-52
pemjh\challenge119\challenge119      24     19     10      9    18%   2-7, 12-23, 26-28, 33
pemjh\challenge120\challenge120      10      6      4      3    36%   2-6, 9-10, 15
pemjh\challenge121\challenge121      26     25     10     10     3%   3-39
pemjh\challenge122\challenge122      15     12     12     11    15%   2-23, 28
pemjh\challenge123\challenge123      16     15      6      6     5%   3-20
pemjh\challenge124\challenge124      21     20     14     14     3%   3-41
pemjh\challenge125\challenge125      21     18     12     11    12%   2-24, 29
pemjh\challenge126\challenge126      31     27     24     23     9%   2, 6-36, 41
pemjh\challenge127\challenge127      23     22     15     15     3%   3-35
pemjh\challenge128\challenge128      23     22     10     10     3%   3-33
pemjh\challenge129\challenge129      22     18     10      9    16%   2-8, 11-20, 25-27
pemjh\challenge130\challenge130      21     20      8      8     3%   3-30
pemjh\challenge131\challenge131      22     21     10     10     3%   3-41
pemjh\challenge132\challenge132      16     15      8      8     4%   3-24
pemjh\challenge133\challenge133      10      9      2      2     8%   3-16
pemjh\challenge134\challenge134      42     41     20     20     2%   3-72
pemjh\challenge135\challenge135      15     11     10      9    20%   2-16, 19, 25
pemjh\challenge136\challenge136      19     18     10     10     3%   3-26
pemjh\challenge137\challenge137      16     11      6      5    27%   2-6, 10-17, 20, 25
pemjh\challenge138\challenge138      23     22     14     14     3%   3-34
pemjh\challenge139\challenge139      11     10      6      6     6%   3-19
pemjh\challenge142\challenge142      26     21     18     17    14%   2, 5, 8-34, 39
pemjh\challenge144\challenge144      34     26      6      5    23%   4-5, 9-27, 31-51, 54, 57-67, 72
pemjh\challenge145\challenge145      11      8      4      3    27%   2-10, 15
pemjh\challenge146\challenge146      18     13     14     13    19%   2-6, 9, 17-26, 31
pemjh\challenge148\challenge148      22     17      6      5    21%   2-8, 11-29, 32-34, 39
pemjh\challenge149\challenge149      32     26     12     11    16%   2, 5, 9-27, 30-46, 51
pemjh\challenge151\challenge151      21     17     14     13    14%   2-20, 23, 28
pemjh\challenge162\challenge162       7      3      4      3    45%   2-4, 11
pemjh\challenge164\challenge164      20     16     10      9    17%   3-23, 27-31, 36
pemjh\challenge166\challenge166      40     37     33     32     5%   3-68, 73
pemjh\challenge173\challenge173      21     17      6      5    19%   2-27, 30, 35
pemjh\challenge174\challenge174      27     26     14     14     2%   3-40
pemjh\challenge179\challenge179      18     14      8      7    19%   3-17, 20-21, 26
pemjh\challenge183\challenge183      39     38     12     12     2%   2-56
pemjh\challenge187\challenge187      16     15      8      8     4%   3-22
pemjh\challenge188\challenge188      15     11      6      5    24%   2-10, 13, 18
pemjh\challenge190\challenge190       7      3      6      5    38%   2, 6, 11
pemjh\challenge191\challenge191      48     43     34     33     7%   2-23, 27-70, 73-78, 83
pemjh\challenge197\challenge197      19     15      8      7    19%   2, 5-22, 27
pemjh\challenge203\challenge203      27     26     16     16     2%   3-44
pemjh\challenge204\challenge204      21     20      8      8     3%   3-32
pemjh\challenge205\challenge205      25     20     10      9    17%   2-4, 8-14, 17-27, 32
pemjh\challenge206\challenge206      45     37     16     13    18%   6-10, 13-22, 26-60, 65
pemjh\challenge207\challenge207      20     17      6      5    15%   3-20, 25
pemjh\challenge211\challenge211      46     45     24     24     1%   2-68
pemjh\challenge214\challenge214      45     44     26     26     1%   3-76
pemjh\challenge215\challenge215      45     39     32     31     9%   2-23, 26-29, 32-44, 48-59, 64
pemjh\challenge216\challenge216      67     61     48     47     6%   4-18, 21-44, 47-76, 81
pemjh\challenge220\challenge220      17     13      6      5    22%   2-14, 17, 22
pemjh\challenge225\challenge225      14     11      8      7    18%   4-14, 19
pemjh\challenge230\challenge230      34     30     12     11    11%   2-37, 40-47, 52-53
pemjh\challenge231\challenge231      41     40     14     14     2%   3-72
pemjh\challenge234\challenge234      25     24     10     10     3%   3-44
pemjh\challenge235\challenge235      15     12      8      7    17%   2-14, 19
pemjh\challenge243\challenge243      33     32     20     20     2%   3-49
pemjh\challenge250\challenge250      16     12      8      7    21%   2-18, 21-22, 27
pemjh\challenge259\challenge259      42     32     18     17    18%   4-8, 11, 14, 17, 20, 23-53, 58-63, 66
pemjh\challenge265\challenge265      35     27     10      9    20%   2-9, 13-15, 18, 21-33, 37-47, 50, 55
pemjh\main                           51     33     20     15    32%   7-8, 13-28, 39-57, 63, 66-68
-----------------------------------------------------------------------------
TOTAL                              4961   4273   2571   2370    12%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\python27\v2.7.10_64\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "E:\software_tools\python\python27\v2.7.10_64\Scripts\py.test.exe\__main__.py", line 9, in <module>
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "E:\software_tools\python\python27\v2.7.10_64\lib\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
pytest_cov.plugin.CoverageError: Required test coverage of 100% not reached. Total coverage: 11.80%
