running test
Searching for tox
Best match: tox 2.1.1
Processing tox-2.1.1-py2.7.egg

Using d:\development\pemjh\.eggs\tox-2.1.1-py2.7.egg
Searching for pluggy<0.4.0,>=0.3.0
Best match: pluggy 0.3.0
Processing pluggy-0.3.0-py2.7.egg

Using d:\development\pemjh\.eggs\pluggy-0.3.0-py2.7.egg
Searching for py>=1.4.17
Best match: py 1.4.30
Processing py-1.4.30-py2.7.egg

Using d:\development\pemjh\.eggs\py-1.4.30-py2.7.egg
running egg_info
writing pemjh.egg-info\PKG-INFO
writing top-level names to pemjh.egg-info\top_level.txt
writing dependency_links to pemjh.egg-info\dependency_links.txt
package init file 'pemjh\__init__.py' not found (or not a regular file)
reading manifest file 'pemjh.egg-info\SOURCES.txt'
writing manifest file 'pemjh.egg-info\SOURCES.txt'
running build_ext
GLOB sdist-make: D:\Development\pemjh\setup.py
py27 inst-nodeps: D:\Development\pemjh\.tox\dist\pemjh-0.0.1.zip
py27 installed: apipkg==1.4,astroid==1.3.8,colorama==0.3.3,coverage==3.7.1,execnet==1.4.1,flake8==2.4.1,logilab-common==1.0.2,mccabe==0.3.1,pemjh==0.0.1,pep8==1.5.7,py==1.4.30,pyflakes==0.8.1,pylint==1.4.4,pytest==2.7.2,pytest-cache==1.0,pytest-cov==2.1.0,pytest-flake8==0.1,pytest-pylint==0.3.0,six==1.9.0,wheel==0.24.0
py27 runtests: PYTHONHASHSEED='850'
py27 runtests: commands[0] | py.test --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100
============================= test session starts =============================
platform win32 -- Python 2.7.10 -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh, inifile: 
plugins: cache, cov, flake8, pylint
collected 358 items / 65 errors

setup.py FF
pemjh\main.py FF
pemjh\challenge001\challenge001.py FF
pemjh\challenge002\challenge002.py FF
pemjh\challenge003\challenge003.py FF
pemjh\challenge004\challenge004.py FF
pemjh\challenge005\challenge005.py FF
pemjh\challenge006\challenge006.py FF
pemjh\challenge007\challenge007.py FF
pemjh\challenge008\challenge008.py FF
pemjh\challenge009\challenge009.py FF
pemjh\challenge010\challenge010.py FF
pemjh\challenge011\challenge011.py FF
pemjh\challenge012\challenge012.py FF
pemjh\challenge013\challenge013.py FF
pemjh\challenge014\challenge014.py FF
pemjh\challenge015\challenge015.py FF
pemjh\challenge016\challenge016.py FF
pemjh\challenge017\challenge017.py FF
pemjh\challenge018\challenge018.py FF
pemjh\challenge019\challenge019.py FF
pemjh\challenge020\challenge020.py FF
pemjh\challenge021\challenge021.py FF
pemjh\challenge022\challenge022.py FF
pemjh\challenge023\challenge023.py FF
pemjh\challenge024\challenge024.py FF
pemjh\challenge025\challenge025.py FF
pemjh\challenge026\challenge026.py FF
pemjh\challenge027\challenge027.py FF
pemjh\challenge028\challenge028.py FF
pemjh\challenge029\challenge029.py FF
pemjh\challenge030\challenge030.py FF
pemjh\challenge031\challenge031.py FF
pemjh\challenge032\challenge032.py FF
pemjh\challenge033\challenge033.py FF
pemjh\challenge034\challenge034.py FF
pemjh\challenge035\challenge035.py FF
pemjh\challenge036\challenge036.py FF
pemjh\challenge037\challenge037.py FF
pemjh\challenge038\challenge038.py FF
pemjh\challenge039\challenge039.py FF
pemjh\challenge040\challenge040.py FF
pemjh\challenge041\challenge041.py FF
pemjh\challenge042\challenge042.py FF
pemjh\challenge043\challenge043.py FF
pemjh\challenge044\challenge044.py FF
pemjh\challenge045\challenge045.py FF
pemjh\challenge046\challenge046.py FF
pemjh\challenge047\challenge047.py FF
pemjh\challenge048\challenge048.py FF
pemjh\challenge049\challenge049.py FF
pemjh\challenge050\challenge050.py FF
pemjh\challenge051\challenge051.py FF
pemjh\challenge052\challenge052.py FF
pemjh\challenge053\challenge053.py FF
pemjh\challenge054\challenge054.py FF
pemjh\challenge055\challenge055.py FF
pemjh\challenge056\challenge056.py FF
pemjh\challenge057\challenge057.py FF
pemjh\challenge058\challenge058.py FF
pemjh\challenge059\challenge059.py FF
pemjh\challenge060\challenge060.py FF
pemjh\challenge061\challenge061.py FF
pemjh\challenge062\challenge062.py FF
pemjh\challenge063\challenge063.py FF
pemjh\challenge064\challenge064.py FF
pemjh\challenge065\challenge065.py FF
pemjh\challenge066\challenge066.py FF
pemjh\challenge067\challenge067.py FF
pemjh\challenge068\challenge068.py FF
pemjh\challenge069\challenge069.py FF
pemjh\challenge070\challenge070.py FF
pemjh\challenge071\challenge071.py FF
pemjh\challenge072\challenge072.py FF
pemjh\challenge073\challenge073.py FF
pemjh\challenge074\challenge074.py FF
pemjh\challenge075\challenge075.py FF
pemjh\challenge076\challenge076.py FF
pemjh\challenge077\challenge077.py FF
pemjh\challenge078\challenge078.py FF
pemjh\challenge079\challenge079.py FF
pemjh\challenge080\challenge080.py FF
pemjh\challenge081\challenge081.py FF
pemjh\challenge082\challenge082.py FF
pemjh\challenge083\challenge083.py FF
pemjh\challenge084\challenge084.py FF
pemjh\challenge085\challenge085.py FF
pemjh\challenge086\challenge086.py FF
pemjh\challenge087\challenge087.py FF
pemjh\challenge088\challenge088.py FF
pemjh\challenge089\challenge089.py FF
pemjh\challenge090\challenge090.py FF
pemjh\challenge091\challenge091.py FF
pemjh\challenge092\challenge092.py FF
pemjh\challenge093\challenge093.py FF
pemjh\challenge094\challenge094.py FF
pemjh\challenge095\challenge095.py FF
pemjh\challenge096\challenge096.py FF
pemjh\challenge097\challenge097.py FF
pemjh\challenge098\challenge098.py FF
pemjh\challenge099\challenge099.py FF
pemjh\challenge100\challenge100.py F.
pemjh\challenge101\challenge101.py FF
pemjh\challenge102\challenge102.py FF
pemjh\challenge103\challenge103.py FF
pemjh\challenge104\challenge104.py FF
pemjh\challenge105\challenge105.py FF
pemjh\challenge106\challenge106.py FF
pemjh\challenge107\challenge107.py FF
pemjh\challenge108\challenge108.py FF
pemjh\challenge109\challenge109.py FF
pemjh\challenge110\challenge110.py FF
pemjh\challenge111\challenge111.py FF
pemjh\challenge112\challenge112.py FF
pemjh\challenge113\challenge113.py FF
pemjh\challenge114\challenge114.py FF
pemjh\challenge115\challenge115.py FF
pemjh\challenge116\challenge116.py FF
pemjh\challenge117\challenge117.py FF
pemjh\challenge118\challenge118.py FF
pemjh\challenge119\challenge119.py FF
pemjh\challenge120\challenge120.py FF
pemjh\challenge121\challenge121.py FF
pemjh\challenge122\challenge122.py FF
pemjh\challenge123\challenge123.py FF
pemjh\challenge124\challenge124.py FF
pemjh\challenge125\challenge125.py F.
pemjh\challenge126\challenge126.py FF
pemjh\challenge127\challenge127.py FF
pemjh\challenge128\challenge128.py FF
pemjh\challenge129\challenge129.py FF
pemjh\challenge130\challenge130.py FF
pemjh\challenge131\challenge131.py FF
pemjh\challenge132\challenge132.py FF
pemjh\challenge133\challenge133.py FF
pemjh\challenge134\challenge134.py FF
pemjh\challenge135\challenge135.py FF
pemjh\challenge136\challenge136.py FF
pemjh\challenge137\challenge137.py FF
pemjh\challenge138\challenge138.py FF
pemjh\challenge139\challenge139.py FF
pemjh\challenge142\challenge142.py FF
pemjh\challenge144\challenge144.py FF
pemjh\challenge145\challenge145.py F.
pemjh\challenge146\challenge146.py FF
pemjh\challenge148\challenge148.py FF
pemjh\challenge149\challenge149.py FF
pemjh\challenge151\challenge151.py FF
pemjh\challenge162\challenge162.py FF
pemjh\challenge164\challenge164.py FF
pemjh\challenge166\challenge166.py FF
pemjh\challenge173\challenge173.py FF
pemjh\challenge174\challenge174.py FF
pemjh\challenge179\challenge179.py FF
pemjh\challenge183\challenge183.py FF
pemjh\challenge187\challenge187.py FF
pemjh\challenge188\challenge188.py FF
pemjh\challenge190\challenge190.py FF
pemjh\challenge191\challenge191.py FF
pemjh\challenge197\challenge197.py FF
pemjh\challenge203\challenge203.py FF
pemjh\challenge204\challenge204.py FF
pemjh\challenge205\challenge205.py FF
pemjh\challenge206\challenge206.py FF
pemjh\challenge207\challenge207.py F.
pemjh\challenge211\challenge211.py FF
pemjh\challenge214\challenge214.py FF
pemjh\challenge215\challenge215.py FF
pemjh\challenge216\challenge216.py FF
pemjh\challenge220\challenge220.py FF
pemjh\challenge225\challenge225.py FF
pemjh\challenge230\challenge230.py FF
pemjh\challenge231\challenge231.py FF
pemjh\challenge234\challenge234.py FF
pemjh\challenge235\challenge235.py FF
pemjh\challenge243\challenge243.py FF
pemjh\challenge250\challenge250.py FF
pemjh\challenge259\challenge259.py FF
pemjh\challenge265\challenge265.py FF

=================================== ERRORS ====================================
__________________________ ERROR collecting setup.py __________________________

self = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
func = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
self       = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003EF6358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = None
function   = <function <lambda> at 0x0000000003EF6358>
self       = <DoctestModule 'setup.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'setup.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\setup.py'), modname = 'setup'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'setup'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh')
self       = local('D:\\Development\\pemjh\\setup.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    https://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands"""
    
    import os
    import sys
    from setuptools import setup
    from setuptools.command.test import test as TestCommand
    
    def read(fname):
        return open(os.path.join(os.path.dirname(__file__), fname)).read()
    
    class Tox(TestCommand):
        user_options = [('tox-args=', 'a', "Arguments to pass to tox")]
        def initialize_options(self):
            TestCommand.initialize_options(self)
            self.tox_args = None
        def finalize_options(self):
            TestCommand.finalize_options(self)
            self.test_args = []
            self.test_suite = True
        def run_tests(self):
            #import here, cause outside the eggs aren't loaded
            import tox
            import shlex
            args = self.tox_args
            if args:
                args = shlex.split(self.tox_args)
            errno = tox.cmdline(args=args)
            sys.exit(errno)
    
    setup(
        name = "pemjh",
        version = "0.0.1",
        author = "Matthew Hussey",
        author_email = "matthew.hussey@googlemail.com",
        description = ("Project euler (https://projecteuler.net/) challenge "
                       "code in Python."),
        license = "None, private use by myself only",
        keywords = "code challenge euler",
        url = "none.non",
        packages = ["pemjh"],
        long_description = read("README"),
        classifiers=[
            "Development Status :: 1 - Planning"],
        tests_require=['tox'],
>       cmdclass = {"test": Tox},
    )

TestCommand = None
Tox        = None
__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
os         = None
read       = None
setup      = None
sys        = None

setup.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

attrs = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x00000000043ADD68>}, ...}
klass = <class setuptools.dist.Distribution at 0x000000000437C7C8>
dist = <setuptools.dist.Distribution instance at 0x00000000043B9408>
msg = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

    def setup(**attrs):
        """The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
    
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
    
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
    
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.
        """
    
        global _setup_stop_after, _setup_distribution
    
        # Determine the distribution class -- either caller-supplied or
        # our Distribution (see below).
        klass = attrs.get('distclass')
        if klass:
            del attrs['distclass']
        else:
            klass = Distribution
    
        if 'script_name' not in attrs:
            attrs['script_name'] = os.path.basename(sys.argv[0])
        if 'script_args' not in attrs:
            attrs['script_args'] = sys.argv[1:]
    
        # Create the Distribution instance, using the remaining arguments
        # (ie. everything except distclass) to initialize it
        try:
            _setup_distribution = dist = klass(attrs)
        except DistutilsSetupError, msg:
            if 'name' in attrs:
                raise SystemExit, "error in %s setup command: %s" % \
                      (attrs['name'], msg)
            else:
                raise SystemExit, "error in setup command: %s" % msg
    
        if _setup_stop_after == "init":
            return dist
    
        # Find and parse the config file(s): they will override options from
        # the setup script, but be overridden by the command line.
        dist.parse_config_files()
    
        if DEBUG:
            print "options (after parsing config files):"
            dist.dump_option_dicts()
    
        if _setup_stop_after == "config":
            return dist
    
        # Parse the command line and override config files; any
        # command-line errors are the end user's fault, so turn them into
        # SystemExit to suppress tracebacks.
        try:
            ok = dist.parse_command_line()
        except DistutilsArgError, msg:
>           raise SystemExit, gen_usage(dist.script_name) + "\nerror: %s" % msg
E           SystemExit: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
E              or: py.test.EXE --help [cmd1 cmd2 ...]
E              or: py.test.EXE --help-commands
E              or: py.test.EXE cmd --help
E           
E           error: option --pylint not recognized

attrs      = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x00000000043ADD68>}, ...}
dist       = <setuptools.dist.Distribution instance at 0x00000000043B9408>
klass      = <class setuptools.dist.Distribution at 0x000000000437C7C8>
msg        = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

E:\software_tools\python\python27_64\Lib\distutils\core.py:139: SystemExit
_____________ ERROR collecting pemjh/challenge002/challenge002.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044B7828>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000043FC888>)
function   = <function <lambda> at 0x00000000044B7828>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge002\challenge002.py:5: ImportError
_____________ ERROR collecting pemjh/challenge012/challenge012.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047669E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045FC288>)
function   = <function <lambda> at 0x00000000047669E8>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge012\challenge012.py:6: ImportError
_____________ ERROR collecting pemjh/challenge015/challenge015.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004792A58>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045DD748>)
function   = <function <lambda> at 0x0000000004792A58>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge015\challenge015.py:5: ImportError
_____________ ERROR collecting pemjh/challenge018/challenge018.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000477AAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000459AAC8>)
function   = <function <lambda> at 0x000000000477AAC8>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge018\challenge018.py:4: ImportError
_____________ ERROR collecting pemjh/challenge021/challenge021.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004787F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000043B9D48>)
function   = <function <lambda> at 0x0000000004787F98>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge021\challenge021.py:5: ImportError
_____________ ERROR collecting pemjh/challenge024/challenge024.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004787518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000004789208>)
function   = <function <lambda> at 0x0000000004787518>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge024\challenge024.py:5: ImportError
_____________ ERROR collecting pemjh/challenge025/challenge025.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004787AC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004416FC8>)
function   = <function <lambda> at 0x0000000004787AC8>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge025\challenge025.py:4: ImportError
_____________ ERROR collecting pemjh/challenge027/challenge027.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004787E48>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004428248>)
function   = <function <lambda> at 0x0000000004787E48>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge027\challenge027.py:5: ImportError
_____________ ERROR collecting pemjh/challenge032/challenge032.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045F0278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x00000000044DBA88>)
function   = <function <lambda> at 0x00000000045F0278>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge032\challenge032.py:5: ImportError
_____________ ERROR collecting pemjh/challenge033/challenge033.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045F06D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004724D08>)
function   = <function <lambda> at 0x00000000045F06D8>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import lowestCommonTerms
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge033\challenge033.py:5: ImportError
_____________ ERROR collecting pemjh/challenge034/challenge034.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045F0898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003007CC8>)
function   = <function <lambda> at 0x00000000045F0898>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge034\challenge034.py:5: ImportError
_____________ ERROR collecting pemjh/challenge035/challenge035.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045F0C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000477C148>)
function   = <function <lambda> at 0x00000000045F0C88>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge035\challenge035.py:5: ImportError
_____________ ERROR collecting pemjh/challenge037/challenge037.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047B3EB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044761C8>)
function   = <function <lambda> at 0x00000000047B3EB8>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge037\challenge037.py:5: ImportError
_____________ ERROR collecting pemjh/challenge041/challenge041.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047B3208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002FEEB08>)
function   = <function <lambda> at 0x00000000047B3208>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge041\challenge041.py:5: ImportError
_____________ ERROR collecting pemjh/challenge043/challenge043.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047B3518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000004536A48>)
function   = <function <lambda> at 0x00000000047B3518>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge043\challenge043.py:4: ImportError
_____________ ERROR collecting pemjh/challenge046/challenge046.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047B39E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047418C8>)
function   = <function <lambda> at 0x00000000047B39E8>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import sqrt
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge046\challenge046.py:6: ImportError
_____________ ERROR collecting pemjh/challenge047/challenge047.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000460B278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003017648>)
function   = <function <lambda> at 0x000000000460B278>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
count      = None

pemjh\challenge047\challenge047.py:6: ImportError
_____________ ERROR collecting pemjh/challenge049/challenge049.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000460B358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044FF6C8>)
function   = <function <lambda> at 0x000000000460B358>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import string
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
string     = None

pemjh\challenge049\challenge049.py:6: ImportError
_____________ ERROR collecting pemjh/challenge050/challenge050.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000460B198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045D6E48>)
function   = <function <lambda> at 0x000000000460B198>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge050\challenge050.py:4: ImportError
_____________ ERROR collecting pemjh/challenge051/challenge051.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000460B438>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002FC2A88>)
function   = <function <lambda> at 0x000000000460B438>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import cycle
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
cycle      = None

pemjh\challenge051\challenge051.py:6: ImportError
_____________ ERROR collecting pemjh/challenge053/challenge053.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000460B828>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004495048>)
function   = <function <lambda> at 0x000000000460B828>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge053\challenge053.py:4: ImportError
_____________ ERROR collecting pemjh/challenge058/challenge058.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000460BD68>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000444E288>)
function   = <function <lambda> at 0x000000000460BD68>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge058\challenge058.py:4: ImportError
_____________ ERROR collecting pemjh/challenge060/challenge060.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000462D6D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000465F288>)
function   = <function <lambda> at 0x000000000462D6D8>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge060\challenge060.py:5: ImportError
_____________ ERROR collecting pemjh/challenge064/challenge064.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000462D898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045D0A08>)
function   = <function <lambda> at 0x000000000462D898>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import continueGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge064\challenge064.py:1: ImportError
_____________ ERROR collecting pemjh/challenge065/challenge065.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046480B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047EC208>)
function   = <function <lambda> at 0x00000000046480B8>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge065\challenge065.py:4: ImportError
_____________ ERROR collecting pemjh/challenge066/challenge066.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046482E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047DA1C8>)
function   = <function <lambda> at 0x00000000046482E8>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import rootConvergentGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge066\challenge066.py:1: ImportError
_____________ ERROR collecting pemjh/challenge067/challenge067.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004648198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004509C48>)
function   = <function <lambda> at 0x0000000004648198>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import with_statement
    from os.path import dirname, abspath
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
abspath    = None
dirname    = None
with_statement = None

pemjh\challenge067\challenge067.py:9: ImportError
_____________ ERROR collecting pemjh/challenge069/challenge069.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046485F8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E78F08>)
function   = <function <lambda> at 0x00000000046485F8>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge069\challenge069.py:4: ImportError
_____________ ERROR collecting pemjh/challenge070/challenge070.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004648F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004422F48>)
function   = <function <lambda> at 0x0000000004648F28>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge070\challenge070.py:4: ImportError
_____________ ERROR collecting pemjh/challenge072/challenge072.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044D3278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045F4088>)
function   = <function <lambda> at 0x00000000044D3278>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge072\challenge072.py:5: ImportError
_____________ ERROR collecting pemjh/challenge073/challenge073.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044D3438>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E6EDC8>)
function   = <function <lambda> at 0x00000000044D3438>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import ceil, floor
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
ceil       = None
floor      = None

pemjh\challenge073\challenge073.py:6: ImportError
_____________ ERROR collecting pemjh/challenge075/challenge075.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044D3518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004799D88>)
function   = <function <lambda> at 0x00000000044D3518>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge075\challenge075.py:1: ImportError
_____________ ERROR collecting pemjh/challenge077/challenge077.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044D3978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F9EF08>)
function   = <function <lambda> at 0x00000000044D3978>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge077\challenge077.py:1: ImportError
_____________ ERROR collecting pemjh/challenge087/challenge087.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002FD9048>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003028708>)
function   = <function <lambda> at 0x0000000002FD9048>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge087\challenge087.py:4: ImportError
_____________ ERROR collecting pemjh/challenge092/challenge092.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002FD9DD8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000445AEC8>)
function   = <function <lambda> at 0x0000000002FD9DD8>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge092\challenge092.py:4: ImportError
_____________ ERROR collecting pemjh/challenge104/challenge104.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002FEFAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045D0B48>)
function   = <function <lambda> at 0x0000000002FEFAC8>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge104\challenge104.py:1: ImportError
_____________ ERROR collecting pemjh/challenge108/challenge108.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004415AC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046771C8>)
function   = <function <lambda> at 0x0000000004415AC8>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge108\challenge108.py:1: ImportError
_____________ ERROR collecting pemjh/challenge110/challenge110.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002F9F588>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046BC1C8>)
function   = <function <lambda> at 0x0000000002F9F588>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge110\challenge110.py:1: ImportError
_____________ ERROR collecting pemjh/challenge111/challenge111.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002F9F908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004443308>)
function   = <function <lambda> at 0x0000000002F9F908>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, roughPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge111\challenge111.py:1: ImportError
_____________ ERROR collecting pemjh/challenge113/challenge113.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002F9FC18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000468C888>)
function   = <function <lambda> at 0x0000000002F9FC18>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import polytopicNumbers
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge113\challenge113.py:4: ImportError
_____________ ERROR collecting pemjh/challenge118/challenge118.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000467C198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047F0308>)
function   = <function <lambda> at 0x000000000467C198>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge118\challenge118.py:1: ImportError
_____________ ERROR collecting pemjh/challenge121/challenge121.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000467CB38>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000482B1C8>)
function   = <function <lambda> at 0x000000000467CB38>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge121\challenge121.py:1: ImportError
_____________ ERROR collecting pemjh/challenge123/challenge123.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046C9F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000464AA48>)
function   = <function <lambda> at 0x00000000046C9F98>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge123\challenge123.py:1: ImportError
_____________ ERROR collecting pemjh/challenge124/challenge124.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046C9048>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A26608>)
function   = <function <lambda> at 0x00000000046C9048>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge124\challenge124.py:1: ImportError
_____________ ERROR collecting pemjh/challenge127/challenge127.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046C90B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004836C88>)
function   = <function <lambda> at 0x00000000046C90B8>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import gcd, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge127\challenge127.py:1: ImportError
_____________ ERROR collecting pemjh/challenge128/challenge128.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046C9668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000049FBBC8>)
function   = <function <lambda> at 0x00000000046C9668>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge128\challenge128.py:1: ImportError
_____________ ERROR collecting pemjh/challenge130/challenge130.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046C9908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000450B3C8>)
function   = <function <lambda> at 0x00000000046C9908>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge130\challenge130.py:1: ImportError
_____________ ERROR collecting pemjh/challenge131/challenge131.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004922F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004647848>)
function   = <function <lambda> at 0x0000000004922F98>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge131\challenge131.py:1: ImportError
_____________ ERROR collecting pemjh/challenge132/challenge132.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004922128>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000498C048>)
function   = <function <lambda> at 0x0000000004922128>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge132\challenge132.py:1: ImportError
_____________ ERROR collecting pemjh/challenge133/challenge133.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004922828>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000445AB08>)
function   = <function <lambda> at 0x0000000004922828>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge133\challenge133.py:1: ImportError
_____________ ERROR collecting pemjh/challenge134/challenge134.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004922898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000301CA08>)
function   = <function <lambda> at 0x0000000004922898>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge134\challenge134.py:1: ImportError
_____________ ERROR collecting pemjh/challenge136/challenge136.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004922518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044CFBC8>)
function   = <function <lambda> at 0x0000000004922518>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge136\challenge136.py:1: ImportError
_____________ ERROR collecting pemjh/challenge138/challenge138.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004922908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004932E88>)
function   = <function <lambda> at 0x0000000004922908>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge138\challenge138.py:1: ImportError
_____________ ERROR collecting pemjh/challenge139/challenge139.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002E60208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004724D48>)
function   = <function <lambda> at 0x0000000002E60208>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge139\challenge139.py:1: ImportError
_____________ ERROR collecting pemjh/challenge174/challenge174.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002E60128>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004811E88>)
function   = <function <lambda> at 0x0000000002E60128>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge174\challenge174.py:1: ImportError
_____________ ERROR collecting pemjh/challenge183/challenge183.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002E72A58>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E69408>)
function   = <function <lambda> at 0x0000000002E72A58>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge183\challenge183.py:1: ImportError
_____________ ERROR collecting pemjh/challenge187/challenge187.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002E72C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000499ED48>)
function   = <function <lambda> at 0x0000000002E72C88>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge187\challenge187.py:1: ImportError
_____________ ERROR collecting pemjh/challenge203/challenge203.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002E72F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000483B7C8>)
function   = <function <lambda> at 0x0000000002E72F98>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge203\challenge203.py:1: ImportError
_____________ ERROR collecting pemjh/challenge204/challenge204.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045CA6D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000498DFC8>)
function   = <function <lambda> at 0x00000000045CA6D8>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge204\challenge204.py:1: ImportError
_____________ ERROR collecting pemjh/challenge211/challenge211.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045CAAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000485F0C8>)
function   = <function <lambda> at 0x00000000045CAAC8>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge211\challenge211.py:1: ImportError
_____________ ERROR collecting pemjh/challenge214/challenge214.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004832198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004AAA2C8>)
function   = <function <lambda> at 0x0000000004832198>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes, primeFactors, phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge214\challenge214.py:1: ImportError
_____________ ERROR collecting pemjh/challenge231/challenge231.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004832278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002FFF308>)
function   = <function <lambda> at 0x0000000004832278>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge231\challenge231.py:1: ImportError
_____________ ERROR collecting pemjh/challenge234/challenge234.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004832E48>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000482DA88>)
function   = <function <lambda> at 0x0000000004832E48>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge234\challenge234.py:1: ImportError
_____________ ERROR collecting pemjh/challenge243/challenge243.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000471D908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000497A848>)
function   = <function <lambda> at 0x000000000471D908>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge243\challenge243.py:1: ImportError
================================== FAILURES ===================================
______________________________ [pylint] setup.py ______________________________
C: 36, 0: No space allowed around keyword argument assignment
    name = "pemjh",
         ^ (bad-whitespace)
C: 37, 0: No space allowed around keyword argument assignment
    version = "0.0.1",
            ^ (bad-whitespace)
C: 38, 0: No space allowed around keyword argument assignment
    author = "Matthew Hussey",
           ^ (bad-whitespace)
C: 39, 0: No space allowed around keyword argument assignment
    author_email = "matthew.hussey@googlemail.com",
                 ^ (bad-whitespace)
C: 40, 0: No space allowed around keyword argument assignment
    description = ("Project euler (https://projecteuler.net/) challenge "
                ^ (bad-whitespace)
C: 42, 0: No space allowed around keyword argument assignment
    license = "None, private use by myself only",
            ^ (bad-whitespace)
C: 43, 0: No space allowed around keyword argument assignment
    keywords = "code challenge euler",
             ^ (bad-whitespace)
C: 44, 0: No space allowed around keyword argument assignment
    url = "none.non",
        ^ (bad-whitespace)
C: 45, 0: No space allowed around keyword argument assignment
    packages = ["pemjh"],
             ^ (bad-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
    long_description = read("README"),
                     ^ (bad-whitespace)
C: 50, 0: No space allowed around keyword argument assignment
    cmdclass = {"test": Tox},
             ^ (bad-whitespace)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing class docstring (missing-docstring)
F: 27, 8: Unable to import 'tox' (import-error)
W: 24, 8: Attribute 'test_suite' defined outside __init__ (attribute-defined-outside-init)
W: 23, 8: Attribute 'test_args' defined outside __init__ (attribute-defined-outside-init)
W: 20, 8: Attribute 'tox_args' defined outside __init__ (attribute-defined-outside-init)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\setup.py:6:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\setup.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:18:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:21:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:25:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:26:9: E265 block comment should start with '# '
D:\Development\pemjh\setup.py:36:9: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:36:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:12: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:14: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:13: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:19: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:18: E251 unexpected spaces around keyword / parameter equals

___________________________ [pylint] pemjh/main.py ____________________________
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 58, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  9, 0: No exception type(s) specified (bare-except)
F:  6, 4: Unable to import 'psyco' (import-error)
C: 12, 0: Invalid function name "testFunction" (invalid-name)
C: 12, 0: Invalid argument name "id" (invalid-name)
C: 12, 0: Invalid argument name "knownAnswer" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
W: 12,27: Redefining name 'knownAnswer' from outer scope (line 46) (redefined-outer-name)
W: 12,17: Redefining built-in 'id' (redefined-builtin)
W: 12,21: Redefining name 'func' from outer scope (line 43) (redefined-outer-name)
C: 30, 0: Invalid constant name "wholeTime" (invalid-name)
C: 32, 0: Invalid constant name "failures" (invalid-name)
C: 34, 0: Invalid constant name "nChallenges" (invalid-name)
C: 60, 0: Invalid constant name "wholeTime" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\main.py:13:15: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\main.py:32:18: W291 trailing whitespace
D:\Development\pemjh\pemjh\main.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\main.py:58:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge001/challenge001.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid constant name "upper" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  4,15: Used builtin function 'filter' (bad-builtin)
W:  4,15: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C:  6, 0: Invalid constant name "answer" (invalid-name)
W:  9, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge001\challenge001.py:9:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge002/challenge002.py _________________
C: 10, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "numRange" (invalid-name)
C: 10, 4: Invalid variable name "evenNums" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge003/challenge003.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 19,26: More than one statement on a single line (multiple-statements)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import math (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge003\challenge003.py:1:1: F401 'math' imported but unused
D:\Development\pemjh\pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge003\challenge003.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge004/challenge004.py _________________
C:  8, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 18, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 26, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 18,61: More than one statement on a single line (multiple-statements)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W: 36, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge004\challenge004.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge005/challenge005.py _________________
C: 12, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  3, 4: Redefining built-in 'max' (redefined-builtin)
C:  6, 8: Invalid variable name "n" (invalid-name)
C: 14,16: Invalid variable name "n" (invalid-name)
C: 28,23: More than one statement on a single line (multiple-statements)
C: 31, 8: Invalid variable name "n" (invalid-name)
C: 31,11: Invalid variable name "p" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge005\challenge005.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge006/challenge006.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'max' (redefined-builtin)
W: 10, 4: Redefining built-in 'sum' (redefined-builtin)
C:  4, 4: Invalid variable name "sumOfSquares" (invalid-name)
C:  7, 8: Invalid variable name "sumOfSquares" (invalid-name)
C: 13, 4: Invalid variable name "squareOfSums" (invalid-name)
C: 20, 0: Invalid constant name "answer" (invalid-name)
W: 23, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:23:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge007/challenge007.py _________________
C: 14, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'max' (redefined-builtin)
C: 13, 8: Invalid variable name "primeRange" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
W: 24, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge007\challenge007.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge008/challenge008.py _________________
C: 29, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'input' (redefined-builtin)
C: 26, 8: Invalid variable name "testPart" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
W: 44, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge008\challenge008.py:44:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge009/challenge009.py _________________
C:  8, 0: Exactly one space required after comma
    for a in range(1,(max / 3)):
                    ^ (bad-whitespace)
C: 11, 0: Exactly one space required after comma
        for b in range((a + 1),(a + 1 + (remainder / 2))):
                              ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  4, 4: Redefining built-in 'max' (redefined-builtin)
W:  5, 4: Redefining name 'answer' from outer scope (line 18) (redefined-outer-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C: 11,12: Invalid variable name "b" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge010/challenge010.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  6, 4: Redefining built-in 'max' (redefined-builtin)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ifilter imported from itertools (unused-import)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge010\challenge010.py:1:1: F401 'ifilter' imported but unused
D:\Development\pemjh\pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge010\challenge010.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge011/challenge011.py _________________
C:  2, 0: Line too long (1212/100) (line-too-long)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCols" (invalid-name)
C: 10, 8: Invalid variable name "currentRow" (invalid-name)
C: 12,12: Invalid variable name "nextChunk" (invalid-name)
C: 31,36: More than one statement on a single line (multiple-statements)
C: 38,40: More than one statement on a single line (multiple-statements)
C: 45,40: More than one statement on a single line (multiple-statements)
C: 52,36: More than one statement on a single line (multiple-statements)
W: 11,12: Unused variable 'index' (unused-variable)
R:  1, 0: Too many branches (16/12) (too-many-branches)
C: 58, 0: Invalid constant name "answer" (invalid-name)
W: 61, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:61:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge012/challenge012.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 15, 0: Invalid function name "triangleDivisors" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 16, 4: Invalid variable name "n" (invalid-name)
C: 17, 4: Invalid variable name "nOdd" (invalid-name)
C: 18, 4: Invalid variable name "nEven" (invalid-name)
C: 19, 4: Invalid variable name "knownDivisors" (invalid-name)
C: 24,12: Invalid variable name "nOdd" (invalid-name)
C: 27,12: Invalid variable name "nEven" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36,22: More than one statement on a single line (multiple-statements)
W: 38,12: Using possibly undefined loop variable 'n' (undefined-loop-variable)
W: 38,17: Using possibly undefined loop variable 'n' (undefined-loop-variable)
C: 40, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge013/challenge013.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:111, 0: Invalid constant name "answer" (invalid-name)
W:114, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:114:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge014/challenge014.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getChainSize" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "knownChains" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "knownChains" (invalid-name)
C: 31, 8: Invalid variable name "newChain" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge015/challenge015.py _________________
C:  7, 0: No space allowed around keyword argument assignment
def multiplierGen(n = 0):
                    ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "multiplierGen" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid function name "getRoutes" (invalid-name)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge016/challenge016.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge016\challenge016.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge017/challenge017.py _________________
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 37, 0: Trailing whitespace (trailing-whitespace)
C:103, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumberLength" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "hundredRep" (invalid-name)
C:  1, 0: Invalid argument name "andRep" (invalid-name)
C:  1, 0: Invalid argument name "thousandRep" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "tempN" (invalid-name)
C:  7, 8: Invalid variable name "numberRepresentation" (invalid-name)
C: 13,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 16,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 18,12: Invalid variable name "tempN" (invalid-name)
C: 22,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 29,16: Invalid variable name "tempN" (invalid-name)
C: 31,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 35,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 41, 0: Missing function docstring (missing-docstring)
C: 70, 4: Invalid variable name "knownInts" (invalid-name)
C:100, 4: Invalid variable name "endLine" (invalid-name)
W: 70, 4: Unused variable 'knownInts' (unused-variable)
W:100, 4: Unused variable 'endLine' (unused-variable)
C:106, 0: Invalid constant name "answer" (invalid-name)
W:109, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:5: F841 local variable 'knownInts' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:100:5: F841 local variable 'endLine' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:109:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge018/challenge018.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge018\challenge018.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge019/challenge019.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isLeapYear" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "getYearDays" (invalid-name)
C:  5, 0: Invalid argument name "y" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "getFirstJan" (invalid-name)
C: 11, 0: Invalid argument name "y" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "totalDays" (invalid-name)
C: 14, 8: Invalid variable name "totalDays" (invalid-name)
C: 17, 0: Invalid function name "monthStartDays" (invalid-name)
C: 17, 0: Invalid argument name "y" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "monthLengths" (invalid-name)
C: 25, 8: Invalid variable name "m" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "totalDays" (invalid-name)
C: 34, 8: Invalid variable name "y" (invalid-name)
C: 36,12: Invalid variable name "d" (invalid-name)
C: 38,16: Invalid variable name "totalDays" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
W: 45, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge020/challenge020.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge020\challenge020.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge021/challenge021.py _________________
C: 18, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
W: 11, 4: Redefining built-in 'dict' (redefined-builtin)
C: 12, 8: Invalid variable name "a" (invalid-name)
C: 14, 8: Invalid variable name "b" (invalid-name)
C: 15,12: Invalid variable name "d" (invalid-name)
C: 16,12: Invalid variable name "b" (invalid-name)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'

_________________ [pylint] pemjh/challenge022/challenge022.py _________________
C: 25, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getNames" (invalid-name)
C:  4, 0: Invalid argument name "fp" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7,21: Invalid variable name "f" (invalid-name)
C: 16, 0: Invalid function name "scoredNames" (invalid-name)
C: 16, 0: Invalid argument name "f" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 21,12: Invalid variable name "c" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 29, 8: Invalid variable name "s" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W: 37, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:37:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge023/challenge023.py _________________
C: 10, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "sumOfDivisors" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "p" (invalid-name)
C: 13,12: Invalid variable name "p" (invalid-name)
C: 23, 0: Invalid function name "isSum" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 0: Missing function docstring (missing-docstring)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge024/challenge024.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge024\challenge024.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge025/challenge025.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8,11: Invalid variable name "c" (invalid-name)
C:  9, 8: Invalid variable name "l" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge026/challenge026.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "biggestD" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C: 14,12: Invalid variable name "newSize" (invalid-name)
C: 18,16: Invalid variable name "biggestD" (invalid-name)
C: 20,12: Invalid variable name "newSize" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import string (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge026\challenge026.py:1:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge027/challenge027.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "aMax" (invalid-name)
C: 13, 4: Invalid variable name "bMax" (invalid-name)
C: 16, 4: Invalid variable name "bS" (invalid-name)
C: 17, 8: Invalid variable name "b" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "n" (invalid-name)
C: 21,16: Invalid variable name "f" (invalid-name)
C: 22,35: More than one statement on a single line (multiple-statements)
C: 23,16: Invalid variable name "n" (invalid-name)
C: 27,16: Invalid variable name "aMax" (invalid-name)
C: 28,16: Invalid variable name "bMax" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge027\challenge027.py:6:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge027\challenge027.py:35:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge028/challenge028.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge028\challenge028.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge029/challenge029.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "aLower" (invalid-name)
C:  3, 4: Invalid variable name "aUpper" (invalid-name)
C:  4, 4: Invalid variable name "bLower" (invalid-name)
C:  5, 4: Invalid variable name "bUpper" (invalid-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  9,12: Invalid variable name "b" (invalid-name)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge029\challenge029.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge030/challenge030.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "perDigit" (invalid-name)
C:  7, 4: Invalid variable name "grandTotal" (invalid-name)
C: 11,12: Invalid variable name "c" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "grandTotal" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge030\challenge030.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge031/challenge031.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPatternCount" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid constant name "answer" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
W: 22, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge031\challenge031.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge032/challenge032.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge032\challenge032.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge033/challenge033.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "totalNum" (invalid-name)
C:  9, 4: Invalid variable name "totalDen" (invalid-name)
C: 20,16: Invalid variable name "n1" (invalid-name)
C: 21,16: Invalid variable name "n2" (invalid-name)
C: 22,16: Invalid variable name "d3" (invalid-name)
C: 23,16: Invalid variable name "d4" (invalid-name)
C: 29,24: Invalid variable name "totalNum" (invalid-name)
C: 30,24: Invalid variable name "totalDen" (invalid-name)
C: 37,24: Invalid variable name "totalNum" (invalid-name)
C: 38,24: Invalid variable name "totalDen" (invalid-name)
C: 40, 4: Invalid variable name "totalNum" (invalid-name)
C: 40,14: Invalid variable name "totalDen" (invalid-name)
C: 44, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:47:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge034/challenge034.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "getLimit" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "factSum" (invalid-name)
C:  9, 4: Invalid variable name "factNine" (invalid-name)
C: 13, 8: Invalid variable name "factSum" (invalid-name)
C: 15,29: More than one statement on a single line (multiple-statements)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 8: Invalid variable name "iStr" (invalid-name)
C: 35, 8: Invalid variable name "iTotal" (invalid-name)
C: 36,12: Invalid variable name "c" (invalid-name)
C: 37,12: Invalid variable name "iTotal" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge035/challenge035.py _________________
C: 32, 0: Wrong continued indentation.
              if b == True and
              ^   | (bad-continuation)
C: 33, 0: Wrong continued indentation.
              ((p < 10) or not any(c in str(p) for c in disallowedChars))])
              ^   | (bad-continuation)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "nStr" (invalid-name)
C: 15, 8: Invalid variable name "nextString" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "disallowedChars" (invalid-name)
C: 35, 4: Invalid variable name "circularCount" (invalid-name)
C: 39, 8: Invalid variable name "circularList" (invalid-name)
C: 42, 8: Invalid variable name "allFound" (invalid-name)
C: 48,16: Invalid variable name "allFound" (invalid-name)
C: 51,12: Invalid variable name "circularCount" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sievedPrimes imported from utils.numbers (unused-import)
W:  5, 0: Unused fact imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'fact' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'sievedPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
D:\Development\pemjh\pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge035\challenge035.py:58:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge036/challenge036.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getBinaryString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "binStr" (invalid-name)
C:  5, 8: Invalid variable name "binStr" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 18, 8: Invalid variable name "decStr" (invalid-name)
C: 21,12: Invalid variable name "binStr" (invalid-name)
W: 11, 4: Unused variable 'limit' (unused-variable)
W: 14, 4: Unused variable 'binary' (unused-variable)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W: 29, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge036\challenge036.py:11:5: F841 local variable 'limit' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:14:5: F841 local variable 'binary' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge037/challenge037.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "isTruncPrime" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 12,23: More than one statement on a single line (multiple-statements)
C: 13,45: More than one statement on a single line (multiple-statements)
C: 18,51: More than one statement on a single line (multiple-statements)
C: 23, 0: Missing function docstring (missing-docstring)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge038/challenge038.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "isPandigital" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "m" (invalid-name)
C: 12,11: Invalid variable name "l" (invalid-name)
C: 12,14: Invalid variable name "u" (invalid-name)
C: 13,12: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge038\challenge038.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge039/challenge039.py _________________
W: 18, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
W: 19, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numPerimeters" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "a" (invalid-name)
C: 16, 8: Invalid variable name "bLimit" (invalid-name)
C: 17,12: Invalid variable name "b" (invalid-name)
C: 18,11: Invalid variable name "c" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "highestVal" (invalid-name)
C: 30, 8: Invalid variable name "iCount" (invalid-name)
C: 33,12: Invalid variable name "highestVal" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge039\challenge039.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge040/challenge040.py _________________
C: 11, 0: No space allowed before bracket
        total *= int (str(currentValue)[index - currentN - 1])
                     ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "currentN" (invalid-name)
C:  5, 4: Invalid variable name "currentValue" (invalid-name)
C:  9,12: Invalid variable name "currentValue" (invalid-name)
C: 10,12: Invalid variable name "currentN" (invalid-name)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
D:\Development\pemjh\pemjh\challenge040\challenge040.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge041/challenge041.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
F:  6, 0: Unable to import 'utils.strings' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 15,36: More than one statement on a single line (multiple-statements)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge041\challenge041.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge042/challenge042.py _________________
C: 35, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "scoreWord" (invalid-name)
C:  4, 0: Invalid argument name "w" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "x" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12,62: Invalid variable name "f" (invalid-name)
C: 23, 8: Invalid variable name "nTriangleWords" (invalid-name)
C: 30,16: Invalid variable name "nTriangleWords" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge042\challenge042.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge043/challenge043.py _________________
C:  8, 0: Trailing whitespace (trailing-whitespace)
W: 19, 0: Bad indentation. Found 12 spaces, expected 8 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.strings' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge044/challenge044.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "isPent" (invalid-name)
C:  6, 0: Invalid argument name "p" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "n" (invalid-name)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "pk" (invalid-name)
C: 19, 8: Invalid variable name "performedOneStep" (invalid-name)
C: 20,12: Invalid variable name "pj" (invalid-name)
C: 21,12: Invalid variable name "diffPkPj" (invalid-name)
C: 22,45: More than one statement on a single line (multiple-statements)
C: 25,12: Invalid variable name "performedOneStep" (invalid-name)
C: 27,33: More than one statement on a single line (multiple-statements)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge044\challenge044.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge045/challenge045.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
W:  4, 0: Redefining built-in 'hex' (redefined-builtin)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "pentAndHex" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "p" (invalid-name)
C: 10, 4: Invalid variable name "h" (invalid-name)
C: 12, 8: Invalid variable name "pVal" (invalid-name)
C: 13, 8: Invalid variable name "hVal" (invalid-name)
C: 19,12: Invalid variable name "p" (invalid-name)
C: 21,12: Invalid variable name "h" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 26, 8: Redefining built-in 'next' (redefined-builtin)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge046/challenge046.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "hasCriteria" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "dSq" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "n" (invalid-name)
C: 25, 8: Invalid variable name "n" (invalid-name)
C: 26,36: More than one statement on a single line (multiple-statements)
C: 26,36: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge046\challenge046.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge047/challenge047.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "numPrimeFactors" (invalid-name)
C:  8, 0: Invalid argument name "nPrimes" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "n" (invalid-name)
C: 11, 8: Invalid variable name "pf" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Invalid function name "hasNumPrimes" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 20,30: More than one statement on a single line (multiple-statements)
C: 24, 0: Missing function docstring (missing-docstring)
W: 30, 4: Redefining name 'count' from outer scope (line 1) (redefined-outer-name)
C: 31, 8: Invalid variable name "p" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused count imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
D:\Development\pemjh\pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge048/challenge048.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid constant name "answer" (invalid-name)
W:  8, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge048\challenge048.py:8:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge049/challenge049.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 18, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 21,12: Invalid variable name "p1" (invalid-name)
C: 22,16: Invalid variable name "p2" (invalid-name)
C: 24,16: Invalid variable name "p3" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge049\challenge049.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge050/challenge050.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
W: 13, 4: Redefining name 'answer' from outer scope (line 26) (redefined-outer-name)
C:  9, 4: Invalid variable name "knownPrimes" (invalid-name)
C: 11, 4: Invalid variable name "nPrimes" (invalid-name)
C: 18,31: More than one statement on a single line (multiple-statements)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge050\challenge050.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge050\challenge050.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge051/challenge051.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "substitutePrimes" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid function name "has3SameDigits" (invalid-name)
C: 24, 0: Invalid argument name "n" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "w" (invalid-name)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
C: 39,12: Invalid variable name "w" (invalid-name)
C: 41,16: Invalid variable name "nPrimes" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge052/challenge052.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getSortedString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "x" (invalid-name)
C:  9, 8: Invalid variable name "x" (invalid-name)
C: 10, 8: Invalid variable name "xStr" (invalid-name)
C: 15,12: Invalid variable name "ix" (invalid-name)
C: 16,12: Invalid variable name "ixStr" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge053/challenge053.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge053\challenge053.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge054/challenge054.py _________________
C:122, 0: Trailing whitespace (trailing-whitespace)
C:131, 0: Trailing whitespace (trailing-whitespace)
C:133, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getDuplicateCounts" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "valCounts" (invalid-name)
C: 14, 0: Invalid function name "isStraight" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid function name "isFlush" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid function name "scoreHand" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 52, 8: Invalid variable name "c1" (invalid-name)
C: 52,12: Invalid variable name "c2" (invalid-name)
C: 53, 8: Invalid variable name "v1" (invalid-name)
C: 53,12: Invalid variable name "v2" (invalid-name)
R: 26, 0: Too many return statements (11/6) (too-many-return-statements)
R: 26, 0: Too many branches (15/12) (too-many-branches)
C: 96, 0: Invalid function name "compareHands" (invalid-name)
C: 96, 0: Invalid argument name "handOne" (invalid-name)
C: 96, 0: Invalid argument name "handTwo" (invalid-name)
C: 96, 0: Missing function docstring (missing-docstring)
C:100, 4: Invalid variable name "handOneScore" (invalid-name)
C:100,18: Invalid variable name "handTwoScore" (invalid-name)
C:106,12: Invalid variable name "c1" (invalid-name)
C:106,16: Invalid variable name "c2" (invalid-name)
C:114, 0: Missing function docstring (missing-docstring)
C:115, 4: Invalid variable name "faceConvert" (invalid-name)
C:118, 4: Invalid variable name "nHandOneWins" (invalid-name)
C:119,62: Invalid variable name "f" (invalid-name)
C:120,12: Invalid variable name "l" (invalid-name)
C:129,16: Invalid variable name "nHandOneWins" (invalid-name)
C:133, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace

_________________ [pylint] pemjh/challenge055/challenge055.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "becomesPalindrome" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "workingN" (invalid-name)
C:  6, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
D:\Development\pemjh\pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge055\challenge055.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge056/challenge056.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "a" (invalid-name)
C:  4,12: Invalid variable name "b" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
W: 16, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge056\challenge056.py:16:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge057/challenge057.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTopHeavy" (invalid-name)
C:  5, 8: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  8,15: Invalid variable name "d" (invalid-name)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 10,11: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nTopHeavy" (invalid-name)
W:  7,12: Unused variable 'i' (unused-variable)
C: 17, 0: Invalid constant name "answer" (invalid-name)
W: 20, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge057\challenge057.py:20:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge058/challenge058.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nPrimes" (invalid-name)
C: 13, 4: Invalid variable name "primeChecker" (invalid-name)
C: 22,16: Invalid variable name "nPrimes" (invalid-name)
W: 18,12: Unused variable 'j' (unused-variable)
W:  9, 4: Unused variable 'total' (unused-variable)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
D:\Development\pemjh\pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge059/challenge059.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 27,64: Invalid variable name "f" (invalid-name)
C: 29,12: Invalid variable name "l" (invalid-name)
W: 48, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge060/challenge060.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 64, 0: Line too long (118/100) (line-too-long)
C: 69, 0: Trailing whitespace (trailing-whitespace)
C: 85, 0: Line too long (141/100) (line-too-long)
C: 94, 0: Trailing whitespace (trailing-whitespace)
C: 95, 0: Trailing whitespace (trailing-whitespace)
C: 97, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid constant name "primeSet" (invalid-name)
C:  8, 0: Invalid constant name "maxPrime" (invalid-name)
C: 10, 0: Invalid function name "getNumLength" (invalid-name)
C: 10, 0: Invalid argument name "n" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 14, 8: Invalid variable name "l" (invalid-name)
C: 17, 0: Invalid argument name "m" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "isConcatPrime" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "newFirst" (invalid-name)
C: 25, 4: Invalid variable name "newLast" (invalid-name)
C: 29, 0: Invalid function name "getPrimePairs" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "nPrimes" (invalid-name)
C: 33, 8: Invalid variable name "m" (invalid-name)
C: 34, 8: Invalid variable name "p" (invalid-name)
C: 38,12: Invalid variable name "n" (invalid-name)
C: 39,12: Invalid variable name "q" (invalid-name)
C: 47, 0: Invalid function name "nextDigits" (invalid-name)
C: 47, 0: Invalid argument name "nToFind" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "currentSum" (invalid-name)
C: 49, 4: Invalid variable name "currentSolution" (invalid-name)
C: 50, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 61,16: Invalid variable name "foundSolution" (invalid-name)
C: 64,16: Invalid variable name "foundSolution" (invalid-name)
C: 67,16: Invalid variable name "currentSolution" (invalid-name)
C: 68,16: Invalid variable name "currentSolutionSum" (invalid-name)
C: 71, 0: Invalid function name "nextDigitsDict" (invalid-name)
C: 71, 0: Invalid argument name "nToFind" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 72, 4: Invalid variable name "currentSum" (invalid-name)
C: 73, 4: Invalid variable name "currentSolution" (invalid-name)
C: 74, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 77, 8: Invalid variable name "p" (invalid-name)
C: 83,12: Invalid variable name "foundSolution" (invalid-name)
C: 86,12: Invalid variable name "newPotential" (invalid-name)
C: 87,12: Invalid variable name "foundSolution" (invalid-name)
C: 92,12: Invalid variable name "currentSolution" (invalid-name)
C: 93,12: Invalid variable name "currentSolutionSum" (invalid-name)
C: 98, 0: Missing function docstring (missing-docstring)
W:109, 4: Redefining name 'answer' from outer scope (line 116) (redefined-outer-name)
C:116, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace

_________________ [pylint] pemjh/challenge061/challenge061.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "hasDuplicates" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "eachInList" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 17,12: Invalid variable name "newNums" (invalid-name)
C: 18,12: Invalid variable name "newLists" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
W: 51, 4: Redefining built-in 'oct' (redefined-builtin)
W: 55, 4: Redefining built-in 'all' (redefined-builtin)
W: 43, 4: Redefining built-in 'hex' (redefined-builtin)
R: 24, 0: Too many local variables (27/15) (too-many-locals)
C: 28, 4: Invalid variable name "allLists" (invalid-name)
C: 35, 4: Invalid variable name "sq" (invalid-name)
C: 56, 4: Invalid variable name "d" (invalid-name)
C: 57, 8: Invalid variable name "n" (invalid-name)
C: 64, 8: Invalid variable name "n" (invalid-name)
C: 70,16: Invalid variable name "l" (invalid-name)
C: 76, 8: Invalid variable name "n1" (invalid-name)
C: 79,12: Invalid variable name "n2" (invalid-name)
C: 82,16: Invalid variable name "n3" (invalid-name)
C: 85,20: Invalid variable name "n4" (invalid-name)
C: 88,24: Invalid variable name "n5" (invalid-name)
C: 91,28: Invalid variable name "n6" (invalid-name)
C: 94,32: Invalid variable name "n7" (invalid-name)
R: 24, 0: Too many branches (17/12) (too-many-branches)
C:101, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'

_________________ [pylint] pemjh/challenge062/challenge062.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "n" (invalid-name)
C:  8, 8: Invalid variable name "potentialAnswer" (invalid-name)
C: 19,20: Invalid variable name "nCubes" (invalid-name)
C: 21,12: Invalid variable name "nCubes" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge063/challenge063.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14,26: More than one statement on a single line (multiple-statements)
C: 20,29: More than one statement on a single line (multiple-statements)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge064/challenge064.py _________________
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getPeriodLength" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "pathGen" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 4: Invalid variable name "nOdd" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 32,12: Invalid variable name "nOdd" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge065/challenge065.py _________________
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "nextDen" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused divisors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge065\challenge065.py:4:1: F401 'divisors' imported but unused
D:\Development\pemjh\pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge066/challenge066.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "diophantineX" (invalid-name)
C:  8, 0: Invalid argument name "d" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "x" (invalid-name)
C: 10,11: Invalid variable name "y" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)

_________________ [pylint] pemjh/challenge067/challenge067.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  9, 0: Unable to import 'utils.numbers' (import-error)
C: 11, 0: Missing function docstring (missing-docstring)
W: 14,65: Redefining built-in 'file' (redefined-builtin)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge067\challenge067.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge068/challenge068.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPairs" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "getSpokes" (invalid-name)
C:  7, 0: Invalid argument name "startIndex" (invalid-name)
C:  7, 0: Invalid argument name "nSpokes" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 18,16: Invalid variable name "nextSpokes" (invalid-name)
C: 19,16: Invalid variable name "y" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 54,20: Unused variable 'move' (unused-variable)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)

_________________ [pylint] pemjh/challenge069/challenge069.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "sp" (invalid-name)
C: 11, 4: Invalid variable name "nPhi" (invalid-name)
C: 12,11: Invalid variable name "n" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge070/challenge070.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "isPermutation" (invalid-name)
C:  8, 0: Invalid argument name "a" (invalid-name)
C:  8, 0: Invalid argument name "b" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 17,11: Invalid variable name "p" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused import string (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge071/challenge071.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "targetNum" (invalid-name)
C:  5, 4: Invalid variable name "targetDen" (invalid-name)
C:  8, 4: Invalid variable name "bestNum" (invalid-name)
C:  9, 4: Invalid variable name "bestDen" (invalid-name)
C: 13, 8: Invalid variable name "highNum" (invalid-name)
C: 14, 8: Invalid variable name "lowNum" (invalid-name)
C: 18,55: More than one statement on a single line (multiple-statements)
C: 20,12: Invalid variable name "leftSide" (invalid-name)
C: 21,12: Invalid variable name "rightSide" (invalid-name)
C: 23,16: Invalid variable name "bestNum" (invalid-name)
C: 23,25: Invalid variable name "bestDen" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge072/challenge072.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge073/challenge073.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "shareDivisors" (invalid-name)
C:  8, 0: Invalid argument name "n1" (invalid-name)
C:  8, 0: Invalid argument name "n2" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "d" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "upperNum" (invalid-name)
C: 19, 4: Invalid variable name "upperDen" (invalid-name)
C: 20, 4: Invalid variable name "lowerNum" (invalid-name)
C: 21, 4: Invalid variable name "lowerDen" (invalid-name)
C: 25, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 26, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 28, 8: Invalid variable name "upperLimit" (invalid-name)
C: 29, 8: Invalid variable name "upperLimit" (invalid-name)
C: 31, 8: Invalid variable name "rangeLimits" (invalid-name)
W: 31, 8: Unused variable 'rangeLimits' (unused-variable)
C: 39, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:31:9: F841 local variable 'rangeLimits' is assigned to but never used

_________________ [pylint] pemjh/challenge074/challenge074.py _________________
C:  2, 0: Line too long (109/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "factSum" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "chainSize" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "w" (invalid-name)
C:  8, 4: Invalid variable name "firstW" (invalid-name)
C:  9, 4: Invalid variable name "routeLen" (invalid-name)
C: 17,12: Invalid variable name "routeLen" (invalid-name)
C: 19,12: Invalid variable name "w" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 27, 4: Unused variable 'target' (unused-variable)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
D:\Development\pemjh\pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:27:5: F841 local variable 'target' is assigned to but never used

_________________ [pylint] pemjh/challenge075/challenge075.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "l" (invalid-name)
C:  8,15: Invalid variable name "a" (invalid-name)
C:  8,18: Invalid variable name "b" (invalid-name)
C:  8,21: Invalid variable name "c" (invalid-name)
C: 21, 4: Invalid variable name "l" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge076/challenge076.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numBreakDowns" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  9, 8: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nBreakDowns" (invalid-name)
C: 12,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 14,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge077/challenge077.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "pc" (invalid-name)
C: 17,12: Invalid variable name "a" (invalid-name)
C: 18,12: Invalid variable name "b" (invalid-name)
C: 21,16: Invalid variable name "abSums" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)

_________________ [pylint] pemjh/challenge078/challenge078.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
W:  6, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W:  7, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W: 15, 0: Found indentation with tabs instead of spaces (mixed-indentation)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "n" (invalid-name)
C:  3, 4: Invalid variable name "p" (invalid-name)
C:  6, 7: Invalid variable name "s" (invalid-name)
C: 10,16: Invalid variable name "s" (invalid-name)
C: 13,16: Invalid variable name "s" (invalid-name)
C: 17, 8: Invalid variable name "m" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge079/challenge079.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
W:  2, 0: Unused import string (unused-import)
W: 14, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge079\challenge079.py:2:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge079\challenge079.py:14:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge080/challenge080.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "buildRoot" (invalid-name)
C:  3, 0: Invalid argument name "sq" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W: 14, 4: Redefining name 'answer' from outer scope (line 36) (redefined-outer-name)
W: 18, 8: Redefining built-in 'next' (redefined-builtin)
C:  5, 4: Invalid function name "getNextNum" (invalid-name)
C:  5, 4: Missing function docstring (missing-docstring)
W:  5,19: Unused argument 'target' (unused-argument)
C: 13, 4: Invalid variable name "prevNum" (invalid-name)
C: 24, 8: Invalid variable name "prevNum" (invalid-name)
W: 16, 8: Unused variable 'i' (unused-variable)
C: 28, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge081/challenge081.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "addRows" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "r1" (invalid-name)
C:  7, 8: Invalid variable name "r2" (invalid-name)
C: 10,12: Invalid variable name "i1" (invalid-name)
C: 11,12: Invalid variable name "i2" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 21,63: Invalid variable name "f" (invalid-name)
C: 22, 8: Invalid variable name "tr" (invalid-name)
C: 26,12: Invalid variable name "n" (invalid-name)
C: 26,15: Invalid variable name "l" (invalid-name)
W: 28,26: Using possibly undefined loop variable 'i' (undefined-loop-variable)
C: 39, 4: Invalid variable name "tr" (invalid-name)
C: 43, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge082/challenge082.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "combineColumns" (invalid-name)
C:  5, 0: Invalid argument name "c1" (invalid-name)
C:  5, 0: Invalid argument name "c2" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "downRow" (invalid-name)
C: 11, 8: Invalid variable name "v1" (invalid-name)
C: 11,12: Invalid variable name "v2" (invalid-name)
C: 23, 4: Invalid variable name "newRow" (invalid-name)
C: 26, 8: Invalid variable name "v1" (invalid-name)
C: 26,12: Invalid variable name "v2" (invalid-name)
C: 39, 0: Missing function docstring (missing-docstring)
C: 42,23: Invalid variable name "f" (invalid-name)
W: 44,16: Used builtin function 'map' (bad-builtin)
W: 48,26: Lambda may not be necessary (unnecessary-lambda)
C: 50, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused izip imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge082\challenge082.py:3:1: F401 'izip' imported but unused
D:\Development\pemjh\pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge083/challenge083.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getGrid" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6,63: Invalid variable name "f" (invalid-name)
C:  9,12: Invalid variable name "nextLine" (invalid-name)
C: 16, 0: Invalid function name "compareToProcess" (invalid-name)
C: 16, 0: Invalid argument name "m" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 27, 0: Missing function docstring (missing-docstring)
W: 35,11: Used builtin function 'map' (bad-builtin)
W: 35,11: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 35,27: Used builtin function 'map' (bad-builtin)
W: 35,27: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C: 38, 4: Invalid variable name "toProcess" (invalid-name)
C: 45, 8: Invalid variable name "x" (invalid-name)
C: 45,11: Invalid variable name "y" (invalid-name)
C: 55,12: Invalid variable name "nx" (invalid-name)
C: 55,16: Invalid variable name "ny" (invalid-name)
C: 56,12: Invalid variable name "newSquare" (invalid-name)
C: 59,12: Invalid variable name "newLength" (invalid-name)
W: 40, 4: Unused variable 'processed' (unused-variable)
C: 77, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge083\challenge083.py:40:5: F841 local variable 'processed' is assigned to but never used
D:\Development\pemjh\pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'

_________________ [pylint] pemjh/challenge084/challenge084.py _________________
C:  8, 0: No space allowed around keyword argument assignment
def chanceCardMove(current, prev = [0]):
                                 ^ (bad-whitespace)
C: 52, 0: No space allowed around keyword argument assignment
def communityChestCardMove(current, prev = [0]):
                                         ^ (bad-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C: 77, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:100, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "rollDice" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  8, 0: Dangerous default value [] as argument (dangerous-default-value)
C:  8, 0: Invalid function name "chanceCardMove" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
R:  8, 0: Too many return statements (13/6) (too-many-return-statements)
R:  8, 0: Too many branches (14/12) (too-many-branches)
W: 52, 0: Dangerous default value [] as argument (dangerous-default-value)
C: 52, 0: Invalid function name "communityChestCardMove" (invalid-name)
C: 52, 0: Missing function docstring (missing-docstring)
C: 68, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "doubleCount" (invalid-name)
C: 85,12: Invalid variable name "doubleCount" (invalid-name)
C: 87,12: Invalid variable name "doubleCount" (invalid-name)
C: 94,12: Invalid variable name "doubleCount" (invalid-name)
C:111, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace

_________________ [pylint] pemjh/challenge085/challenge085.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numRects" (invalid-name)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Invalid argument name "w" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "rh" (invalid-name)
C:  5,12: Invalid variable name "rw" (invalid-name)
C:  6,12: Invalid variable name "numAcross" (invalid-name)
C:  7,12: Invalid variable name "numDown" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 32,16: Invalid variable name "areaRectangles" (invalid-name)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge086/challenge086.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def isInt(a, msq, sqLib, found = list()):
                               ^ (bad-whitespace)
C:  2, 0: Unnecessary parens after 'return' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value list() (__builtin__.list) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "isInt" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "sqLib" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  1,25: Unused argument 'found' (unused-argument)
C:  4, 0: Invalid function name "getNumPairs" (invalid-name)
C:  4, 0: Invalid argument name "pairSum" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nPairs" (invalid-name)
C:  8, 4: Invalid variable name "a" (invalid-name)
C:  9, 4: Invalid variable name "b" (invalid-name)
C: 11, 8: Invalid variable name "a" (invalid-name)
C: 12, 8: Invalid variable name "b" (invalid-name)
C: 16,12: Invalid variable name "nPairs" (invalid-name)
C: 19, 0: Invalid function name "getStepSize" (invalid-name)
C: 19, 0: Invalid argument name "m" (invalid-name)
C: 19, 0: Invalid argument name "sqLib" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "nStep" (invalid-name)
W: 25, 4: Unreachable code (unreachable)
C: 27, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "sqLimit" (invalid-name)
C: 33, 4: Invalid variable name "m" (invalid-name)
C: 36, 8: Invalid variable name "m" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge087/challenge087.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sqLimit" (invalid-name)
C: 13, 4: Invalid variable name "sqPrimes" (invalid-name)
C: 16, 4: Invalid variable name "cuLimit" (invalid-name)
C: 17, 4: Invalid variable name "cuPrimes" (invalid-name)
C: 20, 4: Invalid variable name "foLimit" (invalid-name)
C: 21, 4: Invalid variable name "foPrimes" (invalid-name)
C: 23, 4: Invalid variable name "nAnswers" (invalid-name)
C: 24, 8: Invalid variable name "s" (invalid-name)
C: 25,12: Invalid variable name "c" (invalid-name)
C: 26,12: Invalid variable name "sc" (invalid-name)
C: 29,16: Invalid variable name "f" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge087\challenge087.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge088/challenge088.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def findPossibleProducts(limit, known = dict()):
                                      ^ (bad-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "findPossibleProducts" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12,20: Invalid variable name "s" (invalid-name)
C: 12,23: Invalid variable name "d" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 25, 8: Invalid variable name "pr" (invalid-name)
C: 25,12: Invalid variable name "s" (invalid-name)
C: 25,15: Invalid variable name "d" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ceil imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge088\challenge088.py:1:1: F401 'ceil' imported but unused
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace

_________________ [pylint] pemjh/challenge089/challenge089.py _________________
C: 56, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C: 17, 0: Invalid function name "convertChar" (invalid-name)
C: 17, 0: Invalid argument name "c" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
R: 17, 0: Too many return statements (7/6) (too-many-return-statements)
C: 33, 0: Invalid function name "decypherNumeral" (invalid-name)
C: 33, 0: Invalid argument name "s" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "currentTotal" (invalid-name)
C: 38, 8: Invalid variable name "v" (invalid-name)
C: 41,12: Invalid variable name "currentTotal" (invalid-name)
C: 43,12: Invalid variable name "currentTotal" (invalid-name)
C: 46,12: Invalid variable name "currentTotal" (invalid-name)
C: 53, 0: Invalid function name "getNumeral" (invalid-name)
C: 53, 0: Invalid argument name "n" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 61,13: Invalid variable name "c" (invalid-name)
C: 62, 8: Invalid variable name "nDiv" (invalid-name)
C: 67, 0: Invalid function name "getRomanNumeralSaving" (invalid-name)
C: 67, 0: Invalid argument name "s" (invalid-name)
C: 67, 0: Missing function docstring (missing-docstring)
C: 69, 4: Invalid variable name "preLength" (invalid-name)
C: 75, 4: Invalid variable name "newNumeral" (invalid-name)
C: 76, 4: Invalid variable name "newLength" (invalid-name)
C: 81, 0: Missing function docstring (missing-docstring)
C: 83,62: Invalid variable name "f" (invalid-name)
C: 87, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
D:\Development\pemjh\pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge090/challenge090.py _________________
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 78, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "get6Combs" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "c6" (invalid-name)
C: 10, 8: Invalid variable name "i6" (invalid-name)
C: 15, 8: Invalid variable name "i6" (invalid-name)
C: 20, 0: Invalid function name "fillRemaining" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid function name "validAddition" (invalid-name)
C: 29, 0: Invalid argument name "newFace" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 35, 0: Invalid function name "amendCubesForSquare" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "newCube1" (invalid-name)
C: 56, 8: Invalid variable name "newCube0" (invalid-name)
C: 62, 4: Invalid variable name "newCube0" (invalid-name)
C: 63, 4: Invalid variable name "newCube1" (invalid-name)
C: 71, 0: Invalid function name "buildCubes" (invalid-name)
C: 71, 0: Invalid argument name "squaresLeft" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nextSquare" (invalid-name)
C: 77, 4: Invalid variable name "suitableCubes" (invalid-name)
C:109,16: Invalid variable name "c0" (invalid-name)
C:110,20: Invalid variable name "c1" (invalid-name)
R: 71, 0: Too many branches (13/12) (too-many-branches)
C:116, 0: Missing function docstring (missing-docstring)
C:117, 4: Invalid variable name "squareNumbers" (invalid-name)
C:119, 4: Invalid variable name "possibleNumbers" (invalid-name)
C:125, 8: Invalid variable name "c" (invalid-name)
W:119, 4: Unused variable 'possibleNumbers' (unused-variable)
W:125, 8: Unused variable 'c' (unused-variable)
C:129, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:119:5: F841 local variable 'possibleNumbers' is assigned to but never used

_________________ [pylint] pemjh/challenge091/challenge091.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "bruteForce" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTriangles" (invalid-name)
C:  5, 8: Invalid variable name "x1" (invalid-name)
C:  6,12: Invalid variable name "y1" (invalid-name)
C:  9,16: Invalid variable name "nTriangles" (invalid-name)
C: 12,16: Invalid variable name "nTriangles" (invalid-name)
C: 15,20: Invalid variable name "x2" (invalid-name)
C: 16,24: Invalid variable name "y2" (invalid-name)
C: 29,32: Invalid variable name "nTriangles" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "gridSize" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge092/challenge092.py _________________
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 87, 0: Trailing whitespace (trailing-whitespace)
C:112, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Invalid function name "getDigits" (invalid-name)
C:  6, 0: Invalid argument name "n" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "workingN" (invalid-name)
C: 11, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 20, 8: Invalid variable name "workingN" (invalid-name)
C: 29,20: Invalid variable name "d" (invalid-name)
C: 31,16: Invalid variable name "workingN" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "n" (invalid-name)
C: 41, 8: Invalid variable name "workingN" (invalid-name)
C: 45,12: Invalid variable name "workingN" (invalid-name)
C: 46,19: Invalid variable name "c" (invalid-name)
C: 52,12: Invalid variable name "workingN" (invalid-name)
W: 42, 8: Unused variable 'route' (unused-variable)
C: 58, 0: Invalid function name "buildNumber" (invalid-name)
C: 58, 0: Missing function docstring (missing-docstring)
C: 61, 0: Missing function docstring (missing-docstring)
C: 73, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "prevI" (invalid-name)
C: 75, 4: Invalid variable name "nI" (invalid-name)
C: 80,12: Invalid variable name "nI" (invalid-name)
C: 83,12: Invalid variable name "prevI" (invalid-name)
C: 84,12: Invalid variable name "nI" (invalid-name)
C: 90, 0: Invalid function name "squareVal" (invalid-name)
C: 90, 0: Missing function docstring (missing-docstring)
C: 91, 4: Invalid variable name "n" (invalid-name)
C: 96, 8: Invalid variable name "n" (invalid-name)
C:100, 0: Missing function docstring (missing-docstring)
C:101, 4: Invalid variable name "n" (invalid-name)
C:108,12: Invalid variable name "n" (invalid-name)
C:110, 0: Missing function docstring (missing-docstring)
C:111, 4: Invalid variable name "nDigits" (invalid-name)
C:120, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:42:9: F841 local variable 'route' is assigned to but never used
D:\Development\pemjh\pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:123:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge093/challenge093.py _________________
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 96, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nLeft" (invalid-name)
C: 12, 0: Invalid argument name "a" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "op" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid argument name "l" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "v" (invalid-name)
C: 34, 0: Invalid function name "equatedNumbers" (invalid-name)
C: 34, 0: Invalid argument name "a" (invalid-name)
C: 34, 0: Invalid argument name "b" (invalid-name)
C: 34, 0: Invalid argument name "c" (invalid-name)
C: 34, 0: Invalid argument name "d" (invalid-name)
C: 34, 0: Missing function docstring (missing-docstring)
W: 40, 8: No exception type(s) specified (bare-except)
C: 39,13: More than one statement on a single line (multiple-statements)
C: 40,16: More than one statement on a single line (multiple-statements)
W: 44, 8: No exception type(s) specified (bare-except)
C: 43,13: More than one statement on a single line (multiple-statements)
C: 44,16: More than one statement on a single line (multiple-statements)
W: 48, 8: No exception type(s) specified (bare-except)
C: 47,13: More than one statement on a single line (multiple-statements)
C: 48,16: More than one statement on a single line (multiple-statements)
W: 52, 8: No exception type(s) specified (bare-except)
C: 51,13: More than one statement on a single line (multiple-statements)
C: 52,16: More than one statement on a single line (multiple-statements)
W: 56, 8: No exception type(s) specified (bare-except)
C: 55,13: More than one statement on a single line (multiple-statements)
C: 56,16: More than one statement on a single line (multiple-statements)
C: 60, 0: Missing function docstring (missing-docstring)
C: 68, 8: Invalid variable name "a" (invalid-name)
C: 69,12: Invalid variable name "b" (invalid-name)
C: 70,16: Invalid variable name "c" (invalid-name)
C: 71,20: Invalid variable name "d" (invalid-name)
C: 77,28: Invalid variable name "n" (invalid-name)
W: 90,19: Using possibly undefined loop variable 'd' (undefined-loop-variable)
W: 92,15: Using possibly undefined loop variable 'c' (undefined-loop-variable)
W: 94,11: Using possibly undefined loop variable 'b' (undefined-loop-variable)
C: 99, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge094/challenge094.py _________________
C: 11, 0: Exactly one space required after comma
    prev_2 = (4,  0)
               ^ (bad-whitespace)
C: 12, 0: Exactly one space required after comma
    prev_1 = (15,  1)
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "n" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
W: 38,12: Redefining built-in 'long' (redefined-builtin)
C: 31, 8: Invalid variable name "c" (invalid-name)
C: 33, 8: Invalid variable name "rt" (invalid-name)
C: 50, 0: Invalid constant name "desc" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge095/challenge095.py _________________
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 47, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid function name "chainLengths" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "x" (invalid-name)
C: 38,12: Invalid variable name "lChain" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge096/challenge096.py _________________
C:104, 0: Trailing whitespace (trailing-whitespace)
C:120, 0: Line too long (150/100) (line-too-long)
C:228, 0: Trailing whitespace (trailing-whitespace)
C:240, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  6, 0: Invalid function name "sortSquareLengths" (invalid-name)
C:  6, 0: Invalid argument name "a" (invalid-name)
C:  6, 0: Invalid argument name "b" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "la" (invalid-name)
C:  8, 4: Invalid variable name "lb" (invalid-name)
C: 16, 0: Missing class docstring (missing-docstring)
C: 16, 0: Old-style class defined. (old-style-class)
C: 20, 4: Invalid argument name "s" (invalid-name)
W: 23,50: Unused variable 'i' (unused-variable)
C: 36, 4: Invalid method name "__loadData" (invalid-name)
C: 36, 4: Invalid argument name "s" (invalid-name)
C: 36, 4: Missing method docstring (missing-docstring)
C: 40,12: Invalid variable name "r" (invalid-name)
C: 42,16: Invalid variable name "c" (invalid-name)
C: 46, 4: Invalid method name "__getBox" (invalid-name)
C: 46, 4: Invalid argument name "r" (invalid-name)
C: 46, 4: Invalid argument name "c" (invalid-name)
C: 46, 4: Missing method docstring (missing-docstring)
C: 47, 8: Invalid function name "getStartIndex" (invalid-name)
C: 47, 8: Missing function docstring (missing-docstring)
C: 55, 8: Invalid variable name "rowStart" (invalid-name)
C: 57,12: Invalid variable name "columnStart" (invalid-name)
C: 61, 4: Invalid method name "__removeValueFromList" (invalid-name)
C: 61, 4: Invalid argument name "l" (invalid-name)
C: 61, 4: Missing method docstring (missing-docstring)
C: 62, 8: Invalid variable name "nRemoved" (invalid-name)
C: 64,12: Invalid variable name "sq" (invalid-name)
C: 66,16: Invalid variable name "nRemoved" (invalid-name)
R: 61, 4: Method could be a function (no-self-use)
C: 71, 4: Invalid method name "__setValue" (invalid-name)
C: 71, 4: Invalid argument name "r" (invalid-name)
C: 71, 4: Invalid argument name "c" (invalid-name)
C: 71, 4: Missing method docstring (missing-docstring)
C: 85, 8: Invalid variable name "sq" (invalid-name)
C: 96, 4: Invalid method name "__getAllBlocks" (invalid-name)
C: 96, 4: Missing method docstring (missing-docstring)
C:100,12: Invalid variable name "r" (invalid-name)
C:101,16: Invalid variable name "c" (invalid-name)
C:107, 4: Invalid method name "__processCompletedSquares" (invalid-name)
C:107, 4: Missing method docstring (missing-docstring)
C:110,12: Invalid variable name "r" (invalid-name)
C:111,16: Invalid variable name "sq" (invalid-name)
C:117, 4: Invalid method name "__processGroups" (invalid-name)
C:117, 4: Missing method docstring (missing-docstring)
C:124,16: Invalid variable name "sq" (invalid-name)
C:131,24: Invalid variable name "lSq" (invalid-name)
C:137,28: Invalid variable name "nRemoved" (invalid-name)
C:148, 4: Invalid method name "__getLocation" (invalid-name)
C:148, 4: Invalid argument name "sq" (invalid-name)
C:148, 4: Missing method docstring (missing-docstring)
C:150,12: Invalid variable name "r" (invalid-name)
C:151,16: Invalid variable name "c" (invalid-name)
C:157, 4: Invalid method name "__processOnlyInOneSquare" (invalid-name)
C:157, 4: Missing method docstring (missing-docstring)
C:176, 4: Missing method docstring (missing-docstring)
C:178,12: Invalid variable name "sRow" (invalid-name)
C:178,18: Invalid variable name "tRow" (invalid-name)
W:178,30: Access to a protected member __rows of a client class (protected-access)
C:179,16: Invalid variable name "sSquare" (invalid-name)
C:179,25: Invalid variable name "tSquare" (invalid-name)
C:183, 4: Missing method docstring (missing-docstring)
C:184, 8: Invalid variable name "progressMade" (invalid-name)
C:187,12: Invalid variable name "progressMade" (invalid-name)
C:189,12: Invalid variable name "progressMade" (invalid-name)
C:191,12: Invalid variable name "progressMade" (invalid-name)
C:195,12: Invalid variable name "unsolvedSquares" (invalid-name)
C:196,16: Invalid variable name "r" (invalid-name)
C:197,20: Invalid variable name "c" (invalid-name)
C:205,16: Invalid variable name "sq" (invalid-name)
W:211,20: Access to a protected member __setValue of a client class (protected-access)
W:214,24: Access to a protected member __solve of a client class (protected-access)
C:223, 4: Missing method docstring (missing-docstring)
C:224,12: Invalid variable name "r" (invalid-name)
C:225,16: Invalid variable name "sq" (invalid-name)
C:230, 4: Missing method docstring (missing-docstring)
C:231,12: Invalid variable name "r" (invalid-name)
C:232,16: Invalid variable name "sq" (invalid-name)
W:244, 8: Redefining built-in 'repr' (redefined-builtin)
C:245,12: Invalid variable name "r" (invalid-name)
C:247,16: Invalid variable name "sq" (invalid-name)
C:249,16: Invalid variable name "f1" (invalid-name)
C:250,16: Invalid variable name "f2" (invalid-name)
C:256, 0: Missing function docstring (missing-docstring)
W:267,12: Redefining built-in 'input' (redefined-builtin)
C:257,63: Invalid variable name "f" (invalid-name)
C:260, 8: Invalid variable name "nBroken" (invalid-name)
C:273,16: Invalid variable name "nBroken" (invalid-name)
W:263,12: Unused variable 'i' (unused-variable)
W:267,46: Unused variable 'j' (unused-variable)
W:260, 8: Unused variable 'nBroken' (unused-variable)
C:279, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge096\challenge096.py:3:1: F401 'sys' imported but unused
D:\Development\pemjh\pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge097/challenge097.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid constant name "answer" (invalid-name)
W:  7, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge097\challenge097.py:7:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge098/challenge098.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getMap" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'map' (redefined-builtin)
C:  6, 8: Invalid variable name "w" (invalid-name)
C:  6,11: Invalid variable name "s" (invalid-name)
C: 15, 0: Invalid function name "uniqueRight" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
W: 15,16: Redefining built-in 'map' (redefined-builtin)
C: 25, 0: Invalid function name "mapWord" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 25,18: Redefining built-in 'map' (redefined-builtin)
C: 27, 8: Invalid variable name "c" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
W: 81,16: Redefining built-in 'map' (redefined-builtin)
R: 32, 0: Too many local variables (19/15) (too-many-locals)
C: 35, 4: Invalid variable name "groupedWords" (invalid-name)
C: 37,62: Invalid variable name "f" (invalid-name)
C: 40,16: Invalid variable name "orderedWord" (invalid-name)
C: 46, 4: Invalid variable name "groupedWords" (invalid-name)
C: 70, 8: Invalid variable name "nWords" (invalid-name)
C: 75,12: Invalid variable name "lWord" (invalid-name)
C: 78,16: Invalid variable name "potentialSquare" (invalid-name)
C: 87,24: Invalid variable name "word2Square" (invalid-name)
C: 95, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)

_________________ [pylint] pemjh/challenge099/challenge099.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5,65: Invalid variable name "f" (invalid-name)
C:  6, 8: Invalid variable name "highestIndex" (invalid-name)
C:  7, 8: Invalid variable name "highestNumber" (invalid-name)
C:  8, 8: Invalid variable name "highestLine" (invalid-name)
C:  9,12: Invalid variable name "nL" (invalid-name)
C:  9,16: Invalid variable name "l" (invalid-name)
C: 10,12: Invalid variable name "n" (invalid-name)
C: 11,12: Invalid variable name "rootedPower" (invalid-name)
C: 13,16: Invalid variable name "highestNumber" (invalid-name)
C: 13,31: Invalid variable name "highestIndex" (invalid-name)
C: 13,45: Invalid variable name "highestLine" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
W: 19, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge099\challenge099.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge100/challenge100.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "b" (invalid-name)
C:  3, 4: Invalid variable name "n" (invalid-name)
C:  5, 8: Invalid variable name "b" (invalid-name)
C:  5,11: Invalid variable name "n" (invalid-name)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge101/challenge101.py _________________
C:  5, 0: Line too long (123/100) (line-too-long)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "highestPower" (invalid-name)
C: 14, 8: Invalid variable name "workedSequence" (invalid-name)
C: 16,12: Invalid variable name "x" (invalid-name)
C: 17,12: Invalid variable name "y" (invalid-name)
C: 28,16: Invalid variable name "y" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
D:\Development\pemjh\pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge102/challenge102.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "enclosesOrigin" (invalid-name)
C:  4, 0: Invalid argument name "x1" (invalid-name)
C:  4, 0: Invalid argument name "y1" (invalid-name)
C:  4, 0: Invalid argument name "x2" (invalid-name)
C:  4, 0: Invalid argument name "y2" (invalid-name)
C:  4, 0: Invalid argument name "x3" (invalid-name)
C:  4, 0: Invalid argument name "y3" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
R:  4, 0: Too many arguments (6/5) (too-many-arguments)
C: 17,12: Invalid variable name "i1" (invalid-name)
C: 18,12: Invalid variable name "i2" (invalid-name)
C: 21,12: Invalid variable name "i1" (invalid-name)
C: 22,12: Invalid variable name "i2" (invalid-name)
C: 25,12: Invalid variable name "i1" (invalid-name)
C: 26,12: Invalid variable name "i2" (invalid-name)
C: 33, 0: Invalid function name "getYIntercept" (invalid-name)
C: 33, 0: Invalid argument name "x1" (invalid-name)
C: 33, 0: Invalid argument name "y1" (invalid-name)
C: 33, 0: Invalid argument name "x2" (invalid-name)
C: 33, 0: Invalid argument name "y2" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "m" (invalid-name)
C: 38, 4: Invalid variable name "c" (invalid-name)
C: 43, 0: Missing function docstring (missing-docstring)
C: 46, 4: Invalid variable name "nEnclosing" (invalid-name)
C: 47,23: Invalid variable name "f" (invalid-name)
C: 48,12: Invalid variable name "l" (invalid-name)
C: 49,12: Invalid variable name "ax" (invalid-name)
C: 49,16: Invalid variable name "ay" (invalid-name)
C: 49,20: Invalid variable name "bx" (invalid-name)
C: 49,24: Invalid variable name "by" (invalid-name)
C: 49,28: Invalid variable name "cx" (invalid-name)
C: 49,32: Invalid variable name "cy" (invalid-name)
C: 51,16: Invalid variable name "nEnclosing" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge103/challenge103.py _________________
C: 41, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "subSets" (invalid-name)
C:  1, 0: Invalid argument name "l" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "setA" (invalid-name)
C:  5, 8: Invalid variable name "setB" (invalid-name)
C: 14, 0: Invalid argument name "l" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "B" (invalid-name)
C: 16,11: Invalid variable name "CPart" (invalid-name)
C: 19,16: Invalid variable name "C" (invalid-name)
C: 19,19: Invalid variable name "notUsed" (invalid-name)
C: 23,24: Invalid variable name "wB" (invalid-name)
C: 23,28: Invalid variable name "wC" (invalid-name)
C: 25,24: Invalid variable name "wB" (invalid-name)
C: 25,28: Invalid variable name "wC" (invalid-name)
W: 19,19: Unused variable 'notUsed' (unused-variable)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "midPoint" (invalid-name)
C: 48, 4: Invalid variable name "sumAns" (invalid-name)
C: 49, 8: Invalid variable name "b" (invalid-name)
C: 50, 8: Invalid variable name "newSet" (invalid-name)
C: 54,16: Invalid variable name "sumAns" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge104/challenge104.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "myEnumerate" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Invalid function name "fiboTrunc" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "aStart" (invalid-name)
C: 10,12: Invalid variable name "bStart" (invalid-name)
C: 11, 4: Invalid variable name "aEnd" (invalid-name)
C: 11,10: Invalid variable name "bEnd" (invalid-name)
C: 13, 4: Invalid variable name "endTrunc" (invalid-name)
C: 14, 4: Invalid variable name "startTrunc" (invalid-name)
C: 18, 8: Invalid variable name "aStart" (invalid-name)
C: 18,16: Invalid variable name "bStart" (invalid-name)
C: 19, 8: Invalid variable name "aEnd" (invalid-name)
C: 19,14: Invalid variable name "bEnd" (invalid-name)
C: 22, 8: Invalid variable name "aEnd" (invalid-name)
C: 23, 8: Invalid variable name "bEnd" (invalid-name)
C: 26,12: Invalid variable name "aStart" (invalid-name)
C: 27,12: Invalid variable name "bStart" (invalid-name)
C: 29, 8: Invalid variable name "aStartRet" (invalid-name)
C: 31,12: Invalid variable name "aStartRet" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "lowerLimit" (invalid-name)
C: 38,11: Invalid variable name "f" (invalid-name)
C: 39, 8: Invalid variable name "s" (invalid-name)
C: 40, 8: Invalid variable name "e" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused fibo imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge104\challenge104.py:1:1: F401 'fibo' imported but unused
D:\Development\pemjh\pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge105/challenge105.py _________________
C: 61, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "sizedSubsets" (invalid-name)
C:  4, 0: Invalid argument name "l" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "sizeL" (invalid-name)
C: 21, 0: Invalid function name "checkForDuplicateSetSums" (invalid-name)
C: 21, 0: Invalid argument name "l" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 22, 8: Invalid variable name "setSize" (invalid-name)
C: 23, 8: Invalid variable name "sumSub" (invalid-name)
C: 30, 0: Invalid argument name "l" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "nItems" (invalid-name)
C: 49, 0: Missing function docstring (missing-docstring)
C: 51,61: Invalid variable name "f" (invalid-name)
C: 60, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge106/challenge106.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "incrementTrilist" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "rightIndex" (invalid-name)
C: 16, 0: Invalid function name "allSubsets" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17, 4: Invalid variable name "triList" (invalid-name)
C: 28, 0: Invalid argument name "l" (invalid-name)
C: 28, 0: Missing function docstring (missing-docstring)
C: 48, 0: Invalid function name "getRequiredCompares" (invalid-name)
C: 48, 0: Missing function docstring (missing-docstring)
C: 49, 4: Invalid variable name "allS" (invalid-name)
C: 52, 4: Invalid variable name "workingS" (invalid-name)
C: 55, 4: Invalid variable name "workingS" (invalid-name)
C: 58, 4: Invalid variable name "workingS" (invalid-name)
C: 62, 0: Missing function docstring (missing-docstring)
C: 65, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge107/challenge107.py _________________
C: 22, 0: Line too long (102/100) (line-too-long)
C: 25, 0: Line too long (139/100) (line-too-long)
C: 25, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "skimNetwork" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "connectedRows" (invalid-name)
C:  7, 4: Invalid variable name "availableConnections" (invalid-name)
C: 22, 8: Invalid variable name "availableConnections" (invalid-name)
C: 30, 4: Invalid variable name "newGrid" (invalid-name)
W: 30,35: Unused variable 'row' (unused-variable)
C: 36, 0: Invalid function name "scoreGrid" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "r" (invalid-name)
C: 41,12: Invalid variable name "v" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 50,64: Invalid variable name "f" (invalid-name)
C: 56, 4: Invalid variable name "originalScore" (invalid-name)
C: 59, 4: Invalid variable name "newGrid" (invalid-name)
C: 62, 4: Invalid variable name "newScore" (invalid-name)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)

_________________ [pylint] pemjh/challenge108/challenge108.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge109/challenge109.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def getNonDoubleOuts(n, darts, nums, known = dict()):
                                           ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "getNonDoubleOuts" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nCount" (invalid-name)
C:  7, 8: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "nCount" (invalid-name)
C: 21, 0: Invalid function name "getDoubleOuts" (invalid-name)
C: 21, 0: Invalid argument name "n" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "nCount" (invalid-name)
C: 24,14: Invalid variable name "d" (invalid-name)
C: 26,12: Invalid variable name "nCount" (invalid-name)
C: 28,12: Invalid variable name "nCount" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "nCount" (invalid-name)
C: 43, 8: Invalid variable name "nCount" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge110/challenge110.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge111/challenge111.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def isPrime(p, pc = PrimeChecker()):
                  ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "isPrime" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "pc" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid function name "buildNums" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17,16: Invalid variable name "b" (invalid-name)
C: 24,16: Invalid variable name "b" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "M" (invalid-name)
C: 31, 4: Invalid variable name "N" (invalid-name)
C: 32, 4: Invalid variable name "S" (invalid-name)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36, 8: Invalid variable name "s" (invalid-name)
C: 38,12: Invalid variable name "m" (invalid-name)
C: 40,20: Invalid variable name "b" (invalid-name)
C: 44,28: Invalid variable name "n" (invalid-name)
C: 45,28: Invalid variable name "s" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused roughPrimes imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge111\challenge111.py:1:1: F401 'roughPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge112/challenge112.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isBouncy" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  6,11: Invalid variable name "nextM" (invalid-name)
C:  9,12: Invalid variable name "nextMovement" (invalid-name)
C: 11,12: Invalid variable name "nextMovement" (invalid-name)
C: 13,12: Invalid variable name "nextMovement" (invalid-name)
C: 15, 8: Invalid variable name "m" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "currentBouncy" (invalid-name)
C: 32, 4: Invalid variable name "currentNumber" (invalid-name)
C: 36,12: Invalid variable name "currentBouncy" (invalid-name)
C: 39,54: More than one statement on a single line (multiple-statements)
C: 41, 8: Invalid variable name "currentNumber" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge113/challenge113.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 21, 8: Invalid variable name "d" (invalid-name)
C: 22, 8: Invalid variable name "p" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge114/challenge114.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 14,16: Invalid variable name "nVariations" (invalid-name)
C: 17, 8: Invalid variable name "nVariations" (invalid-name)
C: 20, 8: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 4: Invalid variable name "n" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge115/challenge115.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, minimum, tileSizes, known = dict()):
                                                    ^ (bad-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 15,12: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 21, 8: Invalid variable name "nVariations" (invalid-name)
C: 27, 0: Invalid function name "f" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "b" (invalid-name)
C: 38, 8: Invalid variable name "b" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge116/challenge116.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                        ^ (bad-whitespace)
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                                      ^ (bad-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSize" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  9,12: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 15, 8: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "n2" (invalid-name)
C: 26, 4: Invalid variable name "n3" (invalid-name)
C: 27, 4: Invalid variable name "n4" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge117/challenge117.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 10,16: Invalid variable name "nVariations" (invalid-name)
C: 13, 8: Invalid variable name "nVariations" (invalid-name)
C: 16, 8: Invalid variable name "nVariations" (invalid-name)
C: 22, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "n" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge118/challenge118.py _________________
C: 10, 0: No space allowed around keyword argument assignment
def build_sets(existing, left, lExist = 0):
                                      ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 0: Invalid argument name "lExist" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "lLeft" (invalid-name)
C: 16, 8: Invalid variable name "lNew" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
W: 37,12: Used builtin function 'map' (bad-builtin)
C: 45, 0: Missing function docstring (missing-docstring)
C: 49, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge119/challenge119.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "sumDigits" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "w" (invalid-name)
C:  5, 8: Invalid variable name "w" (invalid-name)
C:  5,11: Invalid variable name "m" (invalid-name)
C:  9, 0: Invalid function name "an" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 16,12: Invalid variable name "p" (invalid-name)
C: 18,12: Invalid variable name "s" (invalid-name)
W: 16,12: Unused variable 'p' (unused-variable)
C: 25, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge120/challenge120.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "highestMod" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge121/challenge121.py _________________
C: 21, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "winChance" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "lossesAllowed" (invalid-name)
C: 22, 8: Invalid variable name "lossesAllowed" (invalid-name)
C: 27, 8: Invalid variable name "wc" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge122/challenge122.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12,16: Invalid variable name "f" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge123/challenge123.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getRemainder" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 11, 8: Invalid variable name "r" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 17, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge124/challenge124.py _________________
C:  5, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] > b[1]))):
        ^   | (bad-continuation)
C: 12, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] < b[1]))):
        ^   | (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 8: Invalid variable name "p" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge125/challenge125.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "rtLimit" (invalid-name)
C:  8, 8: Invalid variable name "rtLimit" (invalid-name)
C:  9, 4: Invalid variable name "rtLimit" (invalid-name)
C: 13, 8: Invalid variable name "sq" (invalid-name)
C: 15,12: Invalid variable name "sq" (invalid-name)
C: 26, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge126/challenge126.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 16, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 20, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 24, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 29, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "surroundingCubes" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Invalid argument name "z" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "maximumResult" (invalid-name)
C: 10, 4: Invalid variable name "maximumDepth" (invalid-name)
C: 12, 8: Invalid variable name "maximumDepth" (invalid-name)
C: 15, 8: Invalid variable name "maximumA" (invalid-name)
C: 17,12: Invalid variable name "maximumA" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "maximumB" (invalid-name)
C: 21,16: Invalid variable name "maximumB" (invalid-name)
C: 22,16: Invalid variable name "b" (invalid-name)
C: 23,16: Invalid variable name "maximumC" (invalid-name)
C: 25,20: Invalid variable name "maximumC" (invalid-name)
C: 26,20: Invalid variable name "c" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)

_________________ [pylint] pemjh/challenge127/challenge127.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 20,12: Redefining built-in 'next' (redefined-builtin)
C: 19, 8: Invalid variable name "c" (invalid-name)
C: 21,12: Invalid variable name "a" (invalid-name)
C: 24,12: Invalid variable name "b" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','

_________________ [pylint] pemjh/challenge128/challenge128.py _________________
C: 23, 0: Line too long (103/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "nPrimes" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)

_________________ [pylint] pemjh/challenge129/challenge129.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "A" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "n" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16,12: Invalid variable name "an" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
F: 25, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge130/challenge130.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "A" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
F: 28, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge131/challenge131.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "p" (invalid-name)
C: 18, 8: Invalid variable name "lowerCube" (invalid-name)
C: 19, 8: Invalid variable name "upperCube" (invalid-name)
C: 25,16: Invalid variable name "lowerCube" (invalid-name)
C: 30,16: Invalid variable name "upperCube" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge132/challenge132.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "R" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 13,33: More than one statement on a single line (multiple-statements)
C: 17, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge133/challenge133.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)

_________________ [pylint] pemjh/challenge134/challenge134.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "jumpSize" (invalid-name)
C:  3, 0: Invalid argument name "t" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "cInd" (invalid-name)
C: 21, 4: Invalid variable name "tInd" (invalid-name)
C: 29, 0: Invalid function name "f" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "s" (invalid-name)
C: 33, 4: Invalid variable name "c" (invalid-name)
C: 35, 4: Invalid variable name "t" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 51, 8: Invalid variable name "r" (invalid-name)
C: 54, 4: Invalid variable name "p1" (invalid-name)
C: 55, 4: Invalid variable name "S" (invalid-name)
C: 56, 8: Invalid variable name "p2" (invalid-name)
C: 61, 8: Invalid variable name "n" (invalid-name)
C: 63, 8: Invalid variable name "S" (invalid-name)
C: 65, 8: Invalid variable name "p1" (invalid-name)
W: 51, 8: Unused variable 'r' (unused-variable)
C: 68, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge135/challenge135.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumTarget" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "x" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "n" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge136/challenge136.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getNumTarget" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "p" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge137/challenge137.py _________________
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  8, 0: No space allowed around keyword argument assignment
def a(n, known = {0: 0, 1: 2, 2: 15}):
               ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining name 'a' from outer scope (line 8) (redefined-outer-name)
C:  2, 4: Invalid variable name "a" (invalid-name)
C:  2, 7: Invalid variable name "b" (invalid-name)
C:  4, 8: Invalid variable name "x" (invalid-name)
C:  6, 8: Invalid variable name "a" (invalid-name)
C:  6,11: Invalid variable name "b" (invalid-name)
W:  4, 8: Unused variable 'x' (unused-variable)
W:  8, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  8, 0: Invalid function name "a" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 19, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge138/challenge138.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 15, 8: Redefining built-in 'next' (redefined-builtin)
C:  4, 4: Invalid variable name "b1" (invalid-name)
C:  5, 4: Invalid variable name "b2" (invalid-name)
C: 17, 8: Invalid variable name "v" (invalid-name)
C: 21,12: Invalid variable name "v" (invalid-name)
C: 27,23: More than one statement on a single line (multiple-statements)
W:  7, 8: Unused variable 'i' (unused-variable)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)

_________________ [pylint] pemjh/challenge139/challenge139.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge142/challenge142.py _________________
C: 32, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "perfectSquare" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "a" (invalid-name)
C:  4, 0: Invalid argument name "b" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)

_________________ [pylint] pemjh/challenge144/challenge144.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "solveQuadratic" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "sqPart" (invalid-name)
C:  7, 0: Invalid argument name "x" (invalid-name)
C:  7, 0: Invalid argument name "y" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "impGrad" (invalid-name)
C: 12, 4: Invalid variable name "impAngle" (invalid-name)
C: 15, 4: Invalid variable name "inAngle" (invalid-name)
C: 18, 4: Invalid variable name "diffAngle" (invalid-name)
C: 21, 4: Invalid variable name "newAngle" (invalid-name)
C: 24, 4: Invalid variable name "newGradient" (invalid-name)
C: 29, 0: Invalid function name "nextStep" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "m" (invalid-name)
C: 34, 4: Invalid variable name "c" (invalid-name)
C: 41, 4: Invalid variable name "x1" (invalid-name)
C: 41, 8: Invalid variable name "x2" (invalid-name)
C: 45, 8: Invalid variable name "xImpact" (invalid-name)
C: 47, 8: Invalid variable name "xImpact" (invalid-name)
C: 49, 4: Invalid variable name "yImpact" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 56, 0: Missing function docstring (missing-docstring)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge145/challenge145.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "d" (invalid-name)
C:  8, 4: Invalid variable name "sevenDigits" (invalid-name)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge146/challenge146.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def is_pseudo_prime(n, known = {1: True, 2: True}):
                             ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "ns" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent

_________________ [pylint] pemjh/challenge148/challenge148.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 31, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge149/challenge149.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid argument name "l" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 29, 0: Missing function docstring (missing-docstring)
W: 35,13: Used builtin function 'map' (bad-builtin)
W: 44,13: Used builtin function 'map' (bad-builtin)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge151/challenge151.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a5" (invalid-name)
C:  1, 0: Invalid argument name "a4" (invalid-name)
C:  1, 0: Invalid argument name "a3" (invalid-name)
C:  1, 0: Invalid argument name "a2" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge162/challenge162.py _________________
C:  2, 0: Line too long (103/100) (line-too-long)
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid constant name "answer" (invalid-name)
C:  8, 0: Invalid constant name "desc" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge164/challenge164.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(size, previousThree, useZero, known = dict()):
                                                  ^ (bad-whitespace)
C: 15, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "useZero" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nLosses" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge166/challenge166.py _________________
C: 60, 0: Line too long (102/100) (line-too-long)
C: 65, 0: Line too long (114/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sq" (invalid-name)
R:  1, 0: Too many branches (14/12) (too-many-branches)
C: 70, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)

_________________ [pylint] pemjh/challenge173/challenge173.py _________________
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numOfSquares" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nSquares" (invalid-name)
C:  3, 4: Invalid variable name "holeWidth" (invalid-name)
C:  6, 8: Invalid variable name "holeArea" (invalid-name)
C: 12, 8: Invalid variable name "surroundingWidth" (invalid-name)
C: 16,12: Invalid variable name "totalArea" (invalid-name)
C: 19,12: Invalid variable name "surroundingArea" (invalid-name)
C: 24,12: Invalid variable name "surroundingWidth" (invalid-name)
C: 25,12: Invalid variable name "nSquares" (invalid-name)
C: 27, 8: Invalid variable name "holeWidth" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge174/challenge174.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def getDivisors(n, known = dict()):
                         ^ (bad-whitespace)
C: 11, 0: No space allowed around keyword argument assignment
def getNumEvenDivisors(n, known = dict()):
                                ^ (bad-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "getDivisors" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "d" (invalid-name)
W: 11, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 11, 0: Invalid function name "getNumEvenDivisors" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 4: Invalid variable name "nDiv" (invalid-name)
C: 20,12: Invalid variable name "nDiv" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nSquares" (invalid-name)
C: 31, 4: Invalid variable name "nMatches" (invalid-name)
C: 32, 8: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "nMatches" (invalid-name)
W: 33,24: Used builtin function 'filter' (bad-builtin)
W: 33,24: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 33,46: Cell variable n defined in loop (cell-var-from-loop)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge179/challenge179.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nSame" (invalid-name)
C:  8,12: Invalid variable name "a" (invalid-name)
C: 13,12: Invalid variable name "nSame" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge183/challenge183.py _________________
C:  4, 0: No space allowed around keyword argument assignment
def pf(n, known = dict()):
                ^ (bad-whitespace)
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 12, 0: No space allowed around keyword argument assignment
def factPower(b, f, known = dict()):
                          ^ (bad-whitespace)
C: 30, 0: Line too long (106/100) (line-too-long)
C: 32, 0: Line too long (107/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  4, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  4, 0: Invalid function name "pf" (invalid-name)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W: 12, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 12, 0: Invalid function name "factPower" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "f" (invalid-name)
C: 20,11: Invalid variable name "m" (invalid-name)
C: 26, 0: Invalid argument name "n" (invalid-name)
C: 26, 0: Invalid argument name "d" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "dFacts" (invalid-name)
C: 31, 4: Invalid variable name "termDen" (invalid-name)
C: 32, 4: Invalid variable name "dFacts" (invalid-name)
C: 36, 0: Invalid function name "M" (invalid-name)
C: 36, 0: Invalid argument name "N" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 0: Invalid function name "SD" (invalid-name)
C: 40, 0: Missing function docstring (missing-docstring)
C: 42, 8: Invalid variable name "N" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 53, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge187/challenge187.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nPrimes" (invalid-name)
C:  7, 4: Invalid variable name "nTwos" (invalid-name)
C: 12,12: Invalid variable name "nTwos" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge188/challenge188.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge190/challenge190.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "P" (invalid-name)
C:  1, 0: Invalid argument name "m" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge191/challenge191.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(days, previousThree, latesLeft, known = dict()):
                                                    ^ (bad-whitespace)
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
                                                              ^ (bad-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Line too long (105/100) (line-too-long)
C: 67, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "latesLeft" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  7, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "numVariations" (invalid-name)
C: 25, 0: Invalid argument name "tilePatterns" (invalid-name)
C: 25, 0: Invalid argument name "losingPatterns" (invalid-name)
R: 25, 0: Too many local variables (16/15) (too-many-locals)
C: 29, 4: Invalid variable name "nVariations" (invalid-name)
C: 35,16: Invalid variable name "c" (invalid-name)
C: 36,16: Invalid variable name "nVariations" (invalid-name)
C: 39,16: Invalid variable name "tilePattern" (invalid-name)
C: 41,16: Invalid variable name "lTilePattern" (invalid-name)
C: 45,24: Invalid variable name "nVariations" (invalid-name)
C: 50,16: Invalid variable name "nLeft" (invalid-name)
C: 52,20: Invalid variable name "nLeft" (invalid-name)
C: 55,20: Invalid variable name "lPattern" (invalid-name)
C: 62,24: Invalid variable name "nVariations" (invalid-name)
C: 66,12: Invalid variable name "nVariations" (invalid-name)
W: 35,16: Unused variable 'c' (unused-variable)
R: 25, 0: Too many branches (13/12) (too-many-branches)
C: 72, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nPatterns" (invalid-name)
C: 76, 4: Invalid variable name "nLosses" (invalid-name)
C: 80, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge197/challenge197.py _________________
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "f" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "n" (invalid-name)
C:  6, 4: Invalid variable name "u" (invalid-name)
C: 13, 8: Invalid variable name "u" (invalid-name)
W: 10, 4: Unused variable 'odd' (unused-variable)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge197\challenge197.py:10:5: F841 local variable 'odd' is assigned to but never used
D:\Development\pemjh\pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge203/challenge203.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "squareFree" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 29,12: Invalid variable name "p" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
D:\Development\pemjh\pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge204/challenge204.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getHams" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCount" (invalid-name)
C:  5, 8: Invalid variable name "p" (invalid-name)
C:  7, 8: Invalid variable name "pCurrent" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 14,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "pCurrent" (invalid-name)
C: 19, 0: Invalid function name "hamNums" (invalid-name)
C: 19, 0: Invalid argument name "maxPrime" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 23, 4: Unused variable 'found' (unused-variable)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:23:5: F841 local variable 'found' is assigned to but never used
D:\Development\pemjh\pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge205/challenge205.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "diceRolls" (invalid-name)
C:  7, 0: Invalid argument name "nDice" (invalid-name)
C:  7, 0: Invalid argument name "nSides" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nRolls" (invalid-name)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17,10: Invalid variable name "nPete" (invalid-name)
C: 18,11: Invalid variable name "nColin" (invalid-name)
C: 20, 4: Invalid variable name "peteWin" (invalid-name)
C: 21, 4: Invalid variable name "totalRolls" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 22,11: Invalid variable name "f" (invalid-name)
C: 24, 8: Invalid variable name "nWins" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge206/challenge206.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "v" (invalid-name)
C: 12, 0: Invalid function name "hasMask" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "w" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "lowestRoot" (invalid-name)
C: 34, 8: Invalid variable name "sq" (invalid-name)
C: 36, 8: Invalid variable name "hasM" (invalid-name)
C: 36,14: Invalid variable name "wrongIndex" (invalid-name)
C: 51,12: Invalid variable name "sq" (invalid-name)
C: 58,32: More than one statement on a single line (multiple-statements)
C: 62, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused floor imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge206\challenge206.py:1:1: F401 'floor' imported but unused
D:\Development\pemjh\pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge207/challenge207.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "a" (invalid-name)
C:  6, 4: Invalid variable name "b" (invalid-name)
C:  7, 4: Invalid variable name "t" (invalid-name)
C:  8, 4: Invalid variable name "nextPower" (invalid-name)
C: 10, 8: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "t" (invalid-name)
C: 16,12: Invalid variable name "nextPower" (invalid-name)
C: 20, 8: Invalid variable name "a" (invalid-name)
C: 20,11: Invalid variable name "b" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge211/challenge211.py _________________
C: 13, 0: Line too long (112/100) (line-too-long)
C: 54, 0: No space allowed around keyword argument assignment
def challenge211(calc = False):
                      ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "squareSum" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "slowButRight" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "d" (invalid-name)
C: 27,11: Invalid variable name "m" (invalid-name)
C: 30,12: Invalid variable name "a" (invalid-name)
C: 33,16: Invalid variable name "a" (invalid-name)
C: 34,16: Invalid variable name "d" (invalid-name)
C: 34,19: Invalid variable name "m" (invalid-name)
C: 44, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "x" (invalid-name)
C: 48, 8: Invalid variable name "s" (invalid-name)
C: 54, 0: Missing function docstring (missing-docstring)
C: 63, 0: Invalid constant name "answer" (invalid-name)
F: 66, 4: Unable to import 'psyco' (import-error)
W:  2, 0: Unused takewhile imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge211\challenge211.py:2:1: F401 'takewhile' imported but unused
D:\Development\pemjh\pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
D:\Development\pemjh\pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge214/challenge214.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def totients(n, primes = None):
                       ^ (bad-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def totientChainLength(n, current, limit, steps, known = dict()):
                                                       ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "p" (invalid-name)
C: 19,12: Invalid variable name "t" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "totientChainLength" (invalid-name)
C: 25, 0: Invalid argument name "n" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 51,12: Invalid variable name "v" (invalid-name)
W: 25,26: Unused argument 'current' (unused-argument)
C: 58, 0: Missing function docstring (missing-docstring)
C: 64, 8: Invalid variable name "p" (invalid-name)
C: 71, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused phi imported from utils.numbers (unused-import)
W:  1, 0: Unused primeFactors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'phi' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'primeFactors' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge215/challenge215.py _________________
C:  3, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  6, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C:  9, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 12, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "buildRowOptions" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid function name "runningCrack" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 31, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 31, 0: Invalid function name "W" (invalid-name)
C: 31, 0: Invalid argument name "startRow" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 39,16: Invalid variable name "subRow" (invalid-name)
C: 46, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "wallWidth" (invalid-name)
C: 49, 4: Invalid variable name "wallHeight" (invalid-name)
C: 51, 4: Invalid variable name "rowLinks" (invalid-name)
W: 53,11: Used builtin function 'map' (bad-builtin)
C: 61, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)

_________________ [pylint] pemjh/challenge216/challenge216.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
def challenge216(skip = True):
                      ^ (bad-whitespace)
C: 49, 0: Trailing whitespace (trailing-whitespace)
C: 51, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 54, 0: Exactly one space required after comma
    primes[0:2] = [False,False]
                        ^ (bad-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 60, 0: Trailing whitespace (trailing-whitespace)
C: 62, 0: Trailing whitespace (trailing-whitespace)
C: 63, 0: Exactly one space required after comma
    t[0:2] = [False,False]
                   ^ (bad-whitespace)
C: 64, 0: Trailing whitespace (trailing-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "l" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "v" (invalid-name)
C:  8,12: Invalid variable name "v" (invalid-name)
C: 20, 0: Invalid function name "sq" (invalid-name)
C: 20, 0: Invalid argument name "a" (invalid-name)
C: 20, 0: Invalid argument name "p" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 21, 4: Invalid variable name "q" (invalid-name)
C: 21, 7: Invalid variable name "e" (invalid-name)
C: 23, 8: Invalid variable name "e" (invalid-name)
C: 24, 8: Invalid variable name "q" (invalid-name)
C: 25, 4: Invalid variable name "n" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 28, 4: Invalid variable name "z" (invalid-name)
C: 29, 4: Invalid variable name "y" (invalid-name)
C: 29, 7: Invalid variable name "r" (invalid-name)
C: 29,10: Invalid variable name "x" (invalid-name)
C: 30, 4: Invalid variable name "b" (invalid-name)
C: 31, 4: Invalid variable name "x" (invalid-name)
C: 33, 8: Invalid variable name "bb" (invalid-name)
C: 33,12: Invalid variable name "m" (invalid-name)
C: 35,12: Invalid variable name "bb" (invalid-name)
C: 36,12: Invalid variable name "m" (invalid-name)
C: 39, 8: Invalid variable name "t" (invalid-name)
C: 41,12: Invalid variable name "t" (invalid-name)
C: 42, 8: Invalid variable name "y" (invalid-name)
C: 42,11: Invalid variable name "r" (invalid-name)
C: 42,14: Invalid variable name "x" (invalid-name)
C: 43, 8: Invalid variable name "b" (invalid-name)
W: 40,12: Unused variable 'k' (unused-variable)
C: 46, 0: Missing function docstring (missing-docstring)
C: 56, 8: Invalid variable name "x" (invalid-name)
C: 58,16: Invalid variable name "y" (invalid-name)
C: 61, 4: Invalid variable name "t" (invalid-name)
C: 65, 8: Invalid variable name "x" (invalid-name)
C: 67,12: Invalid variable name "s" (invalid-name)
C: 78, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge220/challenge220.py _________________
C:  2, 0: Exactly one space required after comma
    c = [0,1]
          ^ (bad-whitespace)
C: 13, 0: Exactly one space required after comma
    c2 = [-c2[1],c2[0]]
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "c" (invalid-name)
C:  5, 8: Invalid variable name "c" (invalid-name)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 12, 4: Invalid variable name "c2" (invalid-name)
C: 13, 4: Invalid variable name "c2" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
W: 17,20: Used builtin function 'map' (bad-builtin)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge225/challenge225.py _________________
C:  2, 0: Line too long (108/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 10,12: Invalid variable name "a" (invalid-name)
C: 10,15: Invalid variable name "b" (invalid-name)
C: 10,18: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)

_________________ [pylint] pemjh/challenge230/challenge230.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Line too long (110/100) (line-too-long)
C: 41, 0: Line too long (110/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "D" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "aSize" (invalid-name)
C:  7, 4: Invalid variable name "bSize" (invalid-name)
C:  9, 8: Invalid variable name "aSize" (invalid-name)
C:  9,15: Invalid variable name "bSize" (invalid-name)
C: 14, 4: Invalid variable name "workingN" (invalid-name)
C: 22, 8: Invalid variable name "firstSize" (invalid-name)
C: 25,12: Invalid variable name "workingN" (invalid-name)
C: 33, 8: Invalid variable name "containingStr" (invalid-name)
C: 35, 8: Invalid variable name "containingStr" (invalid-name)
W:  2, 4: Unused variable 'size' (unused-variable)
C: 39, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "a" (invalid-name)
C: 41, 4: Invalid variable name "b" (invalid-name)
C: 44,15: Invalid variable name "n" (invalid-name)
C: 49, 0: Invalid constant name "answer" (invalid-name)
W: 52, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge230\challenge230.py:2:5: F841 local variable 'size' is assigned to but never used
D:\Development\pemjh\pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:52:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge231/challenge231.py _________________
C: 43, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getFirstMultipleOnOrAfter" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "m" (invalid-name)
C: 10, 0: Invalid function name "getFirstMultipleOnOrBefore" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 17, 0: Invalid function name "numInRange" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 23, 0: Missing function docstring (missing-docstring)
C: 24, 4: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "p" (invalid-name)
C: 43,12: Invalid variable name "numRange" (invalid-name)
C: 49,12: Invalid variable name "denRange" (invalid-name)
C: 53,12: Invalid variable name "inRange" (invalid-name)
C: 59,16: Invalid variable name "inRange" (invalid-name)
C: 62,16: Invalid variable name "inRange" (invalid-name)
W: 36, 8: Unused variable 'index' (unused-variable)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:36:9: F841 local variable 'index' is assigned to but never used
D:\Development\pemjh\pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace

_________________ [pylint] pemjh/challenge234/challenge234.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Wrong continued indentation.
                          next**2 if next**2 < limit + 1 else limit + 1,
                          ^| (bad-continuation)
C: 24, 0: Wrong continued indentation.
                          current))
                          ^| (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Missing function docstring (missing-docstring)
W: 19, 8: Redefining built-in 'next' (redefined-builtin)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent

_________________ [pylint] pemjh/challenge235/challenge235.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "r" (invalid-name)
C:  4, 4: Invalid variable name "dr" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  7, 8: Invalid variable name "s" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 11,12: Invalid variable name "r" (invalid-name)
C: 12, 8: Invalid variable name "dr" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge243/challenge243.py _________________
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "d" (invalid-name)
C: 24,23: More than one statement on a single line (multiple-statements)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 37,20: Invalid variable name "m" (invalid-name)
C: 38,20: Invalid variable name "d" (invalid-name)
C: 46, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge250/challenge250.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W: 12,12: Unused variable 'j' (unused-variable)
C: 20, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge259/challenge259.py _________________
C: 22, 0: No space allowed around keyword argument assignment
def get_totals(start, end, known = {}):
                                 ^ (bad-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "g" (invalid-name)
C: 10, 0: Invalid argument name "a" (invalid-name)
C: 10, 0: Invalid argument name "b" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid argument name "a" (invalid-name)
C: 13, 0: Invalid argument name "b" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid argument name "a" (invalid-name)
C: 16, 0: Invalid argument name "b" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid argument name "a" (invalid-name)
C: 19, 0: Invalid argument name "b" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 22, 0: Dangerous default value {} as argument (dangerous-default-value)
C: 22, 0: Missing function docstring (missing-docstring)
C: 55, 0: Invalid constant name "answer" (invalid-name)
C: 57, 0: Missing function docstring (missing-docstring)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)

_________________ [pylint] pemjh/challenge265/challenge265.py _________________
C: 10, 0: Trailing whitespace (trailing-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Trailing whitespace (trailing-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  3, 4: Invalid variable name "s" (invalid-name)
C:  4, 4: Invalid variable name "d" (invalid-name)
C:  4, 7: Invalid variable name "m" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  6, 4: Invalid variable name "d" (invalid-name)
C:  6, 7: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "s" (invalid-name)
C:  8, 4: Invalid variable name "s" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Invalid argument name "d" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "b" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "getSequences" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 26, 8: Invalid variable name "b" (invalid-name)
C: 30,16: Invalid variable name "s" (invalid-name)
C: 35, 0: Invalid function name "S" (invalid-name)
C: 35, 0: Invalid argument name "n" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 49, 0: Missing function docstring (missing-docstring)
C: 52, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace

--------------- coverage: platform win32, python 2.7.10-final-0 ---------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge001\challenge001       7      3      4      3    45%   4, 9-10
pemjh\challenge002\challenge002      12     10      8      7    15%   2-3, 6-16
pemjh\challenge003\challenge003      17     13     10      5    33%   5-23, 28-29
pemjh\challenge004\challenge004      19     16     10      9    14%   5-31, 36-37
pemjh\challenge005\challenge005      24     21     18     17    10%   2-34, 39-40
pemjh\challenge006\challenge006      13     10      4      3    24%   2-18, 23-24
pemjh\challenge007\challenge007      18     13      9      8    22%   5-19, 24-25
pemjh\challenge008\challenge008      16     13     10      9    15%   2-39, 44-45
pemjh\challenge009\challenge009      14     11      8      7    18%   4-16, 21-22
pemjh\challenge010\challenge010      14      9     10      9    25%   6-13, 18-19
pemjh\challenge011\challenge011      39     36     26     25     6%   2-56, 61-62
pemjh\challenge012\challenge012      31     28     14      9    18%   2-3, 7-44
pemjh\challenge013\challenge013      11      8      4      3    27%   2-109, 114-115
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      8      5    17%   2-3, 7-32
pemjh\challenge016\challenge016      12      9      4      3    25%   2-12, 17-18
pemjh\challenge017\challenge017      33     29     16     15    10%   2-39, 42-104, 109-110
pemjh\challenge018\challenge018      26     24      4      3    10%   2-3, 6-31
pemjh\challenge019\challenge019      32     25     18     17    16%   2, 6-9, 12-15, 19-28, 33-40, 45-46
pemjh\challenge020\challenge020      16     12      6      5    23%   2-5, 9-16, 21-22
pemjh\challenge021\challenge021      21     19     14     13     9%   2-3, 7-33
pemjh\challenge022\challenge022      28     21     10      9    21%   5-14, 17-24, 28-32, 37-38
pemjh\challenge023\challenge023      24     18     16     14    20%   2-3, 7-21, 24, 27-29, 34
pemjh\challenge024\challenge024      14     12      6      5    15%   2-3, 7-18
pemjh\challenge025\challenge025      15     13     10      9    12%   2-3, 5-19
pemjh\challenge026\challenge026      21     17     10      9    16%   4-23, 28-29
pemjh\challenge027\challenge027      27     25     14     11    12%   2-3, 6-36
pemjh\challenge028\challenge028      14     11      4      3    22%   2-13, 18-19
pemjh\challenge029\challenge029      14     11      6      5    20%   2-12, 17-18
pemjh\challenge030\challenge030      19     16     10      9    14%   3-16, 21-22
pemjh\challenge031\challenge031      16     12      6      5    23%   2-14, 19, 22-23
pemjh\challenge032\challenge032      20     18     10      9    10%   2-3, 7-27
pemjh\challenge033\challenge033      33     31     18     17     6%   2-3, 7-48
pemjh\challenge034\challenge034      30     28     14     11    11%   2-3, 7-46
pemjh\challenge035\challenge035      38     36     24     23     5%   2-3, 6-59
pemjh\challenge036\challenge036      22     18     10      9    16%   2-7, 11-24, 29-30
pemjh\challenge037\challenge037      27     25     18     15    11%   2-3, 7-36
pemjh\challenge038\challenge038      20     15     10      9    20%   4, 7-21, 26-27
pemjh\challenge039\challenge039      27     23     14     13    12%   2-23, 26-34, 39-40
pemjh\challenge040\challenge040      15     12      6      5    19%   2-13, 18-19
pemjh\challenge041\challenge041      17     15      8      7    12%   2-3, 6-23
pemjh\challenge042\challenge042      30     24     14     13    16%   5-9, 12-36, 41-42
pemjh\challenge043\challenge043      14     12      6      5    15%   2-3, 6-27
pemjh\challenge044\challenge044      27     21     14     13    17%   4, 7-11, 14-29, 34-35
pemjh\challenge045\challenge045      25     19     12      7    30%   2, 5, 9-21, 24-29, 34-35
pemjh\challenge046\challenge046      23     20     12      9    17%   4-5, 8-32
pemjh\challenge047\challenge047      37     34     22     19    10%   4-5, 8-50
pemjh\challenge048\challenge048       7      4      2      1    44%   2-3, 8-10
pemjh\challenge049\challenge049      24     21     16     15    10%   4-5, 8-32
pemjh\challenge050\challenge050      24     22     12     11     8%   2-3, 6-30
pemjh\challenge051\challenge051      38     35     24     21    10%   4-5, 8-50
pemjh\challenge052\challenge052      20     16      8      7    18%   2, 5-22, 27-28
pemjh\challenge053\challenge053      16     14     10      9    12%   2-3, 6-20
pemjh\challenge054\challenge054      71     61     44     43    10%   5-12, 16-19, 22-24, 39-93, 98-111, 115-131, 136
pemjh\challenge055\challenge055      23     19     12      9    20%   2-12, 15-21, 26-27
pemjh\challenge056\challenge056      14     11      8      7    18%   2-11, 16-17
pemjh\challenge057\challenge057      15     12      8      7    17%   2-15, 20-21
pemjh\challenge058\challenge058      26     24     12      9    13%   2-3, 6-38
pemjh\challenge059\challenge059      29     22     19     18    17%   6-21, 27-45, 48-49
pemjh\challenge060\challenge060      75     73     37     36     3%   2-3, 7-119
pemjh\challenge061\challenge061      65     59     42     41     7%   4, 7-22, 28-99, 104
pemjh\challenge062\challenge062      23     19      8      5    23%   4-29, 34
pemjh\challenge063\challenge063      18     14      6      3    29%   4-22, 27-28
pemjh\challenge064\challenge064      24     23      8      8     3%   3-39
pemjh\challenge065\challenge065      20     18      8      7    11%   2-3, 6-37
pemjh\challenge066\challenge066      15     14      8      8     4%   5-23
pemjh\challenge067\challenge067      17     13      6      5    22%   5-6, 11-25
pemjh\challenge068\challenge068      48     43     32     31     8%   2-5, 8-21, 24-65, 70
pemjh\challenge069\challenge069      20     18     10      9    10%   2-3, 6-24
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
pemjh\challenge071\challenge071      25     21     12     11    14%   4-27, 32
pemjh\challenge072\challenge072      10      8      4      3    21%   2-3, 7-14
pemjh\challenge073\challenge073      31     28     16     15     9%   4-5, 8-42
pemjh\challenge074\challenge074      33     28     10      9    14%   2-3, 6-23, 26-36, 41
pemjh\challenge075\challenge075      16     15      8      8     4%   3-27
pemjh\challenge076\challenge076      20     16     10      9    17%   2-17, 30-32, 37
pemjh\challenge077\challenge077      20     19     12     10     9%   3-34
pemjh\challenge078\challenge078      20     17     12     11    13%   2-19, 24
pemjh\challenge079\challenge079       8      3      2      1    60%   9, 14-15
pemjh\challenge080\challenge080      26     21     12     11    16%   5-26, 29-34, 39
pemjh\challenge081\challenge081      32     26     13     12    16%   5-17, 20-41, 46
pemjh\challenge082\challenge082      34     27     12     11    17%   7-37, 41-48, 53
pemjh\challenge083\challenge083      45     38     20     19    12%   6-14, 17-25, 29-75, 80
pemjh\challenge084\challenge084      74     67     48     47     7%   4-6, 10-50, 54-66, 69-109, 114
pemjh\challenge085\challenge085      34     30     16     11    18%   3-10, 13-46, 51
pemjh\challenge086\challenge086      32     26     14     11    20%   2, 6-17, 20-25, 28-39, 44
pemjh\challenge087\challenge087      30     28     14     13     7%   2-3, 5-40
pemjh\challenge088\challenge088      24     19     12     11    17%   5-19, 22-31, 36
pemjh\challenge089\challenge089      51     42     26     25    13%   18-31, 35-51, 54-65, 69-79, 83-85, 90
pemjh\challenge090\challenge090      78     68     50     49     9%   5-18, 21-27, 30-33, 36-69, 74-114, 117-127, 132
pemjh\challenge091\challenge091      23     19     20     19    12%   2-30, 33-35, 40
pemjh\challenge092\challenge092      96     94     50     45     5%   2-3, 6-124
pemjh\challenge093\challenge093      67     59     50     49     8%   4-10, 14-24, 27-32, 35-58, 61-97, 102
pemjh\challenge094\challenge094      35     30     12     11    13%   2-7, 11-48, 54
pemjh\challenge095\challenge095      35     30     22     21    11%   3-10, 14-48, 51-56, 61
pemjh\challenge096\challenge096     181    155    116    115     9%   7-14, 22-34, 40-44, 47-59, 62-69, 73-94, 97-105, 108-115, 118-146, 150-155, 158-174, 178-181, 184-221, 224-228, 231-235, 238-241, 244-254, 257-277, 294
pemjh\challenge097\challenge097       6      3      2      1    50%   2, 7-8
pemjh\challenge098\challenge098      62     54     34     33     9%   5-13, 16-23, 26-30, 33-93, 98
pemjh\challenge099\challenge099      17     12      7      6    25%   5-14, 19-20
pemjh\challenge100\challenge100       9      6      4      3    31%   2-6, 11
pemjh\challenge101\challenge101      26     23     18     17     9%   2-38, 43
pemjh\challenge102\challenge102      34     27     14     13    17%   9-31, 35-41, 45-53, 59
pemjh\challenge103\challenge103      40     35     30     29     9%   3-12, 16-34, 37-56, 61
pemjh\challenge104\challenge104      34     33     15     15     2%   3-50
pemjh\challenge105\challenge105      40     32     22     21    15%   5-19, 22-28, 32-47, 51-58, 65
pemjh\challenge106\challenge106      37     30     16     15    15%   2-14, 17-26, 29-46, 49-60, 63, 68
pemjh\challenge107\challenge107      38     31     12     11    16%   6-34, 37-45, 48-65, 70
pemjh\challenge108\challenge108      35     34     16     16     2%   3-59
pemjh\challenge109\challenge109      37     32     18     17    11%   2-19, 23-29, 32-45, 50
pemjh\challenge110\challenge110      35     34     16     16     2%   3-59
pemjh\challenge111\challenge111      38     37     31     31     1%   3-54
pemjh\challenge112\challenge112      32     28     20     17    13%   2-27, 30-43, 48
pemjh\challenge113\challenge113      16     14      6      5    14%   2-3, 6-61
pemjh\challenge114\challenge114      24     19     12     11    17%   2-24, 27-28, 31-32, 37
pemjh\challenge115\challenge115      30     25     14     13    14%   2-25, 28-29, 32-38, 43
pemjh\challenge116\challenge116      24     19     10      9    18%   2-22, 25-28, 31-32, 37
pemjh\challenge117\challenge117      21     16     10      9    19%   2-20, 23-24, 27-28, 33
pemjh\challenge118\challenge118      36     35     14     14     2%   2-52
pemjh\challenge119\challenge119      24     19     10      9    18%   2-7, 12-23, 26-28, 33
pemjh\challenge120\challenge120      10      6      4      3    36%   2-6, 9-10, 15
pemjh\challenge121\challenge121      26     25     10     10     3%   3-39
pemjh\challenge122\challenge122      15     12     12     11    15%   2-23, 28
pemjh\challenge123\challenge123      16     15      6      6     5%   3-20
pemjh\challenge124\challenge124      21     20     14     14     3%   3-41
pemjh\challenge125\challenge125      21     18     12     11    12%   2-24, 29
pemjh\challenge126\challenge126      31     27     24     23     9%   2, 6-36, 41
pemjh\challenge127\challenge127      23     22     15     15     3%   3-35
pemjh\challenge128\challenge128      23     22     10     10     3%   3-33
pemjh\challenge129\challenge129      22     18     10      9    16%   2-8, 11-20, 25-27
pemjh\challenge130\challenge130      21     20      8      8     3%   3-30
pemjh\challenge131\challenge131      22     21     10     10     3%   3-41
pemjh\challenge132\challenge132      16     15      8      8     4%   3-24
pemjh\challenge133\challenge133      10      9      2      2     8%   3-16
pemjh\challenge134\challenge134      42     41     20     20     2%   3-72
pemjh\challenge135\challenge135      15     11     10      9    20%   2-16, 19, 25
pemjh\challenge136\challenge136      19     18     10     10     3%   3-26
pemjh\challenge137\challenge137      16     11      6      5    27%   2-6, 10-17, 20, 25
pemjh\challenge138\challenge138      23     22     14     14     3%   3-34
pemjh\challenge139\challenge139      11     10      6      6     6%   3-19
pemjh\challenge142\challenge142      26     21     18     17    14%   2, 5, 8-34, 39
pemjh\challenge144\challenge144      34     26      6      5    23%   4-5, 9-27, 31-51, 54, 57-67, 72
pemjh\challenge145\challenge145      11      8      4      3    27%   2-10, 15
pemjh\challenge146\challenge146      18     13     14     13    19%   2-6, 9, 17-26, 31
pemjh\challenge148\challenge148      22     17      6      5    21%   2-8, 11-29, 32-34, 39
pemjh\challenge149\challenge149      32     26     12     11    16%   2, 5, 9-27, 30-46, 51
pemjh\challenge151\challenge151      21     17     14     13    14%   2-20, 23, 28
pemjh\challenge162\challenge162       7      3      4      3    45%   2-4, 11
pemjh\challenge164\challenge164      20     16     10      9    17%   3-23, 27-31, 36
pemjh\challenge166\challenge166      40     37     33     32     5%   3-68, 73
pemjh\challenge173\challenge173      21     17      6      5    19%   2-27, 30, 35
pemjh\challenge174\challenge174      27     26     14     14     2%   3-40
pemjh\challenge179\challenge179      18     14      8      7    19%   3-17, 20-21, 26
pemjh\challenge183\challenge183      39     38     12     12     2%   2-56
pemjh\challenge187\challenge187      16     15      8      8     4%   3-22
pemjh\challenge188\challenge188      15     11      6      5    24%   2-10, 13, 18
pemjh\challenge190\challenge190       7      3      6      5    38%   2, 6, 11
pemjh\challenge191\challenge191      48     43     34     33     7%   2-23, 27-70, 73-78, 83
pemjh\challenge197\challenge197      19     15      8      7    19%   2, 5-22, 27
pemjh\challenge203\challenge203      27     26     16     16     2%   3-44
pemjh\challenge204\challenge204      21     20      8      8     3%   3-32
pemjh\challenge205\challenge205      25     20     10      9    17%   2-4, 8-14, 17-27, 32
pemjh\challenge206\challenge206      45     37     16     13    18%   6-10, 13-22, 26-60, 65
pemjh\challenge207\challenge207      20     17      6      5    15%   3-20, 25
pemjh\challenge211\challenge211      46     45     24     24     1%   2-68
pemjh\challenge214\challenge214      45     44     26     26     1%   3-76
pemjh\challenge215\challenge215      45     39     32     31     9%   2-23, 26-29, 32-44, 48-59, 64
pemjh\challenge216\challenge216      67     61     48     47     6%   4-18, 21-44, 47-76, 81
pemjh\challenge220\challenge220      17     13      6      5    22%   2-14, 17, 22
pemjh\challenge225\challenge225      14     11      8      7    18%   4-14, 19
pemjh\challenge230\challenge230      34     30     12     11    11%   2-37, 40-47, 52-53
pemjh\challenge231\challenge231      41     40     14     14     2%   3-72
pemjh\challenge234\challenge234      25     24     10     10     3%   3-44
pemjh\challenge235\challenge235      15     12      8      7    17%   2-14, 19
pemjh\challenge243\challenge243      33     32     20     20     2%   3-49
pemjh\challenge250\challenge250      16     12      8      7    21%   2-18, 21-22, 27
pemjh\challenge259\challenge259      42     32     18     17    18%   4-8, 11, 14, 17, 20, 23-53, 58-63, 66
pemjh\challenge265\challenge265      35     27     10      9    20%   2-9, 13-15, 18, 21-33, 37-47, 50, 55
pemjh\main                           51     33     20     15    32%   7-8, 13-28, 39-57, 63, 66-68
-----------------------------------------------------------------------------
TOTAL                              4961   4273   2571   2370    12%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\python27_64\Lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "E:\software_tools\python\python27_64\Lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\Development\pemjh\.tox\py27\Scripts\py.test.EXE\__main__.py", line 9, in <module>
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
pytest_cov.plugin.CoverageError: Required test coverage of 100% not reached. Total coverage: 11.80%
ERROR: InvocationError: 'D:\\Development\\pemjh\\.tox\\py27\\Scripts\\py.test.EXE --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100'
py27_64 inst-nodeps: D:\Development\pemjh\.tox\dist\pemjh-0.0.1.zip
py27_64 installed: apipkg==1.4,astroid==1.3.8,colorama==0.3.3,coverage==3.7.1,execnet==1.4.1,flake8==2.4.1,logilab-common==1.0.2,mccabe==0.3.1,pemjh==0.0.1,pep8==1.5.7,py==1.4.30,pyflakes==0.8.1,pylint==1.4.4,pytest==2.7.2,pytest-cache==1.0,pytest-cov==2.1.0,pytest-flake8==0.1,pytest-pylint==0.3.0,six==1.9.0,wheel==0.24.0
py27_64 runtests: PYTHONHASHSEED='850'
py27_64 runtests: commands[0] | py.test --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100
============================= test session starts =============================
platform win32 -- Python 2.7.10 -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh, inifile: 
plugins: cache, cov, flake8, pylint
collected 358 items / 65 errors

setup.py FF
pemjh\main.py FF
pemjh\challenge001\challenge001.py FF
pemjh\challenge002\challenge002.py FF
pemjh\challenge003\challenge003.py FF
pemjh\challenge004\challenge004.py FF
pemjh\challenge005\challenge005.py FF
pemjh\challenge006\challenge006.py FF
pemjh\challenge007\challenge007.py FF
pemjh\challenge008\challenge008.py FF
pemjh\challenge009\challenge009.py FF
pemjh\challenge010\challenge010.py FF
pemjh\challenge011\challenge011.py FF
pemjh\challenge012\challenge012.py FF
pemjh\challenge013\challenge013.py FF
pemjh\challenge014\challenge014.py FF
pemjh\challenge015\challenge015.py FF
pemjh\challenge016\challenge016.py FF
pemjh\challenge017\challenge017.py FF
pemjh\challenge018\challenge018.py FF
pemjh\challenge019\challenge019.py FF
pemjh\challenge020\challenge020.py FF
pemjh\challenge021\challenge021.py FF
pemjh\challenge022\challenge022.py FF
pemjh\challenge023\challenge023.py FF
pemjh\challenge024\challenge024.py FF
pemjh\challenge025\challenge025.py FF
pemjh\challenge026\challenge026.py FF
pemjh\challenge027\challenge027.py FF
pemjh\challenge028\challenge028.py FF
pemjh\challenge029\challenge029.py FF
pemjh\challenge030\challenge030.py FF
pemjh\challenge031\challenge031.py FF
pemjh\challenge032\challenge032.py FF
pemjh\challenge033\challenge033.py FF
pemjh\challenge034\challenge034.py FF
pemjh\challenge035\challenge035.py FF
pemjh\challenge036\challenge036.py FF
pemjh\challenge037\challenge037.py FF
pemjh\challenge038\challenge038.py FF
pemjh\challenge039\challenge039.py FF
pemjh\challenge040\challenge040.py FF
pemjh\challenge041\challenge041.py FF
pemjh\challenge042\challenge042.py FF
pemjh\challenge043\challenge043.py FF
pemjh\challenge044\challenge044.py FF
pemjh\challenge045\challenge045.py FF
pemjh\challenge046\challenge046.py FF
pemjh\challenge047\challenge047.py FF
pemjh\challenge048\challenge048.py FF
pemjh\challenge049\challenge049.py FF
pemjh\challenge050\challenge050.py FF
pemjh\challenge051\challenge051.py FF
pemjh\challenge052\challenge052.py FF
pemjh\challenge053\challenge053.py FF
pemjh\challenge054\challenge054.py FF
pemjh\challenge055\challenge055.py FF
pemjh\challenge056\challenge056.py FF
pemjh\challenge057\challenge057.py FF
pemjh\challenge058\challenge058.py FF
pemjh\challenge059\challenge059.py FF
pemjh\challenge060\challenge060.py FF
pemjh\challenge061\challenge061.py FF
pemjh\challenge062\challenge062.py FF
pemjh\challenge063\challenge063.py FF
pemjh\challenge064\challenge064.py FF
pemjh\challenge065\challenge065.py FF
pemjh\challenge066\challenge066.py FF
pemjh\challenge067\challenge067.py FF
pemjh\challenge068\challenge068.py FF
pemjh\challenge069\challenge069.py FF
pemjh\challenge070\challenge070.py FF
pemjh\challenge071\challenge071.py FF
pemjh\challenge072\challenge072.py FF
pemjh\challenge073\challenge073.py FF
pemjh\challenge074\challenge074.py FF
pemjh\challenge075\challenge075.py FF
pemjh\challenge076\challenge076.py FF
pemjh\challenge077\challenge077.py FF
pemjh\challenge078\challenge078.py FF
pemjh\challenge079\challenge079.py FF
pemjh\challenge080\challenge080.py FF
pemjh\challenge081\challenge081.py FF
pemjh\challenge082\challenge082.py FF
pemjh\challenge083\challenge083.py FF
pemjh\challenge084\challenge084.py FF
pemjh\challenge085\challenge085.py FF
pemjh\challenge086\challenge086.py FF
pemjh\challenge087\challenge087.py FF
pemjh\challenge088\challenge088.py FF
pemjh\challenge089\challenge089.py FF
pemjh\challenge090\challenge090.py FF
pemjh\challenge091\challenge091.py FF
pemjh\challenge092\challenge092.py FF
pemjh\challenge093\challenge093.py FF
pemjh\challenge094\challenge094.py FF
pemjh\challenge095\challenge095.py FF
pemjh\challenge096\challenge096.py FF
pemjh\challenge097\challenge097.py FF
pemjh\challenge098\challenge098.py FF
pemjh\challenge099\challenge099.py FF
pemjh\challenge100\challenge100.py Fs
pemjh\challenge101\challenge101.py FF
pemjh\challenge102\challenge102.py FF
pemjh\challenge103\challenge103.py FF
pemjh\challenge104\challenge104.py FF
pemjh\challenge105\challenge105.py FF
pemjh\challenge106\challenge106.py FF
pemjh\challenge107\challenge107.py FF
pemjh\challenge108\challenge108.py FF
pemjh\challenge109\challenge109.py FF
pemjh\challenge110\challenge110.py FF
pemjh\challenge111\challenge111.py FF
pemjh\challenge112\challenge112.py FF
pemjh\challenge113\challenge113.py FF
pemjh\challenge114\challenge114.py FF
pemjh\challenge115\challenge115.py FF
pemjh\challenge116\challenge116.py FF
pemjh\challenge117\challenge117.py FF
pemjh\challenge118\challenge118.py FF
pemjh\challenge119\challenge119.py FF
pemjh\challenge120\challenge120.py FF
pemjh\challenge121\challenge121.py FF
pemjh\challenge122\challenge122.py FF
pemjh\challenge123\challenge123.py FF
pemjh\challenge124\challenge124.py FF
pemjh\challenge125\challenge125.py Fs
pemjh\challenge126\challenge126.py FF
pemjh\challenge127\challenge127.py FF
pemjh\challenge128\challenge128.py FF
pemjh\challenge129\challenge129.py FF
pemjh\challenge130\challenge130.py FF
pemjh\challenge131\challenge131.py FF
pemjh\challenge132\challenge132.py FF
pemjh\challenge133\challenge133.py FF
pemjh\challenge134\challenge134.py FF
pemjh\challenge135\challenge135.py FF
pemjh\challenge136\challenge136.py FF
pemjh\challenge137\challenge137.py FF
pemjh\challenge138\challenge138.py FF
pemjh\challenge139\challenge139.py FF
pemjh\challenge142\challenge142.py FF
pemjh\challenge144\challenge144.py FF
pemjh\challenge145\challenge145.py Fs
pemjh\challenge146\challenge146.py FF
pemjh\challenge148\challenge148.py FF
pemjh\challenge149\challenge149.py FF
pemjh\challenge151\challenge151.py FF
pemjh\challenge162\challenge162.py FF
pemjh\challenge164\challenge164.py FF
pemjh\challenge166\challenge166.py FF
pemjh\challenge173\challenge173.py FF
pemjh\challenge174\challenge174.py FF
pemjh\challenge179\challenge179.py FF
pemjh\challenge183\challenge183.py FF
pemjh\challenge187\challenge187.py FF
pemjh\challenge188\challenge188.py FF
pemjh\challenge190\challenge190.py FF
pemjh\challenge191\challenge191.py FF
pemjh\challenge197\challenge197.py FF
pemjh\challenge203\challenge203.py FF
pemjh\challenge204\challenge204.py FF
pemjh\challenge205\challenge205.py FF
pemjh\challenge206\challenge206.py FF
pemjh\challenge207\challenge207.py Fs
pemjh\challenge211\challenge211.py FF
pemjh\challenge214\challenge214.py FF
pemjh\challenge215\challenge215.py FF
pemjh\challenge216\challenge216.py FF
pemjh\challenge220\challenge220.py FF
pemjh\challenge225\challenge225.py FF
pemjh\challenge230\challenge230.py FF
pemjh\challenge231\challenge231.py FF
pemjh\challenge234\challenge234.py FF
pemjh\challenge235\challenge235.py FF
pemjh\challenge243\challenge243.py FF
pemjh\challenge250\challenge250.py FF
pemjh\challenge259\challenge259.py FF
pemjh\challenge265\challenge265.py FF

=================================== ERRORS ====================================
__________________________ ERROR collecting setup.py __________________________

self = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
func = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
self       = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>, attrname = '_collected'
function = <function <lambda> at 0x000000000400EAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = None
function   = <function <lambda> at 0x000000000400EAC8>
self       = <DoctestModule 'setup.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'setup.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\setup.py'), modname = 'setup'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'setup'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh')
self       = local('D:\\Development\\pemjh\\setup.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    https://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands"""
    
    import os
    import sys
    from setuptools import setup
    from setuptools.command.test import test as TestCommand
    
    def read(fname):
        return open(os.path.join(os.path.dirname(__file__), fname)).read()
    
    class Tox(TestCommand):
        user_options = [('tox-args=', 'a', "Arguments to pass to tox")]
        def initialize_options(self):
            TestCommand.initialize_options(self)
            self.tox_args = None
        def finalize_options(self):
            TestCommand.finalize_options(self)
            self.test_args = []
            self.test_suite = True
        def run_tests(self):
            #import here, cause outside the eggs aren't loaded
            import tox
            import shlex
            args = self.tox_args
            if args:
                args = shlex.split(self.tox_args)
            errno = tox.cmdline(args=args)
            sys.exit(errno)
    
    setup(
        name = "pemjh",
        version = "0.0.1",
        author = "Matthew Hussey",
        author_email = "matthew.hussey@googlemail.com",
        description = ("Project euler (https://projecteuler.net/) challenge "
                       "code in Python."),
        license = "None, private use by myself only",
        keywords = "code challenge euler",
        url = "none.non",
        packages = ["pemjh"],
        long_description = read("README"),
        classifiers=[
            "Development Status :: 1 - Planning"],
        tests_require=['tox'],
>       cmdclass = {"test": Tox},
    )

TestCommand = None
Tox        = None
__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
os         = None
read       = None
setup      = None
sys        = None

setup.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

attrs = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x0000000004536528>}, ...}
klass = <class setuptools.dist.Distribution at 0x00000000044E3C48>
dist = <setuptools.dist.Distribution instance at 0x000000000453F148>
msg = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

    def setup(**attrs):
        """The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
    
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
    
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
    
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.
        """
    
        global _setup_stop_after, _setup_distribution
    
        # Determine the distribution class -- either caller-supplied or
        # our Distribution (see below).
        klass = attrs.get('distclass')
        if klass:
            del attrs['distclass']
        else:
            klass = Distribution
    
        if 'script_name' not in attrs:
            attrs['script_name'] = os.path.basename(sys.argv[0])
        if 'script_args' not in attrs:
            attrs['script_args'] = sys.argv[1:]
    
        # Create the Distribution instance, using the remaining arguments
        # (ie. everything except distclass) to initialize it
        try:
            _setup_distribution = dist = klass(attrs)
        except DistutilsSetupError, msg:
            if 'name' in attrs:
                raise SystemExit, "error in %s setup command: %s" % \
                      (attrs['name'], msg)
            else:
                raise SystemExit, "error in setup command: %s" % msg
    
        if _setup_stop_after == "init":
            return dist
    
        # Find and parse the config file(s): they will override options from
        # the setup script, but be overridden by the command line.
        dist.parse_config_files()
    
        if DEBUG:
            print "options (after parsing config files):"
            dist.dump_option_dicts()
    
        if _setup_stop_after == "config":
            return dist
    
        # Parse the command line and override config files; any
        # command-line errors are the end user's fault, so turn them into
        # SystemExit to suppress tracebacks.
        try:
            ok = dist.parse_command_line()
        except DistutilsArgError, msg:
>           raise SystemExit, gen_usage(dist.script_name) + "\nerror: %s" % msg
E           SystemExit: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
E              or: py.test.EXE --help [cmd1 cmd2 ...]
E              or: py.test.EXE --help-commands
E              or: py.test.EXE cmd --help
E           
E           error: option --pylint not recognized

attrs      = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x0000000004536528>}, ...}
dist       = <setuptools.dist.Distribution instance at 0x000000000453F148>
klass      = <class setuptools.dist.Distribution at 0x00000000044E3C48>
msg        = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

E:\software_tools\python\python27_64\Lib\distutils\core.py:139: SystemExit
_____________ ERROR collecting pemjh/challenge002/challenge002.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045ED898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048C3BC8>)
function   = <function <lambda> at 0x00000000045ED898>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge002\challenge002.py:5: ImportError
_____________ ERROR collecting pemjh/challenge012/challenge012.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048D1C18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047B0708>)
function   = <function <lambda> at 0x00000000048D1C18>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge012\challenge012.py:6: ImportError
_____________ ERROR collecting pemjh/challenge015/challenge015.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048D3C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EBE548>)
function   = <function <lambda> at 0x00000000048D3C88>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge015\challenge015.py:5: ImportError
_____________ ERROR collecting pemjh/challenge018/challenge018.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045CFCF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045F1908>)
function   = <function <lambda> at 0x00000000045CFCF8>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge018\challenge018.py:4: ImportError
_____________ ERROR collecting pemjh/challenge021/challenge021.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045DB278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EAA208>)
function   = <function <lambda> at 0x00000000045DB278>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge021\challenge021.py:5: ImportError
_____________ ERROR collecting pemjh/challenge024/challenge024.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045DB7B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000002E95C48>)
function   = <function <lambda> at 0x00000000045DB7B8>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge024\challenge024.py:5: ImportError
_____________ ERROR collecting pemjh/challenge025/challenge025.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000400EAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004764BC8>)
function   = <function <lambda> at 0x000000000400EAC8>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge025\challenge025.py:4: ImportError
_____________ ERROR collecting pemjh/challenge027/challenge027.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048EB198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045A1688>)
function   = <function <lambda> at 0x00000000048EB198>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge027\challenge027.py:5: ImportError
_____________ ERROR collecting pemjh/challenge032/challenge032.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048EB358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000004770688>)
function   = <function <lambda> at 0x00000000048EB358>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge032\challenge032.py:5: ImportError
_____________ ERROR collecting pemjh/challenge033/challenge033.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048EB748>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003036E48>)
function   = <function <lambda> at 0x00000000048EB748>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import lowestCommonTerms
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge033\challenge033.py:5: ImportError
_____________ ERROR collecting pemjh/challenge034/challenge034.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048EBB38>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004808C08>)
function   = <function <lambda> at 0x00000000048EBB38>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge034\challenge034.py:5: ImportError
_____________ ERROR collecting pemjh/challenge035/challenge035.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002EB7048>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004597408>)
function   = <function <lambda> at 0x0000000002EB7048>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge035\challenge035.py:5: ImportError
_____________ ERROR collecting pemjh/challenge037/challenge037.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002EB70B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047E5E48>)
function   = <function <lambda> at 0x0000000002EB70B8>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge037\challenge037.py:5: ImportError
_____________ ERROR collecting pemjh/challenge041/challenge041.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002EB74A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048C57C8>)
function   = <function <lambda> at 0x0000000002EB74A8>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge041\challenge041.py:5: ImportError
_____________ ERROR collecting pemjh/challenge043/challenge043.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002EB77B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000002EF8A08>)
function   = <function <lambda> at 0x0000000002EB77B8>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge043\challenge043.py:4: ImportError
_____________ ERROR collecting pemjh/challenge046/challenge046.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002EB7C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000030D4BC8>)
function   = <function <lambda> at 0x0000000002EB7C88>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import sqrt
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge046\challenge046.py:6: ImportError
_____________ ERROR collecting pemjh/challenge047/challenge047.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030B54A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004805708>)
function   = <function <lambda> at 0x00000000030B54A8>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
count      = None

pemjh\challenge047\challenge047.py:6: ImportError
_____________ ERROR collecting pemjh/challenge049/challenge049.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030B5438>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000030C8C08>)
function   = <function <lambda> at 0x00000000030B5438>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import string
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
string     = None

pemjh\challenge049\challenge049.py:6: ImportError
_____________ ERROR collecting pemjh/challenge050/challenge050.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030B56D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004591588>)
function   = <function <lambda> at 0x00000000030B56D8>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge050\challenge050.py:4: ImportError
_____________ ERROR collecting pemjh/challenge051/challenge051.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030B5978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003070848>)
function   = <function <lambda> at 0x00000000030B5978>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import cycle
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
cycle      = None

pemjh\challenge051\challenge051.py:6: ImportError
_____________ ERROR collecting pemjh/challenge053/challenge053.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030B5BA8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047D88C8>)
function   = <function <lambda> at 0x00000000030B5BA8>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge053\challenge053.py:4: ImportError
_____________ ERROR collecting pemjh/challenge058/challenge058.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004595128>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004709488>)
function   = <function <lambda> at 0x0000000004595128>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge058\challenge058.py:4: ImportError
_____________ ERROR collecting pemjh/challenge060/challenge060.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004595748>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000498BD48>)
function   = <function <lambda> at 0x0000000004595748>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge060\challenge060.py:5: ImportError
_____________ ERROR collecting pemjh/challenge064/challenge064.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004595C18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A33488>)
function   = <function <lambda> at 0x0000000004595C18>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import continueGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge064\challenge064.py:1: ImportError
_____________ ERROR collecting pemjh/challenge065/challenge065.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000459F2E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046F16C8>)
function   = <function <lambda> at 0x000000000459F2E8>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge065\challenge065.py:4: ImportError
_____________ ERROR collecting pemjh/challenge066/challenge066.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000459F518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EC7148>)
function   = <function <lambda> at 0x000000000459F518>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import rootConvergentGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge066\challenge066.py:1: ImportError
_____________ ERROR collecting pemjh/challenge067/challenge067.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000459F6D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004744848>)
function   = <function <lambda> at 0x000000000459F6D8>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import with_statement
    from os.path import dirname, abspath
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
abspath    = None
dirname    = None
with_statement = None

pemjh\challenge067\challenge067.py:9: ImportError
_____________ ERROR collecting pemjh/challenge069/challenge069.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000459F978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047F5688>)
function   = <function <lambda> at 0x000000000459F978>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge069\challenge069.py:4: ImportError
_____________ ERROR collecting pemjh/challenge070/challenge070.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046F8198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047E09C8>)
function   = <function <lambda> at 0x00000000046F8198>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge070\challenge070.py:4: ImportError
_____________ ERROR collecting pemjh/challenge072/challenge072.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046F8358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047FDC48>)
function   = <function <lambda> at 0x00000000046F8358>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge072\challenge072.py:5: ImportError
_____________ ERROR collecting pemjh/challenge073/challenge073.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046F83C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046D02C8>)
function   = <function <lambda> at 0x00000000046F83C8>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import ceil, floor
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
ceil       = None
floor      = None

pemjh\challenge073\challenge073.py:6: ImportError
_____________ ERROR collecting pemjh/challenge075/challenge075.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046F86D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046F1FC8>)
function   = <function <lambda> at 0x00000000046F86D8>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge075\challenge075.py:1: ImportError
_____________ ERROR collecting pemjh/challenge077/challenge077.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000046F8BA8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046E2F88>)
function   = <function <lambda> at 0x00000000046F8BA8>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge077\challenge077.py:1: ImportError
_____________ ERROR collecting pemjh/challenge087/challenge087.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004613208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EDBC08>)
function   = <function <lambda> at 0x0000000004613208>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge087\challenge087.py:4: ImportError
_____________ ERROR collecting pemjh/challenge092/challenge092.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048D8EB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A8AD08>)
function   = <function <lambda> at 0x00000000048D8EB8>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge092\challenge092.py:4: ImportError
_____________ ERROR collecting pemjh/challenge104/challenge104.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048D8C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A38F48>)
function   = <function <lambda> at 0x00000000048D8C88>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge104\challenge104.py:1: ImportError
_____________ ERROR collecting pemjh/challenge108/challenge108.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047D4CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004639388>)
function   = <function <lambda> at 0x00000000047D4CF8>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge108\challenge108.py:1: ImportError
_____________ ERROR collecting pemjh/challenge110/challenge110.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000468E668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A43EC8>)
function   = <function <lambda> at 0x000000000468E668>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge110\challenge110.py:1: ImportError
_____________ ERROR collecting pemjh/challenge111/challenge111.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000468EBA8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EF2408>)
function   = <function <lambda> at 0x000000000468EBA8>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, roughPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge111\challenge111.py:1: ImportError
_____________ ERROR collecting pemjh/challenge113/challenge113.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004A5BF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002ECA308>)
function   = <function <lambda> at 0x0000000004A5BF28>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import polytopicNumbers
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge113\challenge113.py:4: ImportError
_____________ ERROR collecting pemjh/challenge118/challenge118.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004A5B208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A41C48>)
function   = <function <lambda> at 0x0000000004A5B208>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge118\challenge118.py:1: ImportError
_____________ ERROR collecting pemjh/challenge121/challenge121.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004A5BCF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004904DC8>)
function   = <function <lambda> at 0x0000000004A5BCF8>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge121\challenge121.py:1: ImportError
_____________ ERROR collecting pemjh/challenge123/challenge123.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000475B2E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A3EB48>)
function   = <function <lambda> at 0x000000000475B2E8>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge123\challenge123.py:1: ImportError
_____________ ERROR collecting pemjh/challenge124/challenge124.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000475B3C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000490F1C8>)
function   = <function <lambda> at 0x000000000475B3C8>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge124\challenge124.py:1: ImportError
_____________ ERROR collecting pemjh/challenge127/challenge127.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000475B278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047860C8>)
function   = <function <lambda> at 0x000000000475B278>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import gcd, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge127\challenge127.py:1: ImportError
_____________ ERROR collecting pemjh/challenge128/challenge128.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000475B978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000030C89C8>)
function   = <function <lambda> at 0x000000000475B978>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge128\challenge128.py:1: ImportError
_____________ ERROR collecting pemjh/challenge130/challenge130.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000475BEB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A78848>)
function   = <function <lambda> at 0x000000000475BEB8>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge130\challenge130.py:1: ImportError
_____________ ERROR collecting pemjh/challenge131/challenge131.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047C92E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004CC7BC8>)
function   = <function <lambda> at 0x00000000047C92E8>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge131\challenge131.py:1: ImportError
_____________ ERROR collecting pemjh/challenge132/challenge132.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047C9208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A634C8>)
function   = <function <lambda> at 0x00000000047C9208>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge132\challenge132.py:1: ImportError
_____________ ERROR collecting pemjh/challenge133/challenge133.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047C9198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048347C8>)
function   = <function <lambda> at 0x00000000047C9198>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge133\challenge133.py:1: ImportError
_____________ ERROR collecting pemjh/challenge134/challenge134.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047C9588>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004B40F48>)
function   = <function <lambda> at 0x00000000047C9588>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge134\challenge134.py:1: ImportError
_____________ ERROR collecting pemjh/challenge136/challenge136.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047C9908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000480AB88>)
function   = <function <lambda> at 0x00000000047C9908>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge136\challenge136.py:1: ImportError
_____________ ERROR collecting pemjh/challenge138/challenge138.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004A99F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002ED2788>)
function   = <function <lambda> at 0x0000000004A99F28>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge138\challenge138.py:1: ImportError
_____________ ERROR collecting pemjh/challenge139/challenge139.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004A99278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004ACAD48>)
function   = <function <lambda> at 0x0000000004A99278>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge139\challenge139.py:1: ImportError
_____________ ERROR collecting pemjh/challenge174/challenge174.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004A99128>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004777248>)
function   = <function <lambda> at 0x0000000004A99128>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge174\challenge174.py:1: ImportError
_____________ ERROR collecting pemjh/challenge183/challenge183.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002F32C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004AB86C8>)
function   = <function <lambda> at 0x0000000002F32C88>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge183\challenge183.py:1: ImportError
_____________ ERROR collecting pemjh/challenge187/challenge187.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002F32F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004856208>)
function   = <function <lambda> at 0x0000000002F32F98>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge187\challenge187.py:1: ImportError
_____________ ERROR collecting pemjh/challenge203/challenge203.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004CDF0B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000049D81C8>)
function   = <function <lambda> at 0x0000000004CDF0B8>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge203\challenge203.py:1: ImportError
_____________ ERROR collecting pemjh/challenge204/challenge204.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004CDF908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004D2BE48>)
function   = <function <lambda> at 0x0000000004CDF908>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge204\challenge204.py:1: ImportError
_____________ ERROR collecting pemjh/challenge211/challenge211.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004CDFD68>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004864B08>)
function   = <function <lambda> at 0x0000000004CDFD68>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge211\challenge211.py:1: ImportError
_____________ ERROR collecting pemjh/challenge214/challenge214.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000049203C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000499CB08>)
function   = <function <lambda> at 0x00000000049203C8>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes, primeFactors, phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge214\challenge214.py:1: ImportError
_____________ ERROR collecting pemjh/challenge231/challenge231.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000049204A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004935EC8>)
function   = <function <lambda> at 0x00000000049204A8>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge231\challenge231.py:1: ImportError
_____________ ERROR collecting pemjh/challenge234/challenge234.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004D2DF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048FF308>)
function   = <function <lambda> at 0x0000000004D2DF28>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge234\challenge234.py:1: ImportError
_____________ ERROR collecting pemjh/challenge243/challenge243.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004D2D668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004718188>)
function   = <function <lambda> at 0x0000000004D2D668>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

.tox\py27_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge243\challenge243.py:1: ImportError
================================== FAILURES ===================================
______________________________ [pylint] setup.py ______________________________
C: 36, 0: No space allowed around keyword argument assignment
    name = "pemjh",
         ^ (bad-whitespace)
C: 37, 0: No space allowed around keyword argument assignment
    version = "0.0.1",
            ^ (bad-whitespace)
C: 38, 0: No space allowed around keyword argument assignment
    author = "Matthew Hussey",
           ^ (bad-whitespace)
C: 39, 0: No space allowed around keyword argument assignment
    author_email = "matthew.hussey@googlemail.com",
                 ^ (bad-whitespace)
C: 40, 0: No space allowed around keyword argument assignment
    description = ("Project euler (https://projecteuler.net/) challenge "
                ^ (bad-whitespace)
C: 42, 0: No space allowed around keyword argument assignment
    license = "None, private use by myself only",
            ^ (bad-whitespace)
C: 43, 0: No space allowed around keyword argument assignment
    keywords = "code challenge euler",
             ^ (bad-whitespace)
C: 44, 0: No space allowed around keyword argument assignment
    url = "none.non",
        ^ (bad-whitespace)
C: 45, 0: No space allowed around keyword argument assignment
    packages = ["pemjh"],
             ^ (bad-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
    long_description = read("README"),
                     ^ (bad-whitespace)
C: 50, 0: No space allowed around keyword argument assignment
    cmdclass = {"test": Tox},
             ^ (bad-whitespace)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing class docstring (missing-docstring)
F: 27, 8: Unable to import 'tox' (import-error)
W: 24, 8: Attribute 'test_suite' defined outside __init__ (attribute-defined-outside-init)
W: 23, 8: Attribute 'test_args' defined outside __init__ (attribute-defined-outside-init)
W: 20, 8: Attribute 'tox_args' defined outside __init__ (attribute-defined-outside-init)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\setup.py:6:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\setup.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:18:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:21:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:25:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:26:9: E265 block comment should start with '# '
D:\Development\pemjh\setup.py:36:9: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:36:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:12: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:14: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:13: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:19: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:18: E251 unexpected spaces around keyword / parameter equals

___________________________ [pylint] pemjh/main.py ____________________________
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 58, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  9, 0: No exception type(s) specified (bare-except)
F:  6, 4: Unable to import 'psyco' (import-error)
C: 12, 0: Invalid function name "testFunction" (invalid-name)
C: 12, 0: Invalid argument name "id" (invalid-name)
C: 12, 0: Invalid argument name "knownAnswer" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
W: 12,27: Redefining name 'knownAnswer' from outer scope (line 46) (redefined-outer-name)
W: 12,17: Redefining built-in 'id' (redefined-builtin)
W: 12,21: Redefining name 'func' from outer scope (line 43) (redefined-outer-name)
C: 30, 0: Invalid constant name "wholeTime" (invalid-name)
C: 32, 0: Invalid constant name "failures" (invalid-name)
C: 34, 0: Invalid constant name "nChallenges" (invalid-name)
C: 60, 0: Invalid constant name "wholeTime" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\main.py:13:15: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\main.py:32:18: W291 trailing whitespace
D:\Development\pemjh\pemjh\main.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\main.py:58:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge001/challenge001.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid constant name "upper" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  4,15: Used builtin function 'filter' (bad-builtin)
W:  4,15: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C:  6, 0: Invalid constant name "answer" (invalid-name)
W:  9, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge001\challenge001.py:9:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge002/challenge002.py _________________
C: 10, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "numRange" (invalid-name)
C: 10, 4: Invalid variable name "evenNums" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge003/challenge003.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 19,26: More than one statement on a single line (multiple-statements)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import math (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge003\challenge003.py:1:1: F401 'math' imported but unused
D:\Development\pemjh\pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge003\challenge003.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge004/challenge004.py _________________
C:  8, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 18, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 26, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 18,61: More than one statement on a single line (multiple-statements)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W: 36, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge004\challenge004.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge005/challenge005.py _________________
C: 12, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  3, 4: Redefining built-in 'max' (redefined-builtin)
C:  6, 8: Invalid variable name "n" (invalid-name)
C: 14,16: Invalid variable name "n" (invalid-name)
C: 28,23: More than one statement on a single line (multiple-statements)
C: 31, 8: Invalid variable name "n" (invalid-name)
C: 31,11: Invalid variable name "p" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge005\challenge005.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge006/challenge006.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'max' (redefined-builtin)
W: 10, 4: Redefining built-in 'sum' (redefined-builtin)
C:  4, 4: Invalid variable name "sumOfSquares" (invalid-name)
C:  7, 8: Invalid variable name "sumOfSquares" (invalid-name)
C: 13, 4: Invalid variable name "squareOfSums" (invalid-name)
C: 20, 0: Invalid constant name "answer" (invalid-name)
W: 23, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:23:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge007/challenge007.py _________________
C: 14, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'max' (redefined-builtin)
C: 13, 8: Invalid variable name "primeRange" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
W: 24, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge007\challenge007.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge008/challenge008.py _________________
C: 29, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'input' (redefined-builtin)
C: 26, 8: Invalid variable name "testPart" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
W: 44, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge008\challenge008.py:44:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge009/challenge009.py _________________
C:  8, 0: Exactly one space required after comma
    for a in range(1,(max / 3)):
                    ^ (bad-whitespace)
C: 11, 0: Exactly one space required after comma
        for b in range((a + 1),(a + 1 + (remainder / 2))):
                              ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  4, 4: Redefining built-in 'max' (redefined-builtin)
W:  5, 4: Redefining name 'answer' from outer scope (line 18) (redefined-outer-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C: 11,12: Invalid variable name "b" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge010/challenge010.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  6, 4: Redefining built-in 'max' (redefined-builtin)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ifilter imported from itertools (unused-import)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge010\challenge010.py:1:1: F401 'ifilter' imported but unused
D:\Development\pemjh\pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge010\challenge010.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge011/challenge011.py _________________
C:  2, 0: Line too long (1212/100) (line-too-long)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCols" (invalid-name)
C: 10, 8: Invalid variable name "currentRow" (invalid-name)
C: 12,12: Invalid variable name "nextChunk" (invalid-name)
C: 31,36: More than one statement on a single line (multiple-statements)
C: 38,40: More than one statement on a single line (multiple-statements)
C: 45,40: More than one statement on a single line (multiple-statements)
C: 52,36: More than one statement on a single line (multiple-statements)
W: 11,12: Unused variable 'index' (unused-variable)
R:  1, 0: Too many branches (16/12) (too-many-branches)
C: 58, 0: Invalid constant name "answer" (invalid-name)
W: 61, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:61:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge012/challenge012.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 15, 0: Invalid function name "triangleDivisors" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 16, 4: Invalid variable name "n" (invalid-name)
C: 17, 4: Invalid variable name "nOdd" (invalid-name)
C: 18, 4: Invalid variable name "nEven" (invalid-name)
C: 19, 4: Invalid variable name "knownDivisors" (invalid-name)
C: 24,12: Invalid variable name "nOdd" (invalid-name)
C: 27,12: Invalid variable name "nEven" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36,22: More than one statement on a single line (multiple-statements)
W: 38,12: Using possibly undefined loop variable 'n' (undefined-loop-variable)
W: 38,17: Using possibly undefined loop variable 'n' (undefined-loop-variable)
C: 40, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge013/challenge013.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:111, 0: Invalid constant name "answer" (invalid-name)
W:114, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:114:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge014/challenge014.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getChainSize" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "knownChains" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "knownChains" (invalid-name)
C: 31, 8: Invalid variable name "newChain" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge015/challenge015.py _________________
C:  7, 0: No space allowed around keyword argument assignment
def multiplierGen(n = 0):
                    ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "multiplierGen" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid function name "getRoutes" (invalid-name)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge016/challenge016.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge016\challenge016.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge017/challenge017.py _________________
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 37, 0: Trailing whitespace (trailing-whitespace)
C:103, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumberLength" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "hundredRep" (invalid-name)
C:  1, 0: Invalid argument name "andRep" (invalid-name)
C:  1, 0: Invalid argument name "thousandRep" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "tempN" (invalid-name)
C:  7, 8: Invalid variable name "numberRepresentation" (invalid-name)
C: 13,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 16,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 18,12: Invalid variable name "tempN" (invalid-name)
C: 22,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 29,16: Invalid variable name "tempN" (invalid-name)
C: 31,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 35,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 41, 0: Missing function docstring (missing-docstring)
C: 70, 4: Invalid variable name "knownInts" (invalid-name)
C:100, 4: Invalid variable name "endLine" (invalid-name)
W: 70, 4: Unused variable 'knownInts' (unused-variable)
W:100, 4: Unused variable 'endLine' (unused-variable)
C:106, 0: Invalid constant name "answer" (invalid-name)
W:109, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:5: F841 local variable 'knownInts' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:100:5: F841 local variable 'endLine' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:109:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge018/challenge018.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge018\challenge018.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge019/challenge019.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isLeapYear" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "getYearDays" (invalid-name)
C:  5, 0: Invalid argument name "y" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "getFirstJan" (invalid-name)
C: 11, 0: Invalid argument name "y" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "totalDays" (invalid-name)
C: 14, 8: Invalid variable name "totalDays" (invalid-name)
C: 17, 0: Invalid function name "monthStartDays" (invalid-name)
C: 17, 0: Invalid argument name "y" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "monthLengths" (invalid-name)
C: 25, 8: Invalid variable name "m" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "totalDays" (invalid-name)
C: 34, 8: Invalid variable name "y" (invalid-name)
C: 36,12: Invalid variable name "d" (invalid-name)
C: 38,16: Invalid variable name "totalDays" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
W: 45, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge020/challenge020.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge020\challenge020.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge021/challenge021.py _________________
C: 18, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
W: 11, 4: Redefining built-in 'dict' (redefined-builtin)
C: 12, 8: Invalid variable name "a" (invalid-name)
C: 14, 8: Invalid variable name "b" (invalid-name)
C: 15,12: Invalid variable name "d" (invalid-name)
C: 16,12: Invalid variable name "b" (invalid-name)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'

_________________ [pylint] pemjh/challenge022/challenge022.py _________________
C: 25, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getNames" (invalid-name)
C:  4, 0: Invalid argument name "fp" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7,21: Invalid variable name "f" (invalid-name)
C: 16, 0: Invalid function name "scoredNames" (invalid-name)
C: 16, 0: Invalid argument name "f" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 21,12: Invalid variable name "c" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 29, 8: Invalid variable name "s" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W: 37, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:37:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge023/challenge023.py _________________
C: 10, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "sumOfDivisors" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "p" (invalid-name)
C: 13,12: Invalid variable name "p" (invalid-name)
C: 23, 0: Invalid function name "isSum" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 0: Missing function docstring (missing-docstring)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge024/challenge024.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge024\challenge024.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge025/challenge025.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8,11: Invalid variable name "c" (invalid-name)
C:  9, 8: Invalid variable name "l" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge026/challenge026.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "biggestD" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C: 14,12: Invalid variable name "newSize" (invalid-name)
C: 18,16: Invalid variable name "biggestD" (invalid-name)
C: 20,12: Invalid variable name "newSize" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import string (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge026\challenge026.py:1:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge027/challenge027.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "aMax" (invalid-name)
C: 13, 4: Invalid variable name "bMax" (invalid-name)
C: 16, 4: Invalid variable name "bS" (invalid-name)
C: 17, 8: Invalid variable name "b" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "n" (invalid-name)
C: 21,16: Invalid variable name "f" (invalid-name)
C: 22,35: More than one statement on a single line (multiple-statements)
C: 23,16: Invalid variable name "n" (invalid-name)
C: 27,16: Invalid variable name "aMax" (invalid-name)
C: 28,16: Invalid variable name "bMax" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge027\challenge027.py:6:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge027\challenge027.py:35:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge028/challenge028.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge028\challenge028.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge029/challenge029.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "aLower" (invalid-name)
C:  3, 4: Invalid variable name "aUpper" (invalid-name)
C:  4, 4: Invalid variable name "bLower" (invalid-name)
C:  5, 4: Invalid variable name "bUpper" (invalid-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  9,12: Invalid variable name "b" (invalid-name)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge029\challenge029.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge030/challenge030.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "perDigit" (invalid-name)
C:  7, 4: Invalid variable name "grandTotal" (invalid-name)
C: 11,12: Invalid variable name "c" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "grandTotal" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge030\challenge030.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge031/challenge031.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPatternCount" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid constant name "answer" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
W: 22, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge031\challenge031.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge032/challenge032.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge032\challenge032.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge033/challenge033.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "totalNum" (invalid-name)
C:  9, 4: Invalid variable name "totalDen" (invalid-name)
C: 20,16: Invalid variable name "n1" (invalid-name)
C: 21,16: Invalid variable name "n2" (invalid-name)
C: 22,16: Invalid variable name "d3" (invalid-name)
C: 23,16: Invalid variable name "d4" (invalid-name)
C: 29,24: Invalid variable name "totalNum" (invalid-name)
C: 30,24: Invalid variable name "totalDen" (invalid-name)
C: 37,24: Invalid variable name "totalNum" (invalid-name)
C: 38,24: Invalid variable name "totalDen" (invalid-name)
C: 40, 4: Invalid variable name "totalNum" (invalid-name)
C: 40,14: Invalid variable name "totalDen" (invalid-name)
C: 44, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:47:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge034/challenge034.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "getLimit" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "factSum" (invalid-name)
C:  9, 4: Invalid variable name "factNine" (invalid-name)
C: 13, 8: Invalid variable name "factSum" (invalid-name)
C: 15,29: More than one statement on a single line (multiple-statements)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 8: Invalid variable name "iStr" (invalid-name)
C: 35, 8: Invalid variable name "iTotal" (invalid-name)
C: 36,12: Invalid variable name "c" (invalid-name)
C: 37,12: Invalid variable name "iTotal" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge035/challenge035.py _________________
C: 32, 0: Wrong continued indentation.
              if b == True and
              ^   | (bad-continuation)
C: 33, 0: Wrong continued indentation.
              ((p < 10) or not any(c in str(p) for c in disallowedChars))])
              ^   | (bad-continuation)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "nStr" (invalid-name)
C: 15, 8: Invalid variable name "nextString" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "disallowedChars" (invalid-name)
C: 35, 4: Invalid variable name "circularCount" (invalid-name)
C: 39, 8: Invalid variable name "circularList" (invalid-name)
C: 42, 8: Invalid variable name "allFound" (invalid-name)
C: 48,16: Invalid variable name "allFound" (invalid-name)
C: 51,12: Invalid variable name "circularCount" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sievedPrimes imported from utils.numbers (unused-import)
W:  5, 0: Unused fact imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'fact' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'sievedPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
D:\Development\pemjh\pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge035\challenge035.py:58:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge036/challenge036.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getBinaryString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "binStr" (invalid-name)
C:  5, 8: Invalid variable name "binStr" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 18, 8: Invalid variable name "decStr" (invalid-name)
C: 21,12: Invalid variable name "binStr" (invalid-name)
W: 11, 4: Unused variable 'limit' (unused-variable)
W: 14, 4: Unused variable 'binary' (unused-variable)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W: 29, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge036\challenge036.py:11:5: F841 local variable 'limit' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:14:5: F841 local variable 'binary' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge037/challenge037.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "isTruncPrime" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 12,23: More than one statement on a single line (multiple-statements)
C: 13,45: More than one statement on a single line (multiple-statements)
C: 18,51: More than one statement on a single line (multiple-statements)
C: 23, 0: Missing function docstring (missing-docstring)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge038/challenge038.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "isPandigital" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "m" (invalid-name)
C: 12,11: Invalid variable name "l" (invalid-name)
C: 12,14: Invalid variable name "u" (invalid-name)
C: 13,12: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge038\challenge038.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge039/challenge039.py _________________
W: 18, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
W: 19, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numPerimeters" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "a" (invalid-name)
C: 16, 8: Invalid variable name "bLimit" (invalid-name)
C: 17,12: Invalid variable name "b" (invalid-name)
C: 18,11: Invalid variable name "c" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "highestVal" (invalid-name)
C: 30, 8: Invalid variable name "iCount" (invalid-name)
C: 33,12: Invalid variable name "highestVal" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge039\challenge039.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge040/challenge040.py _________________
C: 11, 0: No space allowed before bracket
        total *= int (str(currentValue)[index - currentN - 1])
                     ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "currentN" (invalid-name)
C:  5, 4: Invalid variable name "currentValue" (invalid-name)
C:  9,12: Invalid variable name "currentValue" (invalid-name)
C: 10,12: Invalid variable name "currentN" (invalid-name)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
D:\Development\pemjh\pemjh\challenge040\challenge040.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge041/challenge041.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
F:  6, 0: Unable to import 'utils.strings' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 15,36: More than one statement on a single line (multiple-statements)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge041\challenge041.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge042/challenge042.py _________________
C: 35, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "scoreWord" (invalid-name)
C:  4, 0: Invalid argument name "w" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "x" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12,62: Invalid variable name "f" (invalid-name)
C: 23, 8: Invalid variable name "nTriangleWords" (invalid-name)
C: 30,16: Invalid variable name "nTriangleWords" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge042\challenge042.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge043/challenge043.py _________________
C:  8, 0: Trailing whitespace (trailing-whitespace)
W: 19, 0: Bad indentation. Found 12 spaces, expected 8 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.strings' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge044/challenge044.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "isPent" (invalid-name)
C:  6, 0: Invalid argument name "p" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "n" (invalid-name)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "pk" (invalid-name)
C: 19, 8: Invalid variable name "performedOneStep" (invalid-name)
C: 20,12: Invalid variable name "pj" (invalid-name)
C: 21,12: Invalid variable name "diffPkPj" (invalid-name)
C: 22,45: More than one statement on a single line (multiple-statements)
C: 25,12: Invalid variable name "performedOneStep" (invalid-name)
C: 27,33: More than one statement on a single line (multiple-statements)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge044\challenge044.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge045/challenge045.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
W:  4, 0: Redefining built-in 'hex' (redefined-builtin)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "pentAndHex" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "p" (invalid-name)
C: 10, 4: Invalid variable name "h" (invalid-name)
C: 12, 8: Invalid variable name "pVal" (invalid-name)
C: 13, 8: Invalid variable name "hVal" (invalid-name)
C: 19,12: Invalid variable name "p" (invalid-name)
C: 21,12: Invalid variable name "h" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 26, 8: Redefining built-in 'next' (redefined-builtin)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge046/challenge046.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "hasCriteria" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "dSq" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "n" (invalid-name)
C: 25, 8: Invalid variable name "n" (invalid-name)
C: 26,36: More than one statement on a single line (multiple-statements)
C: 26,36: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge046\challenge046.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge047/challenge047.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "numPrimeFactors" (invalid-name)
C:  8, 0: Invalid argument name "nPrimes" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "n" (invalid-name)
C: 11, 8: Invalid variable name "pf" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Invalid function name "hasNumPrimes" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 20,30: More than one statement on a single line (multiple-statements)
C: 24, 0: Missing function docstring (missing-docstring)
W: 30, 4: Redefining name 'count' from outer scope (line 1) (redefined-outer-name)
C: 31, 8: Invalid variable name "p" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused count imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
D:\Development\pemjh\pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge048/challenge048.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid constant name "answer" (invalid-name)
W:  8, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge048\challenge048.py:8:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge049/challenge049.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 18, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 21,12: Invalid variable name "p1" (invalid-name)
C: 22,16: Invalid variable name "p2" (invalid-name)
C: 24,16: Invalid variable name "p3" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge049\challenge049.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge050/challenge050.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
W: 13, 4: Redefining name 'answer' from outer scope (line 26) (redefined-outer-name)
C:  9, 4: Invalid variable name "knownPrimes" (invalid-name)
C: 11, 4: Invalid variable name "nPrimes" (invalid-name)
C: 18,31: More than one statement on a single line (multiple-statements)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge050\challenge050.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge050\challenge050.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge051/challenge051.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "substitutePrimes" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid function name "has3SameDigits" (invalid-name)
C: 24, 0: Invalid argument name "n" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "w" (invalid-name)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
C: 39,12: Invalid variable name "w" (invalid-name)
C: 41,16: Invalid variable name "nPrimes" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge052/challenge052.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getSortedString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "x" (invalid-name)
C:  9, 8: Invalid variable name "x" (invalid-name)
C: 10, 8: Invalid variable name "xStr" (invalid-name)
C: 15,12: Invalid variable name "ix" (invalid-name)
C: 16,12: Invalid variable name "ixStr" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge053/challenge053.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge053\challenge053.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge054/challenge054.py _________________
C:122, 0: Trailing whitespace (trailing-whitespace)
C:131, 0: Trailing whitespace (trailing-whitespace)
C:133, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getDuplicateCounts" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "valCounts" (invalid-name)
C: 14, 0: Invalid function name "isStraight" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid function name "isFlush" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid function name "scoreHand" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 52, 8: Invalid variable name "c1" (invalid-name)
C: 52,12: Invalid variable name "c2" (invalid-name)
C: 53, 8: Invalid variable name "v1" (invalid-name)
C: 53,12: Invalid variable name "v2" (invalid-name)
R: 26, 0: Too many return statements (11/6) (too-many-return-statements)
R: 26, 0: Too many branches (15/12) (too-many-branches)
C: 96, 0: Invalid function name "compareHands" (invalid-name)
C: 96, 0: Invalid argument name "handOne" (invalid-name)
C: 96, 0: Invalid argument name "handTwo" (invalid-name)
C: 96, 0: Missing function docstring (missing-docstring)
C:100, 4: Invalid variable name "handOneScore" (invalid-name)
C:100,18: Invalid variable name "handTwoScore" (invalid-name)
C:106,12: Invalid variable name "c1" (invalid-name)
C:106,16: Invalid variable name "c2" (invalid-name)
C:114, 0: Missing function docstring (missing-docstring)
C:115, 4: Invalid variable name "faceConvert" (invalid-name)
C:118, 4: Invalid variable name "nHandOneWins" (invalid-name)
C:119,62: Invalid variable name "f" (invalid-name)
C:120,12: Invalid variable name "l" (invalid-name)
C:129,16: Invalid variable name "nHandOneWins" (invalid-name)
C:133, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace

_________________ [pylint] pemjh/challenge055/challenge055.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "becomesPalindrome" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "workingN" (invalid-name)
C:  6, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
D:\Development\pemjh\pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge055\challenge055.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge056/challenge056.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "a" (invalid-name)
C:  4,12: Invalid variable name "b" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
W: 16, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge056\challenge056.py:16:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge057/challenge057.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTopHeavy" (invalid-name)
C:  5, 8: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  8,15: Invalid variable name "d" (invalid-name)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 10,11: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nTopHeavy" (invalid-name)
W:  7,12: Unused variable 'i' (unused-variable)
C: 17, 0: Invalid constant name "answer" (invalid-name)
W: 20, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge057\challenge057.py:20:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge058/challenge058.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nPrimes" (invalid-name)
C: 13, 4: Invalid variable name "primeChecker" (invalid-name)
C: 22,16: Invalid variable name "nPrimes" (invalid-name)
W: 18,12: Unused variable 'j' (unused-variable)
W:  9, 4: Unused variable 'total' (unused-variable)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
D:\Development\pemjh\pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge059/challenge059.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 27,64: Invalid variable name "f" (invalid-name)
C: 29,12: Invalid variable name "l" (invalid-name)
W: 48, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge060/challenge060.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 64, 0: Line too long (118/100) (line-too-long)
C: 69, 0: Trailing whitespace (trailing-whitespace)
C: 85, 0: Line too long (141/100) (line-too-long)
C: 94, 0: Trailing whitespace (trailing-whitespace)
C: 95, 0: Trailing whitespace (trailing-whitespace)
C: 97, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid constant name "primeSet" (invalid-name)
C:  8, 0: Invalid constant name "maxPrime" (invalid-name)
C: 10, 0: Invalid function name "getNumLength" (invalid-name)
C: 10, 0: Invalid argument name "n" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 14, 8: Invalid variable name "l" (invalid-name)
C: 17, 0: Invalid argument name "m" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "isConcatPrime" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "newFirst" (invalid-name)
C: 25, 4: Invalid variable name "newLast" (invalid-name)
C: 29, 0: Invalid function name "getPrimePairs" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "nPrimes" (invalid-name)
C: 33, 8: Invalid variable name "m" (invalid-name)
C: 34, 8: Invalid variable name "p" (invalid-name)
C: 38,12: Invalid variable name "n" (invalid-name)
C: 39,12: Invalid variable name "q" (invalid-name)
C: 47, 0: Invalid function name "nextDigits" (invalid-name)
C: 47, 0: Invalid argument name "nToFind" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "currentSum" (invalid-name)
C: 49, 4: Invalid variable name "currentSolution" (invalid-name)
C: 50, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 61,16: Invalid variable name "foundSolution" (invalid-name)
C: 64,16: Invalid variable name "foundSolution" (invalid-name)
C: 67,16: Invalid variable name "currentSolution" (invalid-name)
C: 68,16: Invalid variable name "currentSolutionSum" (invalid-name)
C: 71, 0: Invalid function name "nextDigitsDict" (invalid-name)
C: 71, 0: Invalid argument name "nToFind" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 72, 4: Invalid variable name "currentSum" (invalid-name)
C: 73, 4: Invalid variable name "currentSolution" (invalid-name)
C: 74, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 77, 8: Invalid variable name "p" (invalid-name)
C: 83,12: Invalid variable name "foundSolution" (invalid-name)
C: 86,12: Invalid variable name "newPotential" (invalid-name)
C: 87,12: Invalid variable name "foundSolution" (invalid-name)
C: 92,12: Invalid variable name "currentSolution" (invalid-name)
C: 93,12: Invalid variable name "currentSolutionSum" (invalid-name)
C: 98, 0: Missing function docstring (missing-docstring)
W:109, 4: Redefining name 'answer' from outer scope (line 116) (redefined-outer-name)
C:116, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace

_________________ [pylint] pemjh/challenge061/challenge061.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "hasDuplicates" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "eachInList" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 17,12: Invalid variable name "newNums" (invalid-name)
C: 18,12: Invalid variable name "newLists" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
W: 51, 4: Redefining built-in 'oct' (redefined-builtin)
W: 55, 4: Redefining built-in 'all' (redefined-builtin)
W: 43, 4: Redefining built-in 'hex' (redefined-builtin)
R: 24, 0: Too many local variables (27/15) (too-many-locals)
C: 28, 4: Invalid variable name "allLists" (invalid-name)
C: 35, 4: Invalid variable name "sq" (invalid-name)
C: 56, 4: Invalid variable name "d" (invalid-name)
C: 57, 8: Invalid variable name "n" (invalid-name)
C: 64, 8: Invalid variable name "n" (invalid-name)
C: 70,16: Invalid variable name "l" (invalid-name)
C: 76, 8: Invalid variable name "n1" (invalid-name)
C: 79,12: Invalid variable name "n2" (invalid-name)
C: 82,16: Invalid variable name "n3" (invalid-name)
C: 85,20: Invalid variable name "n4" (invalid-name)
C: 88,24: Invalid variable name "n5" (invalid-name)
C: 91,28: Invalid variable name "n6" (invalid-name)
C: 94,32: Invalid variable name "n7" (invalid-name)
R: 24, 0: Too many branches (17/12) (too-many-branches)
C:101, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'

_________________ [pylint] pemjh/challenge062/challenge062.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "n" (invalid-name)
C:  8, 8: Invalid variable name "potentialAnswer" (invalid-name)
C: 19,20: Invalid variable name "nCubes" (invalid-name)
C: 21,12: Invalid variable name "nCubes" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge063/challenge063.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14,26: More than one statement on a single line (multiple-statements)
C: 20,29: More than one statement on a single line (multiple-statements)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge064/challenge064.py _________________
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getPeriodLength" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "pathGen" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 4: Invalid variable name "nOdd" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 32,12: Invalid variable name "nOdd" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge065/challenge065.py _________________
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "nextDen" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused divisors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge065\challenge065.py:4:1: F401 'divisors' imported but unused
D:\Development\pemjh\pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge066/challenge066.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "diophantineX" (invalid-name)
C:  8, 0: Invalid argument name "d" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "x" (invalid-name)
C: 10,11: Invalid variable name "y" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)

_________________ [pylint] pemjh/challenge067/challenge067.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  9, 0: Unable to import 'utils.numbers' (import-error)
C: 11, 0: Missing function docstring (missing-docstring)
W: 14,65: Redefining built-in 'file' (redefined-builtin)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge067\challenge067.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge068/challenge068.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPairs" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "getSpokes" (invalid-name)
C:  7, 0: Invalid argument name "startIndex" (invalid-name)
C:  7, 0: Invalid argument name "nSpokes" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 18,16: Invalid variable name "nextSpokes" (invalid-name)
C: 19,16: Invalid variable name "y" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 54,20: Unused variable 'move' (unused-variable)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)

_________________ [pylint] pemjh/challenge069/challenge069.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "sp" (invalid-name)
C: 11, 4: Invalid variable name "nPhi" (invalid-name)
C: 12,11: Invalid variable name "n" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge070/challenge070.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "isPermutation" (invalid-name)
C:  8, 0: Invalid argument name "a" (invalid-name)
C:  8, 0: Invalid argument name "b" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 17,11: Invalid variable name "p" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused import string (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge071/challenge071.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "targetNum" (invalid-name)
C:  5, 4: Invalid variable name "targetDen" (invalid-name)
C:  8, 4: Invalid variable name "bestNum" (invalid-name)
C:  9, 4: Invalid variable name "bestDen" (invalid-name)
C: 13, 8: Invalid variable name "highNum" (invalid-name)
C: 14, 8: Invalid variable name "lowNum" (invalid-name)
C: 18,55: More than one statement on a single line (multiple-statements)
C: 20,12: Invalid variable name "leftSide" (invalid-name)
C: 21,12: Invalid variable name "rightSide" (invalid-name)
C: 23,16: Invalid variable name "bestNum" (invalid-name)
C: 23,25: Invalid variable name "bestDen" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge072/challenge072.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge073/challenge073.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "shareDivisors" (invalid-name)
C:  8, 0: Invalid argument name "n1" (invalid-name)
C:  8, 0: Invalid argument name "n2" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "d" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "upperNum" (invalid-name)
C: 19, 4: Invalid variable name "upperDen" (invalid-name)
C: 20, 4: Invalid variable name "lowerNum" (invalid-name)
C: 21, 4: Invalid variable name "lowerDen" (invalid-name)
C: 25, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 26, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 28, 8: Invalid variable name "upperLimit" (invalid-name)
C: 29, 8: Invalid variable name "upperLimit" (invalid-name)
C: 31, 8: Invalid variable name "rangeLimits" (invalid-name)
W: 31, 8: Unused variable 'rangeLimits' (unused-variable)
C: 39, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:31:9: F841 local variable 'rangeLimits' is assigned to but never used

_________________ [pylint] pemjh/challenge074/challenge074.py _________________
C:  2, 0: Line too long (109/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "factSum" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "chainSize" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "w" (invalid-name)
C:  8, 4: Invalid variable name "firstW" (invalid-name)
C:  9, 4: Invalid variable name "routeLen" (invalid-name)
C: 17,12: Invalid variable name "routeLen" (invalid-name)
C: 19,12: Invalid variable name "w" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 27, 4: Unused variable 'target' (unused-variable)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
D:\Development\pemjh\pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:27:5: F841 local variable 'target' is assigned to but never used

_________________ [pylint] pemjh/challenge075/challenge075.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "l" (invalid-name)
C:  8,15: Invalid variable name "a" (invalid-name)
C:  8,18: Invalid variable name "b" (invalid-name)
C:  8,21: Invalid variable name "c" (invalid-name)
C: 21, 4: Invalid variable name "l" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge076/challenge076.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numBreakDowns" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  9, 8: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nBreakDowns" (invalid-name)
C: 12,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 14,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge077/challenge077.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "pc" (invalid-name)
C: 17,12: Invalid variable name "a" (invalid-name)
C: 18,12: Invalid variable name "b" (invalid-name)
C: 21,16: Invalid variable name "abSums" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)

_________________ [pylint] pemjh/challenge078/challenge078.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
W:  6, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W:  7, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W: 15, 0: Found indentation with tabs instead of spaces (mixed-indentation)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "n" (invalid-name)
C:  3, 4: Invalid variable name "p" (invalid-name)
C:  6, 7: Invalid variable name "s" (invalid-name)
C: 10,16: Invalid variable name "s" (invalid-name)
C: 13,16: Invalid variable name "s" (invalid-name)
C: 17, 8: Invalid variable name "m" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge079/challenge079.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
W:  2, 0: Unused import string (unused-import)
W: 14, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge079\challenge079.py:2:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge079\challenge079.py:14:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge080/challenge080.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "buildRoot" (invalid-name)
C:  3, 0: Invalid argument name "sq" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W: 14, 4: Redefining name 'answer' from outer scope (line 36) (redefined-outer-name)
W: 18, 8: Redefining built-in 'next' (redefined-builtin)
C:  5, 4: Invalid function name "getNextNum" (invalid-name)
C:  5, 4: Missing function docstring (missing-docstring)
W:  5,19: Unused argument 'target' (unused-argument)
C: 13, 4: Invalid variable name "prevNum" (invalid-name)
C: 24, 8: Invalid variable name "prevNum" (invalid-name)
W: 16, 8: Unused variable 'i' (unused-variable)
C: 28, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge081/challenge081.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "addRows" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "r1" (invalid-name)
C:  7, 8: Invalid variable name "r2" (invalid-name)
C: 10,12: Invalid variable name "i1" (invalid-name)
C: 11,12: Invalid variable name "i2" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 21,63: Invalid variable name "f" (invalid-name)
C: 22, 8: Invalid variable name "tr" (invalid-name)
C: 26,12: Invalid variable name "n" (invalid-name)
C: 26,15: Invalid variable name "l" (invalid-name)
W: 28,26: Using possibly undefined loop variable 'i' (undefined-loop-variable)
C: 39, 4: Invalid variable name "tr" (invalid-name)
C: 43, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge082/challenge082.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "combineColumns" (invalid-name)
C:  5, 0: Invalid argument name "c1" (invalid-name)
C:  5, 0: Invalid argument name "c2" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "downRow" (invalid-name)
C: 11, 8: Invalid variable name "v1" (invalid-name)
C: 11,12: Invalid variable name "v2" (invalid-name)
C: 23, 4: Invalid variable name "newRow" (invalid-name)
C: 26, 8: Invalid variable name "v1" (invalid-name)
C: 26,12: Invalid variable name "v2" (invalid-name)
C: 39, 0: Missing function docstring (missing-docstring)
C: 42,23: Invalid variable name "f" (invalid-name)
W: 44,16: Used builtin function 'map' (bad-builtin)
W: 48,26: Lambda may not be necessary (unnecessary-lambda)
C: 50, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused izip imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge082\challenge082.py:3:1: F401 'izip' imported but unused
D:\Development\pemjh\pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge083/challenge083.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getGrid" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6,63: Invalid variable name "f" (invalid-name)
C:  9,12: Invalid variable name "nextLine" (invalid-name)
C: 16, 0: Invalid function name "compareToProcess" (invalid-name)
C: 16, 0: Invalid argument name "m" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 27, 0: Missing function docstring (missing-docstring)
W: 35,11: Used builtin function 'map' (bad-builtin)
W: 35,11: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 35,27: Used builtin function 'map' (bad-builtin)
W: 35,27: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C: 38, 4: Invalid variable name "toProcess" (invalid-name)
C: 45, 8: Invalid variable name "x" (invalid-name)
C: 45,11: Invalid variable name "y" (invalid-name)
C: 55,12: Invalid variable name "nx" (invalid-name)
C: 55,16: Invalid variable name "ny" (invalid-name)
C: 56,12: Invalid variable name "newSquare" (invalid-name)
C: 59,12: Invalid variable name "newLength" (invalid-name)
W: 40, 4: Unused variable 'processed' (unused-variable)
C: 77, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge083\challenge083.py:40:5: F841 local variable 'processed' is assigned to but never used
D:\Development\pemjh\pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'

_________________ [pylint] pemjh/challenge084/challenge084.py _________________
C:  8, 0: No space allowed around keyword argument assignment
def chanceCardMove(current, prev = [0]):
                                 ^ (bad-whitespace)
C: 52, 0: No space allowed around keyword argument assignment
def communityChestCardMove(current, prev = [0]):
                                         ^ (bad-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C: 77, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:100, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "rollDice" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  8, 0: Dangerous default value [] as argument (dangerous-default-value)
C:  8, 0: Invalid function name "chanceCardMove" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
R:  8, 0: Too many return statements (13/6) (too-many-return-statements)
R:  8, 0: Too many branches (14/12) (too-many-branches)
W: 52, 0: Dangerous default value [] as argument (dangerous-default-value)
C: 52, 0: Invalid function name "communityChestCardMove" (invalid-name)
C: 52, 0: Missing function docstring (missing-docstring)
C: 68, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "doubleCount" (invalid-name)
C: 85,12: Invalid variable name "doubleCount" (invalid-name)
C: 87,12: Invalid variable name "doubleCount" (invalid-name)
C: 94,12: Invalid variable name "doubleCount" (invalid-name)
C:111, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace

_________________ [pylint] pemjh/challenge085/challenge085.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numRects" (invalid-name)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Invalid argument name "w" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "rh" (invalid-name)
C:  5,12: Invalid variable name "rw" (invalid-name)
C:  6,12: Invalid variable name "numAcross" (invalid-name)
C:  7,12: Invalid variable name "numDown" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 32,16: Invalid variable name "areaRectangles" (invalid-name)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge086/challenge086.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def isInt(a, msq, sqLib, found = list()):
                               ^ (bad-whitespace)
C:  2, 0: Unnecessary parens after 'return' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value list() (__builtin__.list) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "isInt" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "sqLib" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  1,25: Unused argument 'found' (unused-argument)
C:  4, 0: Invalid function name "getNumPairs" (invalid-name)
C:  4, 0: Invalid argument name "pairSum" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nPairs" (invalid-name)
C:  8, 4: Invalid variable name "a" (invalid-name)
C:  9, 4: Invalid variable name "b" (invalid-name)
C: 11, 8: Invalid variable name "a" (invalid-name)
C: 12, 8: Invalid variable name "b" (invalid-name)
C: 16,12: Invalid variable name "nPairs" (invalid-name)
C: 19, 0: Invalid function name "getStepSize" (invalid-name)
C: 19, 0: Invalid argument name "m" (invalid-name)
C: 19, 0: Invalid argument name "sqLib" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "nStep" (invalid-name)
W: 25, 4: Unreachable code (unreachable)
C: 27, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "sqLimit" (invalid-name)
C: 33, 4: Invalid variable name "m" (invalid-name)
C: 36, 8: Invalid variable name "m" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge087/challenge087.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sqLimit" (invalid-name)
C: 13, 4: Invalid variable name "sqPrimes" (invalid-name)
C: 16, 4: Invalid variable name "cuLimit" (invalid-name)
C: 17, 4: Invalid variable name "cuPrimes" (invalid-name)
C: 20, 4: Invalid variable name "foLimit" (invalid-name)
C: 21, 4: Invalid variable name "foPrimes" (invalid-name)
C: 23, 4: Invalid variable name "nAnswers" (invalid-name)
C: 24, 8: Invalid variable name "s" (invalid-name)
C: 25,12: Invalid variable name "c" (invalid-name)
C: 26,12: Invalid variable name "sc" (invalid-name)
C: 29,16: Invalid variable name "f" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge087\challenge087.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge088/challenge088.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def findPossibleProducts(limit, known = dict()):
                                      ^ (bad-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "findPossibleProducts" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12,20: Invalid variable name "s" (invalid-name)
C: 12,23: Invalid variable name "d" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 25, 8: Invalid variable name "pr" (invalid-name)
C: 25,12: Invalid variable name "s" (invalid-name)
C: 25,15: Invalid variable name "d" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ceil imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge088\challenge088.py:1:1: F401 'ceil' imported but unused
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace

_________________ [pylint] pemjh/challenge089/challenge089.py _________________
C: 56, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C: 17, 0: Invalid function name "convertChar" (invalid-name)
C: 17, 0: Invalid argument name "c" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
R: 17, 0: Too many return statements (7/6) (too-many-return-statements)
C: 33, 0: Invalid function name "decypherNumeral" (invalid-name)
C: 33, 0: Invalid argument name "s" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "currentTotal" (invalid-name)
C: 38, 8: Invalid variable name "v" (invalid-name)
C: 41,12: Invalid variable name "currentTotal" (invalid-name)
C: 43,12: Invalid variable name "currentTotal" (invalid-name)
C: 46,12: Invalid variable name "currentTotal" (invalid-name)
C: 53, 0: Invalid function name "getNumeral" (invalid-name)
C: 53, 0: Invalid argument name "n" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 61,13: Invalid variable name "c" (invalid-name)
C: 62, 8: Invalid variable name "nDiv" (invalid-name)
C: 67, 0: Invalid function name "getRomanNumeralSaving" (invalid-name)
C: 67, 0: Invalid argument name "s" (invalid-name)
C: 67, 0: Missing function docstring (missing-docstring)
C: 69, 4: Invalid variable name "preLength" (invalid-name)
C: 75, 4: Invalid variable name "newNumeral" (invalid-name)
C: 76, 4: Invalid variable name "newLength" (invalid-name)
C: 81, 0: Missing function docstring (missing-docstring)
C: 83,62: Invalid variable name "f" (invalid-name)
C: 87, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
D:\Development\pemjh\pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge090/challenge090.py _________________
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 78, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "get6Combs" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "c6" (invalid-name)
C: 10, 8: Invalid variable name "i6" (invalid-name)
C: 15, 8: Invalid variable name "i6" (invalid-name)
C: 20, 0: Invalid function name "fillRemaining" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid function name "validAddition" (invalid-name)
C: 29, 0: Invalid argument name "newFace" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 35, 0: Invalid function name "amendCubesForSquare" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "newCube1" (invalid-name)
C: 56, 8: Invalid variable name "newCube0" (invalid-name)
C: 62, 4: Invalid variable name "newCube0" (invalid-name)
C: 63, 4: Invalid variable name "newCube1" (invalid-name)
C: 71, 0: Invalid function name "buildCubes" (invalid-name)
C: 71, 0: Invalid argument name "squaresLeft" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nextSquare" (invalid-name)
C: 77, 4: Invalid variable name "suitableCubes" (invalid-name)
C:109,16: Invalid variable name "c0" (invalid-name)
C:110,20: Invalid variable name "c1" (invalid-name)
R: 71, 0: Too many branches (13/12) (too-many-branches)
C:116, 0: Missing function docstring (missing-docstring)
C:117, 4: Invalid variable name "squareNumbers" (invalid-name)
C:119, 4: Invalid variable name "possibleNumbers" (invalid-name)
C:125, 8: Invalid variable name "c" (invalid-name)
W:119, 4: Unused variable 'possibleNumbers' (unused-variable)
W:125, 8: Unused variable 'c' (unused-variable)
C:129, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:119:5: F841 local variable 'possibleNumbers' is assigned to but never used

_________________ [pylint] pemjh/challenge091/challenge091.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "bruteForce" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTriangles" (invalid-name)
C:  5, 8: Invalid variable name "x1" (invalid-name)
C:  6,12: Invalid variable name "y1" (invalid-name)
C:  9,16: Invalid variable name "nTriangles" (invalid-name)
C: 12,16: Invalid variable name "nTriangles" (invalid-name)
C: 15,20: Invalid variable name "x2" (invalid-name)
C: 16,24: Invalid variable name "y2" (invalid-name)
C: 29,32: Invalid variable name "nTriangles" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "gridSize" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge092/challenge092.py _________________
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 87, 0: Trailing whitespace (trailing-whitespace)
C:112, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Invalid function name "getDigits" (invalid-name)
C:  6, 0: Invalid argument name "n" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "workingN" (invalid-name)
C: 11, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 20, 8: Invalid variable name "workingN" (invalid-name)
C: 29,20: Invalid variable name "d" (invalid-name)
C: 31,16: Invalid variable name "workingN" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "n" (invalid-name)
C: 41, 8: Invalid variable name "workingN" (invalid-name)
C: 45,12: Invalid variable name "workingN" (invalid-name)
C: 46,19: Invalid variable name "c" (invalid-name)
C: 52,12: Invalid variable name "workingN" (invalid-name)
W: 42, 8: Unused variable 'route' (unused-variable)
C: 58, 0: Invalid function name "buildNumber" (invalid-name)
C: 58, 0: Missing function docstring (missing-docstring)
C: 61, 0: Missing function docstring (missing-docstring)
C: 73, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "prevI" (invalid-name)
C: 75, 4: Invalid variable name "nI" (invalid-name)
C: 80,12: Invalid variable name "nI" (invalid-name)
C: 83,12: Invalid variable name "prevI" (invalid-name)
C: 84,12: Invalid variable name "nI" (invalid-name)
C: 90, 0: Invalid function name "squareVal" (invalid-name)
C: 90, 0: Missing function docstring (missing-docstring)
C: 91, 4: Invalid variable name "n" (invalid-name)
C: 96, 8: Invalid variable name "n" (invalid-name)
C:100, 0: Missing function docstring (missing-docstring)
C:101, 4: Invalid variable name "n" (invalid-name)
C:108,12: Invalid variable name "n" (invalid-name)
C:110, 0: Missing function docstring (missing-docstring)
C:111, 4: Invalid variable name "nDigits" (invalid-name)
C:120, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:42:9: F841 local variable 'route' is assigned to but never used
D:\Development\pemjh\pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:123:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge093/challenge093.py _________________
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 96, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nLeft" (invalid-name)
C: 12, 0: Invalid argument name "a" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "op" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid argument name "l" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "v" (invalid-name)
C: 34, 0: Invalid function name "equatedNumbers" (invalid-name)
C: 34, 0: Invalid argument name "a" (invalid-name)
C: 34, 0: Invalid argument name "b" (invalid-name)
C: 34, 0: Invalid argument name "c" (invalid-name)
C: 34, 0: Invalid argument name "d" (invalid-name)
C: 34, 0: Missing function docstring (missing-docstring)
W: 40, 8: No exception type(s) specified (bare-except)
C: 39,13: More than one statement on a single line (multiple-statements)
C: 40,16: More than one statement on a single line (multiple-statements)
W: 44, 8: No exception type(s) specified (bare-except)
C: 43,13: More than one statement on a single line (multiple-statements)
C: 44,16: More than one statement on a single line (multiple-statements)
W: 48, 8: No exception type(s) specified (bare-except)
C: 47,13: More than one statement on a single line (multiple-statements)
C: 48,16: More than one statement on a single line (multiple-statements)
W: 52, 8: No exception type(s) specified (bare-except)
C: 51,13: More than one statement on a single line (multiple-statements)
C: 52,16: More than one statement on a single line (multiple-statements)
W: 56, 8: No exception type(s) specified (bare-except)
C: 55,13: More than one statement on a single line (multiple-statements)
C: 56,16: More than one statement on a single line (multiple-statements)
C: 60, 0: Missing function docstring (missing-docstring)
C: 68, 8: Invalid variable name "a" (invalid-name)
C: 69,12: Invalid variable name "b" (invalid-name)
C: 70,16: Invalid variable name "c" (invalid-name)
C: 71,20: Invalid variable name "d" (invalid-name)
C: 77,28: Invalid variable name "n" (invalid-name)
W: 90,19: Using possibly undefined loop variable 'd' (undefined-loop-variable)
W: 92,15: Using possibly undefined loop variable 'c' (undefined-loop-variable)
W: 94,11: Using possibly undefined loop variable 'b' (undefined-loop-variable)
C: 99, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge094/challenge094.py _________________
C: 11, 0: Exactly one space required after comma
    prev_2 = (4,  0)
               ^ (bad-whitespace)
C: 12, 0: Exactly one space required after comma
    prev_1 = (15,  1)
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "n" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
W: 38,12: Redefining built-in 'long' (redefined-builtin)
C: 31, 8: Invalid variable name "c" (invalid-name)
C: 33, 8: Invalid variable name "rt" (invalid-name)
C: 50, 0: Invalid constant name "desc" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge095/challenge095.py _________________
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 47, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid function name "chainLengths" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "x" (invalid-name)
C: 38,12: Invalid variable name "lChain" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge096/challenge096.py _________________
C:104, 0: Trailing whitespace (trailing-whitespace)
C:120, 0: Line too long (150/100) (line-too-long)
C:228, 0: Trailing whitespace (trailing-whitespace)
C:240, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  6, 0: Invalid function name "sortSquareLengths" (invalid-name)
C:  6, 0: Invalid argument name "a" (invalid-name)
C:  6, 0: Invalid argument name "b" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "la" (invalid-name)
C:  8, 4: Invalid variable name "lb" (invalid-name)
C: 16, 0: Missing class docstring (missing-docstring)
C: 16, 0: Old-style class defined. (old-style-class)
C: 20, 4: Invalid argument name "s" (invalid-name)
W: 23,50: Unused variable 'i' (unused-variable)
C: 36, 4: Invalid method name "__loadData" (invalid-name)
C: 36, 4: Invalid argument name "s" (invalid-name)
C: 36, 4: Missing method docstring (missing-docstring)
C: 40,12: Invalid variable name "r" (invalid-name)
C: 42,16: Invalid variable name "c" (invalid-name)
C: 46, 4: Invalid method name "__getBox" (invalid-name)
C: 46, 4: Invalid argument name "r" (invalid-name)
C: 46, 4: Invalid argument name "c" (invalid-name)
C: 46, 4: Missing method docstring (missing-docstring)
C: 47, 8: Invalid function name "getStartIndex" (invalid-name)
C: 47, 8: Missing function docstring (missing-docstring)
C: 55, 8: Invalid variable name "rowStart" (invalid-name)
C: 57,12: Invalid variable name "columnStart" (invalid-name)
C: 61, 4: Invalid method name "__removeValueFromList" (invalid-name)
C: 61, 4: Invalid argument name "l" (invalid-name)
C: 61, 4: Missing method docstring (missing-docstring)
C: 62, 8: Invalid variable name "nRemoved" (invalid-name)
C: 64,12: Invalid variable name "sq" (invalid-name)
C: 66,16: Invalid variable name "nRemoved" (invalid-name)
R: 61, 4: Method could be a function (no-self-use)
C: 71, 4: Invalid method name "__setValue" (invalid-name)
C: 71, 4: Invalid argument name "r" (invalid-name)
C: 71, 4: Invalid argument name "c" (invalid-name)
C: 71, 4: Missing method docstring (missing-docstring)
C: 85, 8: Invalid variable name "sq" (invalid-name)
C: 96, 4: Invalid method name "__getAllBlocks" (invalid-name)
C: 96, 4: Missing method docstring (missing-docstring)
C:100,12: Invalid variable name "r" (invalid-name)
C:101,16: Invalid variable name "c" (invalid-name)
C:107, 4: Invalid method name "__processCompletedSquares" (invalid-name)
C:107, 4: Missing method docstring (missing-docstring)
C:110,12: Invalid variable name "r" (invalid-name)
C:111,16: Invalid variable name "sq" (invalid-name)
C:117, 4: Invalid method name "__processGroups" (invalid-name)
C:117, 4: Missing method docstring (missing-docstring)
C:124,16: Invalid variable name "sq" (invalid-name)
C:131,24: Invalid variable name "lSq" (invalid-name)
C:137,28: Invalid variable name "nRemoved" (invalid-name)
C:148, 4: Invalid method name "__getLocation" (invalid-name)
C:148, 4: Invalid argument name "sq" (invalid-name)
C:148, 4: Missing method docstring (missing-docstring)
C:150,12: Invalid variable name "r" (invalid-name)
C:151,16: Invalid variable name "c" (invalid-name)
C:157, 4: Invalid method name "__processOnlyInOneSquare" (invalid-name)
C:157, 4: Missing method docstring (missing-docstring)
C:176, 4: Missing method docstring (missing-docstring)
C:178,12: Invalid variable name "sRow" (invalid-name)
C:178,18: Invalid variable name "tRow" (invalid-name)
W:178,30: Access to a protected member __rows of a client class (protected-access)
C:179,16: Invalid variable name "sSquare" (invalid-name)
C:179,25: Invalid variable name "tSquare" (invalid-name)
C:183, 4: Missing method docstring (missing-docstring)
C:184, 8: Invalid variable name "progressMade" (invalid-name)
C:187,12: Invalid variable name "progressMade" (invalid-name)
C:189,12: Invalid variable name "progressMade" (invalid-name)
C:191,12: Invalid variable name "progressMade" (invalid-name)
C:195,12: Invalid variable name "unsolvedSquares" (invalid-name)
C:196,16: Invalid variable name "r" (invalid-name)
C:197,20: Invalid variable name "c" (invalid-name)
C:205,16: Invalid variable name "sq" (invalid-name)
W:211,20: Access to a protected member __setValue of a client class (protected-access)
W:214,24: Access to a protected member __solve of a client class (protected-access)
C:223, 4: Missing method docstring (missing-docstring)
C:224,12: Invalid variable name "r" (invalid-name)
C:225,16: Invalid variable name "sq" (invalid-name)
C:230, 4: Missing method docstring (missing-docstring)
C:231,12: Invalid variable name "r" (invalid-name)
C:232,16: Invalid variable name "sq" (invalid-name)
W:244, 8: Redefining built-in 'repr' (redefined-builtin)
C:245,12: Invalid variable name "r" (invalid-name)
C:247,16: Invalid variable name "sq" (invalid-name)
C:249,16: Invalid variable name "f1" (invalid-name)
C:250,16: Invalid variable name "f2" (invalid-name)
C:256, 0: Missing function docstring (missing-docstring)
W:267,12: Redefining built-in 'input' (redefined-builtin)
C:257,63: Invalid variable name "f" (invalid-name)
C:260, 8: Invalid variable name "nBroken" (invalid-name)
C:273,16: Invalid variable name "nBroken" (invalid-name)
W:263,12: Unused variable 'i' (unused-variable)
W:267,46: Unused variable 'j' (unused-variable)
W:260, 8: Unused variable 'nBroken' (unused-variable)
C:279, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge096\challenge096.py:3:1: F401 'sys' imported but unused
D:\Development\pemjh\pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge097/challenge097.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid constant name "answer" (invalid-name)
W:  7, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge097\challenge097.py:7:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge098/challenge098.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getMap" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'map' (redefined-builtin)
C:  6, 8: Invalid variable name "w" (invalid-name)
C:  6,11: Invalid variable name "s" (invalid-name)
C: 15, 0: Invalid function name "uniqueRight" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
W: 15,16: Redefining built-in 'map' (redefined-builtin)
C: 25, 0: Invalid function name "mapWord" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 25,18: Redefining built-in 'map' (redefined-builtin)
C: 27, 8: Invalid variable name "c" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
W: 81,16: Redefining built-in 'map' (redefined-builtin)
R: 32, 0: Too many local variables (19/15) (too-many-locals)
C: 35, 4: Invalid variable name "groupedWords" (invalid-name)
C: 37,62: Invalid variable name "f" (invalid-name)
C: 40,16: Invalid variable name "orderedWord" (invalid-name)
C: 46, 4: Invalid variable name "groupedWords" (invalid-name)
C: 70, 8: Invalid variable name "nWords" (invalid-name)
C: 75,12: Invalid variable name "lWord" (invalid-name)
C: 78,16: Invalid variable name "potentialSquare" (invalid-name)
C: 87,24: Invalid variable name "word2Square" (invalid-name)
C: 95, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)

_________________ [pylint] pemjh/challenge099/challenge099.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5,65: Invalid variable name "f" (invalid-name)
C:  6, 8: Invalid variable name "highestIndex" (invalid-name)
C:  7, 8: Invalid variable name "highestNumber" (invalid-name)
C:  8, 8: Invalid variable name "highestLine" (invalid-name)
C:  9,12: Invalid variable name "nL" (invalid-name)
C:  9,16: Invalid variable name "l" (invalid-name)
C: 10,12: Invalid variable name "n" (invalid-name)
C: 11,12: Invalid variable name "rootedPower" (invalid-name)
C: 13,16: Invalid variable name "highestNumber" (invalid-name)
C: 13,31: Invalid variable name "highestIndex" (invalid-name)
C: 13,45: Invalid variable name "highestLine" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
W: 19, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge099\challenge099.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge100/challenge100.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "b" (invalid-name)
C:  3, 4: Invalid variable name "n" (invalid-name)
C:  5, 8: Invalid variable name "b" (invalid-name)
C:  5,11: Invalid variable name "n" (invalid-name)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge101/challenge101.py _________________
C:  5, 0: Line too long (123/100) (line-too-long)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "highestPower" (invalid-name)
C: 14, 8: Invalid variable name "workedSequence" (invalid-name)
C: 16,12: Invalid variable name "x" (invalid-name)
C: 17,12: Invalid variable name "y" (invalid-name)
C: 28,16: Invalid variable name "y" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
D:\Development\pemjh\pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge102/challenge102.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "enclosesOrigin" (invalid-name)
C:  4, 0: Invalid argument name "x1" (invalid-name)
C:  4, 0: Invalid argument name "y1" (invalid-name)
C:  4, 0: Invalid argument name "x2" (invalid-name)
C:  4, 0: Invalid argument name "y2" (invalid-name)
C:  4, 0: Invalid argument name "x3" (invalid-name)
C:  4, 0: Invalid argument name "y3" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
R:  4, 0: Too many arguments (6/5) (too-many-arguments)
C: 17,12: Invalid variable name "i1" (invalid-name)
C: 18,12: Invalid variable name "i2" (invalid-name)
C: 21,12: Invalid variable name "i1" (invalid-name)
C: 22,12: Invalid variable name "i2" (invalid-name)
C: 25,12: Invalid variable name "i1" (invalid-name)
C: 26,12: Invalid variable name "i2" (invalid-name)
C: 33, 0: Invalid function name "getYIntercept" (invalid-name)
C: 33, 0: Invalid argument name "x1" (invalid-name)
C: 33, 0: Invalid argument name "y1" (invalid-name)
C: 33, 0: Invalid argument name "x2" (invalid-name)
C: 33, 0: Invalid argument name "y2" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "m" (invalid-name)
C: 38, 4: Invalid variable name "c" (invalid-name)
C: 43, 0: Missing function docstring (missing-docstring)
C: 46, 4: Invalid variable name "nEnclosing" (invalid-name)
C: 47,23: Invalid variable name "f" (invalid-name)
C: 48,12: Invalid variable name "l" (invalid-name)
C: 49,12: Invalid variable name "ax" (invalid-name)
C: 49,16: Invalid variable name "ay" (invalid-name)
C: 49,20: Invalid variable name "bx" (invalid-name)
C: 49,24: Invalid variable name "by" (invalid-name)
C: 49,28: Invalid variable name "cx" (invalid-name)
C: 49,32: Invalid variable name "cy" (invalid-name)
C: 51,16: Invalid variable name "nEnclosing" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge103/challenge103.py _________________
C: 41, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "subSets" (invalid-name)
C:  1, 0: Invalid argument name "l" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "setA" (invalid-name)
C:  5, 8: Invalid variable name "setB" (invalid-name)
C: 14, 0: Invalid argument name "l" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "B" (invalid-name)
C: 16,11: Invalid variable name "CPart" (invalid-name)
C: 19,16: Invalid variable name "C" (invalid-name)
C: 19,19: Invalid variable name "notUsed" (invalid-name)
C: 23,24: Invalid variable name "wB" (invalid-name)
C: 23,28: Invalid variable name "wC" (invalid-name)
C: 25,24: Invalid variable name "wB" (invalid-name)
C: 25,28: Invalid variable name "wC" (invalid-name)
W: 19,19: Unused variable 'notUsed' (unused-variable)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "midPoint" (invalid-name)
C: 48, 4: Invalid variable name "sumAns" (invalid-name)
C: 49, 8: Invalid variable name "b" (invalid-name)
C: 50, 8: Invalid variable name "newSet" (invalid-name)
C: 54,16: Invalid variable name "sumAns" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge104/challenge104.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "myEnumerate" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Invalid function name "fiboTrunc" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "aStart" (invalid-name)
C: 10,12: Invalid variable name "bStart" (invalid-name)
C: 11, 4: Invalid variable name "aEnd" (invalid-name)
C: 11,10: Invalid variable name "bEnd" (invalid-name)
C: 13, 4: Invalid variable name "endTrunc" (invalid-name)
C: 14, 4: Invalid variable name "startTrunc" (invalid-name)
C: 18, 8: Invalid variable name "aStart" (invalid-name)
C: 18,16: Invalid variable name "bStart" (invalid-name)
C: 19, 8: Invalid variable name "aEnd" (invalid-name)
C: 19,14: Invalid variable name "bEnd" (invalid-name)
C: 22, 8: Invalid variable name "aEnd" (invalid-name)
C: 23, 8: Invalid variable name "bEnd" (invalid-name)
C: 26,12: Invalid variable name "aStart" (invalid-name)
C: 27,12: Invalid variable name "bStart" (invalid-name)
C: 29, 8: Invalid variable name "aStartRet" (invalid-name)
C: 31,12: Invalid variable name "aStartRet" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "lowerLimit" (invalid-name)
C: 38,11: Invalid variable name "f" (invalid-name)
C: 39, 8: Invalid variable name "s" (invalid-name)
C: 40, 8: Invalid variable name "e" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused fibo imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge104\challenge104.py:1:1: F401 'fibo' imported but unused
D:\Development\pemjh\pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge105/challenge105.py _________________
C: 61, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "sizedSubsets" (invalid-name)
C:  4, 0: Invalid argument name "l" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "sizeL" (invalid-name)
C: 21, 0: Invalid function name "checkForDuplicateSetSums" (invalid-name)
C: 21, 0: Invalid argument name "l" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 22, 8: Invalid variable name "setSize" (invalid-name)
C: 23, 8: Invalid variable name "sumSub" (invalid-name)
C: 30, 0: Invalid argument name "l" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "nItems" (invalid-name)
C: 49, 0: Missing function docstring (missing-docstring)
C: 51,61: Invalid variable name "f" (invalid-name)
C: 60, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge106/challenge106.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "incrementTrilist" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "rightIndex" (invalid-name)
C: 16, 0: Invalid function name "allSubsets" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17, 4: Invalid variable name "triList" (invalid-name)
C: 28, 0: Invalid argument name "l" (invalid-name)
C: 28, 0: Missing function docstring (missing-docstring)
C: 48, 0: Invalid function name "getRequiredCompares" (invalid-name)
C: 48, 0: Missing function docstring (missing-docstring)
C: 49, 4: Invalid variable name "allS" (invalid-name)
C: 52, 4: Invalid variable name "workingS" (invalid-name)
C: 55, 4: Invalid variable name "workingS" (invalid-name)
C: 58, 4: Invalid variable name "workingS" (invalid-name)
C: 62, 0: Missing function docstring (missing-docstring)
C: 65, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge107/challenge107.py _________________
C: 22, 0: Line too long (102/100) (line-too-long)
C: 25, 0: Line too long (139/100) (line-too-long)
C: 25, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "skimNetwork" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "connectedRows" (invalid-name)
C:  7, 4: Invalid variable name "availableConnections" (invalid-name)
C: 22, 8: Invalid variable name "availableConnections" (invalid-name)
C: 30, 4: Invalid variable name "newGrid" (invalid-name)
W: 30,35: Unused variable 'row' (unused-variable)
C: 36, 0: Invalid function name "scoreGrid" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "r" (invalid-name)
C: 41,12: Invalid variable name "v" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 50,64: Invalid variable name "f" (invalid-name)
C: 56, 4: Invalid variable name "originalScore" (invalid-name)
C: 59, 4: Invalid variable name "newGrid" (invalid-name)
C: 62, 4: Invalid variable name "newScore" (invalid-name)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)

_________________ [pylint] pemjh/challenge108/challenge108.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge109/challenge109.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def getNonDoubleOuts(n, darts, nums, known = dict()):
                                           ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "getNonDoubleOuts" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nCount" (invalid-name)
C:  7, 8: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "nCount" (invalid-name)
C: 21, 0: Invalid function name "getDoubleOuts" (invalid-name)
C: 21, 0: Invalid argument name "n" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "nCount" (invalid-name)
C: 24,14: Invalid variable name "d" (invalid-name)
C: 26,12: Invalid variable name "nCount" (invalid-name)
C: 28,12: Invalid variable name "nCount" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "nCount" (invalid-name)
C: 43, 8: Invalid variable name "nCount" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge110/challenge110.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge111/challenge111.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def isPrime(p, pc = PrimeChecker()):
                  ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "isPrime" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "pc" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid function name "buildNums" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17,16: Invalid variable name "b" (invalid-name)
C: 24,16: Invalid variable name "b" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "M" (invalid-name)
C: 31, 4: Invalid variable name "N" (invalid-name)
C: 32, 4: Invalid variable name "S" (invalid-name)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36, 8: Invalid variable name "s" (invalid-name)
C: 38,12: Invalid variable name "m" (invalid-name)
C: 40,20: Invalid variable name "b" (invalid-name)
C: 44,28: Invalid variable name "n" (invalid-name)
C: 45,28: Invalid variable name "s" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused roughPrimes imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge111\challenge111.py:1:1: F401 'roughPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge112/challenge112.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isBouncy" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  6,11: Invalid variable name "nextM" (invalid-name)
C:  9,12: Invalid variable name "nextMovement" (invalid-name)
C: 11,12: Invalid variable name "nextMovement" (invalid-name)
C: 13,12: Invalid variable name "nextMovement" (invalid-name)
C: 15, 8: Invalid variable name "m" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "currentBouncy" (invalid-name)
C: 32, 4: Invalid variable name "currentNumber" (invalid-name)
C: 36,12: Invalid variable name "currentBouncy" (invalid-name)
C: 39,54: More than one statement on a single line (multiple-statements)
C: 41, 8: Invalid variable name "currentNumber" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge113/challenge113.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 21, 8: Invalid variable name "d" (invalid-name)
C: 22, 8: Invalid variable name "p" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge114/challenge114.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 14,16: Invalid variable name "nVariations" (invalid-name)
C: 17, 8: Invalid variable name "nVariations" (invalid-name)
C: 20, 8: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 4: Invalid variable name "n" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge115/challenge115.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, minimum, tileSizes, known = dict()):
                                                    ^ (bad-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 15,12: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 21, 8: Invalid variable name "nVariations" (invalid-name)
C: 27, 0: Invalid function name "f" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "b" (invalid-name)
C: 38, 8: Invalid variable name "b" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge116/challenge116.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                        ^ (bad-whitespace)
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                                      ^ (bad-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSize" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  9,12: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 15, 8: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "n2" (invalid-name)
C: 26, 4: Invalid variable name "n3" (invalid-name)
C: 27, 4: Invalid variable name "n4" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge117/challenge117.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 10,16: Invalid variable name "nVariations" (invalid-name)
C: 13, 8: Invalid variable name "nVariations" (invalid-name)
C: 16, 8: Invalid variable name "nVariations" (invalid-name)
C: 22, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "n" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge118/challenge118.py _________________
C: 10, 0: No space allowed around keyword argument assignment
def build_sets(existing, left, lExist = 0):
                                      ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 0: Invalid argument name "lExist" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "lLeft" (invalid-name)
C: 16, 8: Invalid variable name "lNew" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
W: 37,12: Used builtin function 'map' (bad-builtin)
C: 45, 0: Missing function docstring (missing-docstring)
C: 49, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge119/challenge119.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "sumDigits" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "w" (invalid-name)
C:  5, 8: Invalid variable name "w" (invalid-name)
C:  5,11: Invalid variable name "m" (invalid-name)
C:  9, 0: Invalid function name "an" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 16,12: Invalid variable name "p" (invalid-name)
C: 18,12: Invalid variable name "s" (invalid-name)
W: 16,12: Unused variable 'p' (unused-variable)
C: 25, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge120/challenge120.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "highestMod" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge121/challenge121.py _________________
C: 21, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "winChance" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "lossesAllowed" (invalid-name)
C: 22, 8: Invalid variable name "lossesAllowed" (invalid-name)
C: 27, 8: Invalid variable name "wc" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge122/challenge122.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12,16: Invalid variable name "f" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge123/challenge123.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getRemainder" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 11, 8: Invalid variable name "r" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 17, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge124/challenge124.py _________________
C:  5, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] > b[1]))):
        ^   | (bad-continuation)
C: 12, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] < b[1]))):
        ^   | (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 8: Invalid variable name "p" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge125/challenge125.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "rtLimit" (invalid-name)
C:  8, 8: Invalid variable name "rtLimit" (invalid-name)
C:  9, 4: Invalid variable name "rtLimit" (invalid-name)
C: 13, 8: Invalid variable name "sq" (invalid-name)
C: 15,12: Invalid variable name "sq" (invalid-name)
C: 26, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge126/challenge126.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 16, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 20, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 24, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 29, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "surroundingCubes" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Invalid argument name "z" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "maximumResult" (invalid-name)
C: 10, 4: Invalid variable name "maximumDepth" (invalid-name)
C: 12, 8: Invalid variable name "maximumDepth" (invalid-name)
C: 15, 8: Invalid variable name "maximumA" (invalid-name)
C: 17,12: Invalid variable name "maximumA" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "maximumB" (invalid-name)
C: 21,16: Invalid variable name "maximumB" (invalid-name)
C: 22,16: Invalid variable name "b" (invalid-name)
C: 23,16: Invalid variable name "maximumC" (invalid-name)
C: 25,20: Invalid variable name "maximumC" (invalid-name)
C: 26,20: Invalid variable name "c" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)

_________________ [pylint] pemjh/challenge127/challenge127.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 20,12: Redefining built-in 'next' (redefined-builtin)
C: 19, 8: Invalid variable name "c" (invalid-name)
C: 21,12: Invalid variable name "a" (invalid-name)
C: 24,12: Invalid variable name "b" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','

_________________ [pylint] pemjh/challenge128/challenge128.py _________________
C: 23, 0: Line too long (103/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "nPrimes" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)

_________________ [pylint] pemjh/challenge129/challenge129.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "A" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "n" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16,12: Invalid variable name "an" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
F: 25, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge130/challenge130.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "A" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
F: 28, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge131/challenge131.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "p" (invalid-name)
C: 18, 8: Invalid variable name "lowerCube" (invalid-name)
C: 19, 8: Invalid variable name "upperCube" (invalid-name)
C: 25,16: Invalid variable name "lowerCube" (invalid-name)
C: 30,16: Invalid variable name "upperCube" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge132/challenge132.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "R" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 13,33: More than one statement on a single line (multiple-statements)
C: 17, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge133/challenge133.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)

_________________ [pylint] pemjh/challenge134/challenge134.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "jumpSize" (invalid-name)
C:  3, 0: Invalid argument name "t" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "cInd" (invalid-name)
C: 21, 4: Invalid variable name "tInd" (invalid-name)
C: 29, 0: Invalid function name "f" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "s" (invalid-name)
C: 33, 4: Invalid variable name "c" (invalid-name)
C: 35, 4: Invalid variable name "t" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 51, 8: Invalid variable name "r" (invalid-name)
C: 54, 4: Invalid variable name "p1" (invalid-name)
C: 55, 4: Invalid variable name "S" (invalid-name)
C: 56, 8: Invalid variable name "p2" (invalid-name)
C: 61, 8: Invalid variable name "n" (invalid-name)
C: 63, 8: Invalid variable name "S" (invalid-name)
C: 65, 8: Invalid variable name "p1" (invalid-name)
W: 51, 8: Unused variable 'r' (unused-variable)
C: 68, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge135/challenge135.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumTarget" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "x" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "n" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge136/challenge136.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getNumTarget" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "p" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge137/challenge137.py _________________
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  8, 0: No space allowed around keyword argument assignment
def a(n, known = {0: 0, 1: 2, 2: 15}):
               ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining name 'a' from outer scope (line 8) (redefined-outer-name)
C:  2, 4: Invalid variable name "a" (invalid-name)
C:  2, 7: Invalid variable name "b" (invalid-name)
C:  4, 8: Invalid variable name "x" (invalid-name)
C:  6, 8: Invalid variable name "a" (invalid-name)
C:  6,11: Invalid variable name "b" (invalid-name)
W:  4, 8: Unused variable 'x' (unused-variable)
W:  8, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  8, 0: Invalid function name "a" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 19, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge138/challenge138.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 15, 8: Redefining built-in 'next' (redefined-builtin)
C:  4, 4: Invalid variable name "b1" (invalid-name)
C:  5, 4: Invalid variable name "b2" (invalid-name)
C: 17, 8: Invalid variable name "v" (invalid-name)
C: 21,12: Invalid variable name "v" (invalid-name)
C: 27,23: More than one statement on a single line (multiple-statements)
W:  7, 8: Unused variable 'i' (unused-variable)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)

_________________ [pylint] pemjh/challenge139/challenge139.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge142/challenge142.py _________________
C: 32, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "perfectSquare" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "a" (invalid-name)
C:  4, 0: Invalid argument name "b" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)

_________________ [pylint] pemjh/challenge144/challenge144.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "solveQuadratic" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "sqPart" (invalid-name)
C:  7, 0: Invalid argument name "x" (invalid-name)
C:  7, 0: Invalid argument name "y" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "impGrad" (invalid-name)
C: 12, 4: Invalid variable name "impAngle" (invalid-name)
C: 15, 4: Invalid variable name "inAngle" (invalid-name)
C: 18, 4: Invalid variable name "diffAngle" (invalid-name)
C: 21, 4: Invalid variable name "newAngle" (invalid-name)
C: 24, 4: Invalid variable name "newGradient" (invalid-name)
C: 29, 0: Invalid function name "nextStep" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "m" (invalid-name)
C: 34, 4: Invalid variable name "c" (invalid-name)
C: 41, 4: Invalid variable name "x1" (invalid-name)
C: 41, 8: Invalid variable name "x2" (invalid-name)
C: 45, 8: Invalid variable name "xImpact" (invalid-name)
C: 47, 8: Invalid variable name "xImpact" (invalid-name)
C: 49, 4: Invalid variable name "yImpact" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 56, 0: Missing function docstring (missing-docstring)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge145/challenge145.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "d" (invalid-name)
C:  8, 4: Invalid variable name "sevenDigits" (invalid-name)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge146/challenge146.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def is_pseudo_prime(n, known = {1: True, 2: True}):
                             ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "ns" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent

_________________ [pylint] pemjh/challenge148/challenge148.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 31, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge149/challenge149.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid argument name "l" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 29, 0: Missing function docstring (missing-docstring)
W: 35,13: Used builtin function 'map' (bad-builtin)
W: 44,13: Used builtin function 'map' (bad-builtin)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge151/challenge151.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a5" (invalid-name)
C:  1, 0: Invalid argument name "a4" (invalid-name)
C:  1, 0: Invalid argument name "a3" (invalid-name)
C:  1, 0: Invalid argument name "a2" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge162/challenge162.py _________________
C:  2, 0: Line too long (103/100) (line-too-long)
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid constant name "answer" (invalid-name)
C:  8, 0: Invalid constant name "desc" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge164/challenge164.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(size, previousThree, useZero, known = dict()):
                                                  ^ (bad-whitespace)
C: 15, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "useZero" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nLosses" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge166/challenge166.py _________________
C: 60, 0: Line too long (102/100) (line-too-long)
C: 65, 0: Line too long (114/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sq" (invalid-name)
R:  1, 0: Too many branches (14/12) (too-many-branches)
C: 70, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)

_________________ [pylint] pemjh/challenge173/challenge173.py _________________
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numOfSquares" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nSquares" (invalid-name)
C:  3, 4: Invalid variable name "holeWidth" (invalid-name)
C:  6, 8: Invalid variable name "holeArea" (invalid-name)
C: 12, 8: Invalid variable name "surroundingWidth" (invalid-name)
C: 16,12: Invalid variable name "totalArea" (invalid-name)
C: 19,12: Invalid variable name "surroundingArea" (invalid-name)
C: 24,12: Invalid variable name "surroundingWidth" (invalid-name)
C: 25,12: Invalid variable name "nSquares" (invalid-name)
C: 27, 8: Invalid variable name "holeWidth" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge174/challenge174.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def getDivisors(n, known = dict()):
                         ^ (bad-whitespace)
C: 11, 0: No space allowed around keyword argument assignment
def getNumEvenDivisors(n, known = dict()):
                                ^ (bad-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "getDivisors" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "d" (invalid-name)
W: 11, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 11, 0: Invalid function name "getNumEvenDivisors" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 4: Invalid variable name "nDiv" (invalid-name)
C: 20,12: Invalid variable name "nDiv" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nSquares" (invalid-name)
C: 31, 4: Invalid variable name "nMatches" (invalid-name)
C: 32, 8: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "nMatches" (invalid-name)
W: 33,24: Used builtin function 'filter' (bad-builtin)
W: 33,24: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 33,46: Cell variable n defined in loop (cell-var-from-loop)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge179/challenge179.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nSame" (invalid-name)
C:  8,12: Invalid variable name "a" (invalid-name)
C: 13,12: Invalid variable name "nSame" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge183/challenge183.py _________________
C:  4, 0: No space allowed around keyword argument assignment
def pf(n, known = dict()):
                ^ (bad-whitespace)
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 12, 0: No space allowed around keyword argument assignment
def factPower(b, f, known = dict()):
                          ^ (bad-whitespace)
C: 30, 0: Line too long (106/100) (line-too-long)
C: 32, 0: Line too long (107/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  4, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  4, 0: Invalid function name "pf" (invalid-name)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W: 12, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 12, 0: Invalid function name "factPower" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "f" (invalid-name)
C: 20,11: Invalid variable name "m" (invalid-name)
C: 26, 0: Invalid argument name "n" (invalid-name)
C: 26, 0: Invalid argument name "d" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "dFacts" (invalid-name)
C: 31, 4: Invalid variable name "termDen" (invalid-name)
C: 32, 4: Invalid variable name "dFacts" (invalid-name)
C: 36, 0: Invalid function name "M" (invalid-name)
C: 36, 0: Invalid argument name "N" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 0: Invalid function name "SD" (invalid-name)
C: 40, 0: Missing function docstring (missing-docstring)
C: 42, 8: Invalid variable name "N" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 53, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge187/challenge187.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nPrimes" (invalid-name)
C:  7, 4: Invalid variable name "nTwos" (invalid-name)
C: 12,12: Invalid variable name "nTwos" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge188/challenge188.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge190/challenge190.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "P" (invalid-name)
C:  1, 0: Invalid argument name "m" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge191/challenge191.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(days, previousThree, latesLeft, known = dict()):
                                                    ^ (bad-whitespace)
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
                                                              ^ (bad-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Line too long (105/100) (line-too-long)
C: 67, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "latesLeft" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  7, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "numVariations" (invalid-name)
C: 25, 0: Invalid argument name "tilePatterns" (invalid-name)
C: 25, 0: Invalid argument name "losingPatterns" (invalid-name)
R: 25, 0: Too many local variables (16/15) (too-many-locals)
C: 29, 4: Invalid variable name "nVariations" (invalid-name)
C: 35,16: Invalid variable name "c" (invalid-name)
C: 36,16: Invalid variable name "nVariations" (invalid-name)
C: 39,16: Invalid variable name "tilePattern" (invalid-name)
C: 41,16: Invalid variable name "lTilePattern" (invalid-name)
C: 45,24: Invalid variable name "nVariations" (invalid-name)
C: 50,16: Invalid variable name "nLeft" (invalid-name)
C: 52,20: Invalid variable name "nLeft" (invalid-name)
C: 55,20: Invalid variable name "lPattern" (invalid-name)
C: 62,24: Invalid variable name "nVariations" (invalid-name)
C: 66,12: Invalid variable name "nVariations" (invalid-name)
W: 35,16: Unused variable 'c' (unused-variable)
R: 25, 0: Too many branches (13/12) (too-many-branches)
C: 72, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nPatterns" (invalid-name)
C: 76, 4: Invalid variable name "nLosses" (invalid-name)
C: 80, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge197/challenge197.py _________________
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "f" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "n" (invalid-name)
C:  6, 4: Invalid variable name "u" (invalid-name)
C: 13, 8: Invalid variable name "u" (invalid-name)
W: 10, 4: Unused variable 'odd' (unused-variable)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge197\challenge197.py:10:5: F841 local variable 'odd' is assigned to but never used
D:\Development\pemjh\pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge203/challenge203.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "squareFree" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 29,12: Invalid variable name "p" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
D:\Development\pemjh\pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge204/challenge204.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getHams" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCount" (invalid-name)
C:  5, 8: Invalid variable name "p" (invalid-name)
C:  7, 8: Invalid variable name "pCurrent" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 14,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "pCurrent" (invalid-name)
C: 19, 0: Invalid function name "hamNums" (invalid-name)
C: 19, 0: Invalid argument name "maxPrime" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 23, 4: Unused variable 'found' (unused-variable)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:23:5: F841 local variable 'found' is assigned to but never used
D:\Development\pemjh\pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge205/challenge205.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "diceRolls" (invalid-name)
C:  7, 0: Invalid argument name "nDice" (invalid-name)
C:  7, 0: Invalid argument name "nSides" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nRolls" (invalid-name)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17,10: Invalid variable name "nPete" (invalid-name)
C: 18,11: Invalid variable name "nColin" (invalid-name)
C: 20, 4: Invalid variable name "peteWin" (invalid-name)
C: 21, 4: Invalid variable name "totalRolls" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 22,11: Invalid variable name "f" (invalid-name)
C: 24, 8: Invalid variable name "nWins" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge206/challenge206.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "v" (invalid-name)
C: 12, 0: Invalid function name "hasMask" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "w" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "lowestRoot" (invalid-name)
C: 34, 8: Invalid variable name "sq" (invalid-name)
C: 36, 8: Invalid variable name "hasM" (invalid-name)
C: 36,14: Invalid variable name "wrongIndex" (invalid-name)
C: 51,12: Invalid variable name "sq" (invalid-name)
C: 58,32: More than one statement on a single line (multiple-statements)
C: 62, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused floor imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge206\challenge206.py:1:1: F401 'floor' imported but unused
D:\Development\pemjh\pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge207/challenge207.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "a" (invalid-name)
C:  6, 4: Invalid variable name "b" (invalid-name)
C:  7, 4: Invalid variable name "t" (invalid-name)
C:  8, 4: Invalid variable name "nextPower" (invalid-name)
C: 10, 8: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "t" (invalid-name)
C: 16,12: Invalid variable name "nextPower" (invalid-name)
C: 20, 8: Invalid variable name "a" (invalid-name)
C: 20,11: Invalid variable name "b" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge211/challenge211.py _________________
C: 13, 0: Line too long (112/100) (line-too-long)
C: 54, 0: No space allowed around keyword argument assignment
def challenge211(calc = False):
                      ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "squareSum" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "slowButRight" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "d" (invalid-name)
C: 27,11: Invalid variable name "m" (invalid-name)
C: 30,12: Invalid variable name "a" (invalid-name)
C: 33,16: Invalid variable name "a" (invalid-name)
C: 34,16: Invalid variable name "d" (invalid-name)
C: 34,19: Invalid variable name "m" (invalid-name)
C: 44, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "x" (invalid-name)
C: 48, 8: Invalid variable name "s" (invalid-name)
C: 54, 0: Missing function docstring (missing-docstring)
C: 63, 0: Invalid constant name "answer" (invalid-name)
F: 66, 4: Unable to import 'psyco' (import-error)
W:  2, 0: Unused takewhile imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge211\challenge211.py:2:1: F401 'takewhile' imported but unused
D:\Development\pemjh\pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
D:\Development\pemjh\pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge214/challenge214.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def totients(n, primes = None):
                       ^ (bad-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def totientChainLength(n, current, limit, steps, known = dict()):
                                                       ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "p" (invalid-name)
C: 19,12: Invalid variable name "t" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "totientChainLength" (invalid-name)
C: 25, 0: Invalid argument name "n" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 51,12: Invalid variable name "v" (invalid-name)
W: 25,26: Unused argument 'current' (unused-argument)
C: 58, 0: Missing function docstring (missing-docstring)
C: 64, 8: Invalid variable name "p" (invalid-name)
C: 71, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused phi imported from utils.numbers (unused-import)
W:  1, 0: Unused primeFactors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'phi' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'primeFactors' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge215/challenge215.py _________________
C:  3, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  6, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C:  9, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 12, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "buildRowOptions" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid function name "runningCrack" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 31, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 31, 0: Invalid function name "W" (invalid-name)
C: 31, 0: Invalid argument name "startRow" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 39,16: Invalid variable name "subRow" (invalid-name)
C: 46, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "wallWidth" (invalid-name)
C: 49, 4: Invalid variable name "wallHeight" (invalid-name)
C: 51, 4: Invalid variable name "rowLinks" (invalid-name)
W: 53,11: Used builtin function 'map' (bad-builtin)
C: 61, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)

_________________ [pylint] pemjh/challenge216/challenge216.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
def challenge216(skip = True):
                      ^ (bad-whitespace)
C: 49, 0: Trailing whitespace (trailing-whitespace)
C: 51, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 54, 0: Exactly one space required after comma
    primes[0:2] = [False,False]
                        ^ (bad-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 60, 0: Trailing whitespace (trailing-whitespace)
C: 62, 0: Trailing whitespace (trailing-whitespace)
C: 63, 0: Exactly one space required after comma
    t[0:2] = [False,False]
                   ^ (bad-whitespace)
C: 64, 0: Trailing whitespace (trailing-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "l" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "v" (invalid-name)
C:  8,12: Invalid variable name "v" (invalid-name)
C: 20, 0: Invalid function name "sq" (invalid-name)
C: 20, 0: Invalid argument name "a" (invalid-name)
C: 20, 0: Invalid argument name "p" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 21, 4: Invalid variable name "q" (invalid-name)
C: 21, 7: Invalid variable name "e" (invalid-name)
C: 23, 8: Invalid variable name "e" (invalid-name)
C: 24, 8: Invalid variable name "q" (invalid-name)
C: 25, 4: Invalid variable name "n" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 28, 4: Invalid variable name "z" (invalid-name)
C: 29, 4: Invalid variable name "y" (invalid-name)
C: 29, 7: Invalid variable name "r" (invalid-name)
C: 29,10: Invalid variable name "x" (invalid-name)
C: 30, 4: Invalid variable name "b" (invalid-name)
C: 31, 4: Invalid variable name "x" (invalid-name)
C: 33, 8: Invalid variable name "bb" (invalid-name)
C: 33,12: Invalid variable name "m" (invalid-name)
C: 35,12: Invalid variable name "bb" (invalid-name)
C: 36,12: Invalid variable name "m" (invalid-name)
C: 39, 8: Invalid variable name "t" (invalid-name)
C: 41,12: Invalid variable name "t" (invalid-name)
C: 42, 8: Invalid variable name "y" (invalid-name)
C: 42,11: Invalid variable name "r" (invalid-name)
C: 42,14: Invalid variable name "x" (invalid-name)
C: 43, 8: Invalid variable name "b" (invalid-name)
W: 40,12: Unused variable 'k' (unused-variable)
C: 46, 0: Missing function docstring (missing-docstring)
C: 56, 8: Invalid variable name "x" (invalid-name)
C: 58,16: Invalid variable name "y" (invalid-name)
C: 61, 4: Invalid variable name "t" (invalid-name)
C: 65, 8: Invalid variable name "x" (invalid-name)
C: 67,12: Invalid variable name "s" (invalid-name)
C: 78, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge220/challenge220.py _________________
C:  2, 0: Exactly one space required after comma
    c = [0,1]
          ^ (bad-whitespace)
C: 13, 0: Exactly one space required after comma
    c2 = [-c2[1],c2[0]]
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "c" (invalid-name)
C:  5, 8: Invalid variable name "c" (invalid-name)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 12, 4: Invalid variable name "c2" (invalid-name)
C: 13, 4: Invalid variable name "c2" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
W: 17,20: Used builtin function 'map' (bad-builtin)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge225/challenge225.py _________________
C:  2, 0: Line too long (108/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 10,12: Invalid variable name "a" (invalid-name)
C: 10,15: Invalid variable name "b" (invalid-name)
C: 10,18: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)

_________________ [pylint] pemjh/challenge230/challenge230.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Line too long (110/100) (line-too-long)
C: 41, 0: Line too long (110/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "D" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "aSize" (invalid-name)
C:  7, 4: Invalid variable name "bSize" (invalid-name)
C:  9, 8: Invalid variable name "aSize" (invalid-name)
C:  9,15: Invalid variable name "bSize" (invalid-name)
C: 14, 4: Invalid variable name "workingN" (invalid-name)
C: 22, 8: Invalid variable name "firstSize" (invalid-name)
C: 25,12: Invalid variable name "workingN" (invalid-name)
C: 33, 8: Invalid variable name "containingStr" (invalid-name)
C: 35, 8: Invalid variable name "containingStr" (invalid-name)
W:  2, 4: Unused variable 'size' (unused-variable)
C: 39, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "a" (invalid-name)
C: 41, 4: Invalid variable name "b" (invalid-name)
C: 44,15: Invalid variable name "n" (invalid-name)
C: 49, 0: Invalid constant name "answer" (invalid-name)
W: 52, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge230\challenge230.py:2:5: F841 local variable 'size' is assigned to but never used
D:\Development\pemjh\pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:52:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge231/challenge231.py _________________
C: 43, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getFirstMultipleOnOrAfter" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "m" (invalid-name)
C: 10, 0: Invalid function name "getFirstMultipleOnOrBefore" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 17, 0: Invalid function name "numInRange" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 23, 0: Missing function docstring (missing-docstring)
C: 24, 4: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "p" (invalid-name)
C: 43,12: Invalid variable name "numRange" (invalid-name)
C: 49,12: Invalid variable name "denRange" (invalid-name)
C: 53,12: Invalid variable name "inRange" (invalid-name)
C: 59,16: Invalid variable name "inRange" (invalid-name)
C: 62,16: Invalid variable name "inRange" (invalid-name)
W: 36, 8: Unused variable 'index' (unused-variable)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:36:9: F841 local variable 'index' is assigned to but never used
D:\Development\pemjh\pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace

_________________ [pylint] pemjh/challenge234/challenge234.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Wrong continued indentation.
                          next**2 if next**2 < limit + 1 else limit + 1,
                          ^| (bad-continuation)
C: 24, 0: Wrong continued indentation.
                          current))
                          ^| (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Missing function docstring (missing-docstring)
W: 19, 8: Redefining built-in 'next' (redefined-builtin)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent

_________________ [pylint] pemjh/challenge235/challenge235.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "r" (invalid-name)
C:  4, 4: Invalid variable name "dr" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  7, 8: Invalid variable name "s" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 11,12: Invalid variable name "r" (invalid-name)
C: 12, 8: Invalid variable name "dr" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge243/challenge243.py _________________
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "d" (invalid-name)
C: 24,23: More than one statement on a single line (multiple-statements)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 37,20: Invalid variable name "m" (invalid-name)
C: 38,20: Invalid variable name "d" (invalid-name)
C: 46, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge250/challenge250.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W: 12,12: Unused variable 'j' (unused-variable)
C: 20, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge259/challenge259.py _________________
C: 22, 0: No space allowed around keyword argument assignment
def get_totals(start, end, known = {}):
                                 ^ (bad-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "g" (invalid-name)
C: 10, 0: Invalid argument name "a" (invalid-name)
C: 10, 0: Invalid argument name "b" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid argument name "a" (invalid-name)
C: 13, 0: Invalid argument name "b" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid argument name "a" (invalid-name)
C: 16, 0: Invalid argument name "b" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid argument name "a" (invalid-name)
C: 19, 0: Invalid argument name "b" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 22, 0: Dangerous default value {} as argument (dangerous-default-value)
C: 22, 0: Missing function docstring (missing-docstring)
C: 55, 0: Invalid constant name "answer" (invalid-name)
C: 57, 0: Missing function docstring (missing-docstring)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)

_________________ [pylint] pemjh/challenge265/challenge265.py _________________
C: 10, 0: Trailing whitespace (trailing-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Trailing whitespace (trailing-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  3, 4: Invalid variable name "s" (invalid-name)
C:  4, 4: Invalid variable name "d" (invalid-name)
C:  4, 7: Invalid variable name "m" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  6, 4: Invalid variable name "d" (invalid-name)
C:  6, 7: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "s" (invalid-name)
C:  8, 4: Invalid variable name "s" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Invalid argument name "d" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "b" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "getSequences" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 26, 8: Invalid variable name "b" (invalid-name)
C: 30,16: Invalid variable name "s" (invalid-name)
C: 35, 0: Invalid function name "S" (invalid-name)
C: 35, 0: Invalid argument name "n" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 49, 0: Missing function docstring (missing-docstring)
C: 52, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace

--------------- coverage: platform win32, python 2.7.10-final-0 ---------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge001\challenge001       7      3      4      3    45%   4, 9-10
pemjh\challenge002\challenge002      12     10      8      7    15%   2-3, 6-16
pemjh\challenge003\challenge003      17     13     10      5    33%   5-23, 28-29
pemjh\challenge004\challenge004      19     16     10      9    14%   5-31, 36-37
pemjh\challenge005\challenge005      24     21     18     17    10%   2-34, 39-40
pemjh\challenge006\challenge006      13     10      4      3    24%   2-18, 23-24
pemjh\challenge007\challenge007      18     13      9      8    22%   5-19, 24-25
pemjh\challenge008\challenge008      16     13     10      9    15%   2-39, 44-45
pemjh\challenge009\challenge009      14     11      8      7    18%   4-16, 21-22
pemjh\challenge010\challenge010      14      9     10      9    25%   6-13, 18-19
pemjh\challenge011\challenge011      39     36     26     25     6%   2-56, 61-62
pemjh\challenge012\challenge012      31     28     14      9    18%   2-3, 7-44
pemjh\challenge013\challenge013      11      8      4      3    27%   2-109, 114-115
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      8      5    17%   2-3, 7-32
pemjh\challenge016\challenge016      12      9      4      3    25%   2-12, 17-18
pemjh\challenge017\challenge017      33     29     16     15    10%   2-39, 42-104, 109-110
pemjh\challenge018\challenge018      26     24      4      3    10%   2-3, 6-31
pemjh\challenge019\challenge019      32     25     18     17    16%   2, 6-9, 12-15, 19-28, 33-40, 45-46
pemjh\challenge020\challenge020      16     12      6      5    23%   2-5, 9-16, 21-22
pemjh\challenge021\challenge021      21     19     14     13     9%   2-3, 7-33
pemjh\challenge022\challenge022      28     21     10      9    21%   5-14, 17-24, 28-32, 37-38
pemjh\challenge023\challenge023      24     18     16     14    20%   2-3, 7-21, 24, 27-29, 34
pemjh\challenge024\challenge024      14     12      6      5    15%   2-3, 7-18
pemjh\challenge025\challenge025      15     13     10      9    12%   2-3, 5-19
pemjh\challenge026\challenge026      21     17     10      9    16%   4-23, 28-29
pemjh\challenge027\challenge027      27     25     14     11    12%   2-3, 6-36
pemjh\challenge028\challenge028      14     11      4      3    22%   2-13, 18-19
pemjh\challenge029\challenge029      14     11      6      5    20%   2-12, 17-18
pemjh\challenge030\challenge030      19     16     10      9    14%   3-16, 21-22
pemjh\challenge031\challenge031      16     12      6      5    23%   2-14, 19, 22-23
pemjh\challenge032\challenge032      20     18     10      9    10%   2-3, 7-27
pemjh\challenge033\challenge033      33     31     18     17     6%   2-3, 7-48
pemjh\challenge034\challenge034      30     28     14     11    11%   2-3, 7-46
pemjh\challenge035\challenge035      38     36     24     23     5%   2-3, 6-59
pemjh\challenge036\challenge036      22     18     10      9    16%   2-7, 11-24, 29-30
pemjh\challenge037\challenge037      27     25     18     15    11%   2-3, 7-36
pemjh\challenge038\challenge038      20     15     10      9    20%   4, 7-21, 26-27
pemjh\challenge039\challenge039      27     23     14     13    12%   2-23, 26-34, 39-40
pemjh\challenge040\challenge040      15     12      6      5    19%   2-13, 18-19
pemjh\challenge041\challenge041      17     15      8      7    12%   2-3, 6-23
pemjh\challenge042\challenge042      30     24     14     13    16%   5-9, 12-36, 41-42
pemjh\challenge043\challenge043      14     12      6      5    15%   2-3, 6-27
pemjh\challenge044\challenge044      27     21     14     13    17%   4, 7-11, 14-29, 34-35
pemjh\challenge045\challenge045      25     19     12      7    30%   2, 5, 9-21, 24-29, 34-35
pemjh\challenge046\challenge046      23     20     12      9    17%   4-5, 8-32
pemjh\challenge047\challenge047      37     34     22     19    10%   4-5, 8-50
pemjh\challenge048\challenge048       7      4      2      1    44%   2-3, 8-10
pemjh\challenge049\challenge049      24     21     16     15    10%   4-5, 8-32
pemjh\challenge050\challenge050      24     22     12     11     8%   2-3, 6-30
pemjh\challenge051\challenge051      38     35     24     21    10%   4-5, 8-50
pemjh\challenge052\challenge052      20     16      8      7    18%   2, 5-22, 27-28
pemjh\challenge053\challenge053      16     14     10      9    12%   2-3, 6-20
pemjh\challenge054\challenge054      71     61     44     43    10%   5-12, 16-19, 22-24, 39-93, 98-111, 115-131, 136
pemjh\challenge055\challenge055      23     19     12      9    20%   2-12, 15-21, 26-27
pemjh\challenge056\challenge056      14     11      8      7    18%   2-11, 16-17
pemjh\challenge057\challenge057      15     12      8      7    17%   2-15, 20-21
pemjh\challenge058\challenge058      26     24     12      9    13%   2-3, 6-38
pemjh\challenge059\challenge059      29     22     19     18    17%   6-21, 27-45, 48-49
pemjh\challenge060\challenge060      75     73     37     36     3%   2-3, 7-119
pemjh\challenge061\challenge061      65     59     42     41     7%   4, 7-22, 28-99, 104
pemjh\challenge062\challenge062      23     19      8      5    23%   4-29, 34
pemjh\challenge063\challenge063      18     14      6      3    29%   4-22, 27-28
pemjh\challenge064\challenge064      24     23      8      8     3%   3-39
pemjh\challenge065\challenge065      20     18      8      7    11%   2-3, 6-37
pemjh\challenge066\challenge066      15     14      8      8     4%   5-23
pemjh\challenge067\challenge067      17     13      6      5    22%   5-6, 11-25
pemjh\challenge068\challenge068      48     43     32     31     8%   2-5, 8-21, 24-65, 70
pemjh\challenge069\challenge069      20     18     10      9    10%   2-3, 6-24
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
pemjh\challenge071\challenge071      25     21     12     11    14%   4-27, 32
pemjh\challenge072\challenge072      10      8      4      3    21%   2-3, 7-14
pemjh\challenge073\challenge073      31     28     16     15     9%   4-5, 8-42
pemjh\challenge074\challenge074      33     28     10      9    14%   2-3, 6-23, 26-36, 41
pemjh\challenge075\challenge075      16     15      8      8     4%   3-27
pemjh\challenge076\challenge076      20     16     10      9    17%   2-17, 30-32, 37
pemjh\challenge077\challenge077      20     19     12     10     9%   3-34
pemjh\challenge078\challenge078      20     17     12     11    13%   2-19, 24
pemjh\challenge079\challenge079       8      3      2      1    60%   9, 14-15
pemjh\challenge080\challenge080      26     21     12     11    16%   5-26, 29-34, 39
pemjh\challenge081\challenge081      32     26     13     12    16%   5-17, 20-41, 46
pemjh\challenge082\challenge082      34     27     12     11    17%   7-37, 41-48, 53
pemjh\challenge083\challenge083      45     38     20     19    12%   6-14, 17-25, 29-75, 80
pemjh\challenge084\challenge084      74     67     48     47     7%   4-6, 10-50, 54-66, 69-109, 114
pemjh\challenge085\challenge085      34     30     16     11    18%   3-10, 13-46, 51
pemjh\challenge086\challenge086      32     26     14     11    20%   2, 6-17, 20-25, 28-39, 44
pemjh\challenge087\challenge087      30     28     14     13     7%   2-3, 5-40
pemjh\challenge088\challenge088      24     19     12     11    17%   5-19, 22-31, 36
pemjh\challenge089\challenge089      51     42     26     25    13%   18-31, 35-51, 54-65, 69-79, 83-85, 90
pemjh\challenge090\challenge090      78     68     50     49     9%   5-18, 21-27, 30-33, 36-69, 74-114, 117-127, 132
pemjh\challenge091\challenge091      23     19     20     19    12%   2-30, 33-35, 40
pemjh\challenge092\challenge092      96     94     50     45     5%   2-3, 6-124
pemjh\challenge093\challenge093      67     59     50     49     8%   4-10, 14-24, 27-32, 35-58, 61-97, 102
pemjh\challenge094\challenge094      35     30     12     11    13%   2-7, 11-48, 54
pemjh\challenge095\challenge095      35     30     22     21    11%   3-10, 14-48, 51-56, 61
pemjh\challenge096\challenge096     181    155    116    115     9%   7-14, 22-34, 40-44, 47-59, 62-69, 73-94, 97-105, 108-115, 118-146, 150-155, 158-174, 178-181, 184-221, 224-228, 231-235, 238-241, 244-254, 257-277, 294
pemjh\challenge097\challenge097       6      3      2      1    50%   2, 7-8
pemjh\challenge098\challenge098      62     54     34     33     9%   5-13, 16-23, 26-30, 33-93, 98
pemjh\challenge099\challenge099      17     12      7      6    25%   5-14, 19-20
pemjh\challenge100\challenge100       9      6      4      3    31%   2-6, 11
pemjh\challenge101\challenge101      26     23     18     17     9%   2-38, 43
pemjh\challenge102\challenge102      34     27     14     13    17%   9-31, 35-41, 45-53, 59
pemjh\challenge103\challenge103      40     35     30     29     9%   3-12, 16-34, 37-56, 61
pemjh\challenge104\challenge104      34     33     15     15     2%   3-50
pemjh\challenge105\challenge105      40     32     22     21    15%   5-19, 22-28, 32-47, 51-58, 65
pemjh\challenge106\challenge106      37     30     16     15    15%   2-14, 17-26, 29-46, 49-60, 63, 68
pemjh\challenge107\challenge107      38     31     12     11    16%   6-34, 37-45, 48-65, 70
pemjh\challenge108\challenge108      35     34     16     16     2%   3-59
pemjh\challenge109\challenge109      37     32     18     17    11%   2-19, 23-29, 32-45, 50
pemjh\challenge110\challenge110      35     34     16     16     2%   3-59
pemjh\challenge111\challenge111      38     37     31     31     1%   3-54
pemjh\challenge112\challenge112      32     28     20     17    13%   2-27, 30-43, 48
pemjh\challenge113\challenge113      16     14      6      5    14%   2-3, 6-61
pemjh\challenge114\challenge114      24     19     12     11    17%   2-24, 27-28, 31-32, 37
pemjh\challenge115\challenge115      30     25     14     13    14%   2-25, 28-29, 32-38, 43
pemjh\challenge116\challenge116      24     19     10      9    18%   2-22, 25-28, 31-32, 37
pemjh\challenge117\challenge117      21     16     10      9    19%   2-20, 23-24, 27-28, 33
pemjh\challenge118\challenge118      36     35     14     14     2%   2-52
pemjh\challenge119\challenge119      24     19     10      9    18%   2-7, 12-23, 26-28, 33
pemjh\challenge120\challenge120      10      6      4      3    36%   2-6, 9-10, 15
pemjh\challenge121\challenge121      26     25     10     10     3%   3-39
pemjh\challenge122\challenge122      15     12     12     11    15%   2-23, 28
pemjh\challenge123\challenge123      16     15      6      6     5%   3-20
pemjh\challenge124\challenge124      21     20     14     14     3%   3-41
pemjh\challenge125\challenge125      21     18     12     11    12%   2-24, 29
pemjh\challenge126\challenge126      31     27     24     23     9%   2, 6-36, 41
pemjh\challenge127\challenge127      23     22     15     15     3%   3-35
pemjh\challenge128\challenge128      23     22     10     10     3%   3-33
pemjh\challenge129\challenge129      22     18     10      9    16%   2-8, 11-20, 25-27
pemjh\challenge130\challenge130      21     20      8      8     3%   3-30
pemjh\challenge131\challenge131      22     21     10     10     3%   3-41
pemjh\challenge132\challenge132      16     15      8      8     4%   3-24
pemjh\challenge133\challenge133      10      9      2      2     8%   3-16
pemjh\challenge134\challenge134      42     41     20     20     2%   3-72
pemjh\challenge135\challenge135      15     11     10      9    20%   2-16, 19, 25
pemjh\challenge136\challenge136      19     18     10     10     3%   3-26
pemjh\challenge137\challenge137      16     11      6      5    27%   2-6, 10-17, 20, 25
pemjh\challenge138\challenge138      23     22     14     14     3%   3-34
pemjh\challenge139\challenge139      11     10      6      6     6%   3-19
pemjh\challenge142\challenge142      26     21     18     17    14%   2, 5, 8-34, 39
pemjh\challenge144\challenge144      34     26      6      5    23%   4-5, 9-27, 31-51, 54, 57-67, 72
pemjh\challenge145\challenge145      11      8      4      3    27%   2-10, 15
pemjh\challenge146\challenge146      18     13     14     13    19%   2-6, 9, 17-26, 31
pemjh\challenge148\challenge148      22     17      6      5    21%   2-8, 11-29, 32-34, 39
pemjh\challenge149\challenge149      32     26     12     11    16%   2, 5, 9-27, 30-46, 51
pemjh\challenge151\challenge151      21     17     14     13    14%   2-20, 23, 28
pemjh\challenge162\challenge162       7      3      4      3    45%   2-4, 11
pemjh\challenge164\challenge164      20     16     10      9    17%   3-23, 27-31, 36
pemjh\challenge166\challenge166      40     37     33     32     5%   3-68, 73
pemjh\challenge173\challenge173      21     17      6      5    19%   2-27, 30, 35
pemjh\challenge174\challenge174      27     26     14     14     2%   3-40
pemjh\challenge179\challenge179      18     14      8      7    19%   3-17, 20-21, 26
pemjh\challenge183\challenge183      39     38     12     12     2%   2-56
pemjh\challenge187\challenge187      16     15      8      8     4%   3-22
pemjh\challenge188\challenge188      15     11      6      5    24%   2-10, 13, 18
pemjh\challenge190\challenge190       7      3      6      5    38%   2, 6, 11
pemjh\challenge191\challenge191      48     43     34     33     7%   2-23, 27-70, 73-78, 83
pemjh\challenge197\challenge197      19     15      8      7    19%   2, 5-22, 27
pemjh\challenge203\challenge203      27     26     16     16     2%   3-44
pemjh\challenge204\challenge204      21     20      8      8     3%   3-32
pemjh\challenge205\challenge205      25     20     10      9    17%   2-4, 8-14, 17-27, 32
pemjh\challenge206\challenge206      45     37     16     13    18%   6-10, 13-22, 26-60, 65
pemjh\challenge207\challenge207      20     17      6      5    15%   3-20, 25
pemjh\challenge211\challenge211      46     45     24     24     1%   2-68
pemjh\challenge214\challenge214      45     44     26     26     1%   3-76
pemjh\challenge215\challenge215      45     39     32     31     9%   2-23, 26-29, 32-44, 48-59, 64
pemjh\challenge216\challenge216      67     61     48     47     6%   4-18, 21-44, 47-76, 81
pemjh\challenge220\challenge220      17     13      6      5    22%   2-14, 17, 22
pemjh\challenge225\challenge225      14     11      8      7    18%   4-14, 19
pemjh\challenge230\challenge230      34     30     12     11    11%   2-37, 40-47, 52-53
pemjh\challenge231\challenge231      41     40     14     14     2%   3-72
pemjh\challenge234\challenge234      25     24     10     10     3%   3-44
pemjh\challenge235\challenge235      15     12      8      7    17%   2-14, 19
pemjh\challenge243\challenge243      33     32     20     20     2%   3-49
pemjh\challenge250\challenge250      16     12      8      7    21%   2-18, 21-22, 27
pemjh\challenge259\challenge259      42     32     18     17    18%   4-8, 11, 14, 17, 20, 23-53, 58-63, 66
pemjh\challenge265\challenge265      35     27     10      9    20%   2-9, 13-15, 18, 21-33, 37-47, 50, 55
pemjh\main                           51     33     20     15    32%   7-8, 13-28, 39-57, 63, 66-68
-----------------------------------------------------------------------------
TOTAL                              4961   4273   2571   2370    12%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\python27_64\Lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "E:\software_tools\python\python27_64\Lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\Development\pemjh\.tox\py27_64\Scripts\py.test.EXE\__main__.py", line 9, in <module>
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py27_64\lib\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
pytest_cov.plugin.CoverageError: Required test coverage of 100% not reached. Total coverage: 11.80%
ERROR: InvocationError: 'D:\\Development\\pemjh\\.tox\\py27_64\\Scripts\\py.test.EXE --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100'
py34 inst-nodeps: D:\Development\pemjh\.tox\dist\pemjh-0.0.1.zip
py34 installed: apipkg==1.4,astroid==1.3.8,colorama==0.3.3,coverage==3.7.1,execnet==1.4.1,flake8==2.4.1,logilab-common==1.0.2,mccabe==0.3.1,pemjh==0.0.1,pep8==1.5.7,py==1.4.30,pyflakes==0.8.1,pylint==1.4.4,pytest==2.7.2,pytest-cache==1.0,pytest-cov==2.1.0,pytest-flake8==0.1,pytest-pylint==0.3.0,six==1.9.0,wheel==0.24.0
py34 runtests: PYTHONHASHSEED='850'
py34 runtests: commands[0] | py.test --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100
============================= test session starts =============================
platform win32 -- Python 3.4.3 -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh, inifile: 
plugins: cache, cov, flake8, pylint
collected 358 items / 178 errors

setup.py FF
pemjh\main.py FF
pemjh\challenge001\challenge001.py FF
pemjh\challenge002\challenge002.py FF
pemjh\challenge003\challenge003.py FF
pemjh\challenge004\challenge004.py FF
pemjh\challenge005\challenge005.py FF
pemjh\challenge006\challenge006.py FF
pemjh\challenge007\challenge007.py FF
pemjh\challenge008\challenge008.py FF
pemjh\challenge009\challenge009.py FF
pemjh\challenge010\challenge010.py FF
pemjh\challenge011\challenge011.py FF
pemjh\challenge012\challenge012.py FF
pemjh\challenge013\challenge013.py FF
pemjh\challenge014\challenge014.py FF
pemjh\challenge015\challenge015.py FF
pemjh\challenge016\challenge016.py FF
pemjh\challenge017\challenge017.py FF
pemjh\challenge018\challenge018.py FF
pemjh\challenge019\challenge019.py FF
pemjh\challenge020\challenge020.py FF
pemjh\challenge021\challenge021.py FF
pemjh\challenge022\challenge022.py FF
pemjh\challenge023\challenge023.py FF
pemjh\challenge024\challenge024.py FF
pemjh\challenge025\challenge025.py FF
pemjh\challenge026\challenge026.py FF
pemjh\challenge027\challenge027.py FF
pemjh\challenge028\challenge028.py FF
pemjh\challenge029\challenge029.py FF
pemjh\challenge030\challenge030.py FF
pemjh\challenge031\challenge031.py FF
pemjh\challenge032\challenge032.py FF
pemjh\challenge033\challenge033.py FF
pemjh\challenge034\challenge034.py FF
pemjh\challenge035\challenge035.py FF
pemjh\challenge036\challenge036.py FF
pemjh\challenge037\challenge037.py FF
pemjh\challenge038\challenge038.py FF
pemjh\challenge039\challenge039.py FF
pemjh\challenge040\challenge040.py FF
pemjh\challenge041\challenge041.py FF
pemjh\challenge042\challenge042.py FF
pemjh\challenge043\challenge043.py FF
pemjh\challenge044\challenge044.py FF
pemjh\challenge045\challenge045.py FF
pemjh\challenge046\challenge046.py FF
pemjh\challenge047\challenge047.py FF
pemjh\challenge048\challenge048.py FF
pemjh\challenge049\challenge049.py FF
pemjh\challenge050\challenge050.py FF
pemjh\challenge051\challenge051.py FF
pemjh\challenge052\challenge052.py FF
pemjh\challenge053\challenge053.py FF
pemjh\challenge054\challenge054.py FF
pemjh\challenge055\challenge055.py FF
pemjh\challenge056\challenge056.py FF
pemjh\challenge057\challenge057.py FF
pemjh\challenge058\challenge058.py FF
pemjh\challenge059\challenge059.py FF
pemjh\challenge060\challenge060.py FF
pemjh\challenge061\challenge061.py FF
pemjh\challenge062\challenge062.py FF
pemjh\challenge063\challenge063.py FF
pemjh\challenge064\challenge064.py FF
pemjh\challenge065\challenge065.py FF
pemjh\challenge066\challenge066.py FF
pemjh\challenge067\challenge067.py FF
pemjh\challenge068\challenge068.py FF
pemjh\challenge069\challenge069.py FF
pemjh\challenge070\challenge070.py FF
pemjh\challenge071\challenge071.py FF
pemjh\challenge072\challenge072.py FF
pemjh\challenge073\challenge073.py FF
pemjh\challenge074\challenge074.py FF
pemjh\challenge075\challenge075.py FF
pemjh\challenge076\challenge076.py FF
pemjh\challenge077\challenge077.py FF
pemjh\challenge078\challenge078.py FF
pemjh\challenge079\challenge079.py FF
pemjh\challenge080\challenge080.py FF
pemjh\challenge081\challenge081.py FF
pemjh\challenge082\challenge082.py FF
pemjh\challenge083\challenge083.py FF
pemjh\challenge084\challenge084.py FF
pemjh\challenge085\challenge085.py FF
pemjh\challenge086\challenge086.py FF
pemjh\challenge087\challenge087.py FF
pemjh\challenge088\challenge088.py FF
pemjh\challenge089\challenge089.py FF
pemjh\challenge090\challenge090.py FF
pemjh\challenge091\challenge091.py FF
pemjh\challenge092\challenge092.py FF
pemjh\challenge093\challenge093.py FF
pemjh\challenge094\challenge094.py FF
pemjh\challenge095\challenge095.py FF
pemjh\challenge096\challenge096.py FF
pemjh\challenge097\challenge097.py FF
pemjh\challenge098\challenge098.py FF
pemjh\challenge099\challenge099.py FF
pemjh\challenge100\challenge100.py FF
pemjh\challenge101\challenge101.py FF
pemjh\challenge102\challenge102.py FF
pemjh\challenge103\challenge103.py FF
pemjh\challenge104\challenge104.py FF
pemjh\challenge105\challenge105.py FF
pemjh\challenge106\challenge106.py FF
pemjh\challenge107\challenge107.py FF
pemjh\challenge108\challenge108.py FF
pemjh\challenge109\challenge109.py FF
pemjh\challenge110\challenge110.py FF
pemjh\challenge111\challenge111.py FF
pemjh\challenge112\challenge112.py FF
pemjh\challenge113\challenge113.py FF
pemjh\challenge114\challenge114.py FF
pemjh\challenge115\challenge115.py FF
pemjh\challenge116\challenge116.py FF
pemjh\challenge117\challenge117.py FF
pemjh\challenge118\challenge118.py FF
pemjh\challenge119\challenge119.py FF
pemjh\challenge120\challenge120.py FF
pemjh\challenge121\challenge121.py FF
pemjh\challenge122\challenge122.py FF
pemjh\challenge123\challenge123.py FF
pemjh\challenge124\challenge124.py FF
pemjh\challenge125\challenge125.py FF
pemjh\challenge126\challenge126.py FF
pemjh\challenge127\challenge127.py FF
pemjh\challenge128\challenge128.py FF
pemjh\challenge129\challenge129.py FF
pemjh\challenge130\challenge130.py FF
pemjh\challenge131\challenge131.py FF
pemjh\challenge132\challenge132.py FF
pemjh\challenge133\challenge133.py FF
pemjh\challenge134\challenge134.py FF
pemjh\challenge135\challenge135.py FF
pemjh\challenge136\challenge136.py FF
pemjh\challenge137\challenge137.py FF
pemjh\challenge138\challenge138.py FF
pemjh\challenge139\challenge139.py FF
pemjh\challenge142\challenge142.py FF
pemjh\challenge144\challenge144.py FF
pemjh\challenge145\challenge145.py FF
pemjh\challenge146\challenge146.py FF
pemjh\challenge148\challenge148.py FF
pemjh\challenge149\challenge149.py FF
pemjh\challenge151\challenge151.py FF
pemjh\challenge162\challenge162.py FF
pemjh\challenge164\challenge164.py FF
pemjh\challenge166\challenge166.py FF
pemjh\challenge173\challenge173.py FF
pemjh\challenge174\challenge174.py FF
pemjh\challenge179\challenge179.py FF
pemjh\challenge183\challenge183.py FF
pemjh\challenge187\challenge187.py FF
pemjh\challenge188\challenge188.py FF
pemjh\challenge190\challenge190.py FF
pemjh\challenge191\challenge191.py FF
pemjh\challenge197\challenge197.py FF
pemjh\challenge203\challenge203.py FF
pemjh\challenge204\challenge204.py FF
pemjh\challenge205\challenge205.py FF
pemjh\challenge206\challenge206.py FF
pemjh\challenge207\challenge207.py FF
pemjh\challenge211\challenge211.py FF
pemjh\challenge214\challenge214.py FF
pemjh\challenge215\challenge215.py FF
pemjh\challenge216\challenge216.py FF
pemjh\challenge220\challenge220.py FF
pemjh\challenge225\challenge225.py FF
pemjh\challenge230\challenge230.py FF
pemjh\challenge231\challenge231.py FF
pemjh\challenge234\challenge234.py FF
pemjh\challenge235\challenge235.py FF
pemjh\challenge243\challenge243.py FF
pemjh\challenge250\challenge250.py FF
pemjh\challenge259\challenge259.py FF
pemjh\challenge265\challenge265.py FF

=================================== ERRORS ====================================
__________________________ ERROR collecting setup.py __________________________

self = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
func = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
self       = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>, attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000051029D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = None
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000051029D8>
self       = <DoctestModule 'setup.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'setup.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\setup.py'), modname = 'setup'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'setup'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh')
self       = local('D:\\Development\\pemjh\\setup.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    https://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands"""
    
    import os
    import sys
    from setuptools import setup
    from setuptools.command.test import test as TestCommand
    
    def read(fname):
        return open(os.path.join(os.path.dirname(__file__), fname)).read()
    
    class Tox(TestCommand):
        user_options = [('tox-args=', 'a', "Arguments to pass to tox")]
        def initialize_options(self):
            TestCommand.initialize_options(self)
            self.tox_args = None
        def finalize_options(self):
            TestCommand.finalize_options(self)
            self.test_args = []
            self.test_suite = True
        def run_tests(self):
            #import here, cause outside the eggs aren't loaded
            import tox
            import shlex
            args = self.tox_args
            if args:
                args = shlex.split(self.tox_args)
            errno = tox.cmdline(args=args)
            sys.exit(errno)
    
    setup(
        name = "pemjh",
        version = "0.0.1",
        author = "Matthew Hussey",
        author_email = "matthew.hussey@googlemail.com",
        description = ("Project euler (https://projecteuler.net/) challenge "
                       "code in Python."),
        license = "None, private use by myself only",
        keywords = "code challenge euler",
        url = "none.non",
        packages = ["pemjh"],
        long_description = read("README"),
        classifiers=[
            "Development Status :: 1 - Planning"],
        tests_require=['tox'],
>       cmdclass = {"test": Tox},
    )

TestCommand = <class 'setuptools.command.test.test'>
Tox        = <class 'setup.Tox'>
__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\__pycache__\\setup.cpython-34.pyc'
__doc__    = ' Setup file for install and test. Taken from:\nhttps://pythonhosted.org/an_example_pypi_project/setuptools.html\nfor ...html\nfor tox:\nhttps://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands'
__file__   = 'D:\\Development\\pemjh\\setup.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x0000000005383668>
__name__   = 'setup'
__package__ = ''
__spec__   = ModuleSpec(name='setup', loader=<_frozen_importlib.SourceFileLoader object at 0x0000000005383668>, origin='D:\\Development\\pemjh\\setup.py')
__warningregistry__ = {'version': 1, ("unclosed file <_io.TextIOWrapper name='D:\\\\Development\\\\pemjh\\\\README' mode='r' encoding='cp1252'>", <class 'ResourceWarning'>, 14): True}
os         = <module 'os' from 'd:\\development\\pemjh\\.tox\\py34\\lib\\os.py'>
read       = <function read at 0x00000000053911E0>
setup      = <function setup at 0x0000000004592D90>
sys        = <module 'sys' (built-in)>

setup.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

attrs = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class 'setup.Tox'>}, ...}
klass = <class 'setuptools.dist.Distribution'>
dist = <setuptools.dist.Distribution object at 0x0000000005392CC0>

    def setup (**attrs):
        """The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
    
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
    
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
    
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.
        """
    
        global _setup_stop_after, _setup_distribution
    
        # Determine the distribution class -- either caller-supplied or
        # our Distribution (see below).
        klass = attrs.get('distclass')
        if klass:
            del attrs['distclass']
        else:
            klass = Distribution
    
        if 'script_name' not in attrs:
            attrs['script_name'] = os.path.basename(sys.argv[0])
        if 'script_args'  not in attrs:
            attrs['script_args'] = sys.argv[1:]
    
        # Create the Distribution instance, using the remaining arguments
        # (ie. everything except distclass) to initialize it
        try:
            _setup_distribution = dist = klass(attrs)
        except DistutilsSetupError as msg:
            if 'name' not in attrs:
                raise SystemExit("error in setup command: %s" % msg)
            else:
                raise SystemExit("error in %s setup command: %s" % \
                      (attrs['name'], msg))
    
        if _setup_stop_after == "init":
            return dist
    
        # Find and parse the config file(s): they will override options from
        # the setup script, but be overridden by the command line.
        dist.parse_config_files()
    
        if DEBUG:
            print("options (after parsing config files):")
            dist.dump_option_dicts()
    
        if _setup_stop_after == "config":
            return dist
    
        # Parse the command line and override config files; any
        # command-line errors are the end user's fault, so turn them into
        # SystemExit to suppress tracebacks.
        try:
            ok = dist.parse_command_line()
        except DistutilsArgError as msg:
>           raise SystemExit(gen_usage(dist.script_name) + "\nerror: %s" % msg)
E           SystemExit: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
E              or: py.test.EXE --help [cmd1 cmd2 ...]
E              or: py.test.EXE --help-commands
E              or: py.test.EXE cmd --help
E           
E           error: option --pylint not recognized

attrs      = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class 'setup.Tox'>}, ...}
dist       = <setuptools.dist.Distribution object at 0x0000000005392CC0>
klass      = <class 'setuptools.dist.Distribution'>

E:\software_tools\python\python34_64\Lib\distutils\core.py:136: SystemExit
_______________________ ERROR collecting pemjh/main.py ________________________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (main.py, line 8)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/main.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/main.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (main.py, line 8)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/main.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/main.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/main.py'>, attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005475D08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\main.py', 8, 25, '    print "Psyco working"\n')), <traceback object at 0x00000000054953C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005475D08>
self       = <DoctestModule 'pemjh/main.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/main.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/main.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/main.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\main.py'), modname = 'main'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\main.py", line 8
E               print "Psyco working"
E                                   ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'main'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh')
self       = local('D:\\Development\\pemjh\\pemjh\\main.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge001/challenge001.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge001.py, line 10)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge001/challenge001.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge001/challenge001.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge001.py, line 10)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge001/challenge001.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge001/challenge001.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge001/challenge001.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005475950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge001\\challenge001.py', 10, 22, '    print challenge001()\n')), <traceback object at 0x0000000005512C48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005475950>
self       = <DoctestModule 'pemjh/challenge001/challenge001.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge001/challenge001.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge001/challenge001.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge001/challenge001.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge001\\challenge001.py')
modname = 'challenge001', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge001\challenge001.py", line 10
E               print challenge001()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge001'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge001')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge001\\challenge001.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge002/challenge002.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge002.py, line 16)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge002.py, line 16)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054756A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py', 16, 22, '    print challenge002()\n')), <traceback object at 0x0000000005575708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054756A8>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge002\challenge002.py", line 16
E               print challenge002()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge003/challenge003.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge003.py, line 29)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge003/challenge003.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge003/challenge003.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge003.py, line 29)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge003/challenge003.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge003/challenge003.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge003/challenge003.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005439B70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge003\\challenge003.py', 29, 22, '    print challenge003()\n')), <traceback object at 0x000000000556FCC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005439B70>
self       = <DoctestModule 'pemjh/challenge003/challenge003.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge003/challenge003.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge003/challenge003.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge003/challenge003.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge003\\challenge003.py')
modname = 'challenge003', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge003\challenge003.py", line 29
E               print challenge003()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge003'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge003')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge003\\challenge003.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge004/challenge004.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge004.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge004/challenge004.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge004/challenge004.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge004.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge004/challenge004.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge004/challenge004.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge004/challenge004.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054399D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge004\\challenge004.py', 37, 22, '    print challenge004()\n')), <traceback object at 0x000000000555BC48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054399D8>
self       = <DoctestModule 'pemjh/challenge004/challenge004.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge004/challenge004.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge004/challenge004.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge004/challenge004.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge004\\challenge004.py')
modname = 'challenge004', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge004\challenge004.py", line 37
E               print challenge004()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge004'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge004')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge004\\challenge004.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge005/challenge005.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge005.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge005/challenge005.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge005/challenge005.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge005.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge005/challenge005.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge005/challenge005.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge005/challenge005.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550C730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge005\\challenge005.py', 40, 22, '    print challenge005()\n')), <traceback object at 0x00000000054BEC08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550C730>
self       = <DoctestModule 'pemjh/challenge005/challenge005.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge005/challenge005.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge005/challenge005.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge005/challenge005.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge005\\challenge005.py')
modname = 'challenge005', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge005\challenge005.py", line 40
E               print challenge005()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge005'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge005')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge005\\challenge005.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge006/challenge006.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge006.py, line 24)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge006/challenge006.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge006/challenge006.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge006.py, line 24)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge006/challenge006.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge006/challenge006.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge006/challenge006.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550C950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge006\\challenge006.py', 24, 22, '    print challenge006()\n')), <traceback object at 0x0000000005564BC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550C950>
self       = <DoctestModule 'pemjh/challenge006/challenge006.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge006/challenge006.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge006/challenge006.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge006/challenge006.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge006\\challenge006.py')
modname = 'challenge006', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge006\challenge006.py", line 24
E               print challenge006()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge006'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge006')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge006\\challenge006.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge007/challenge007.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge007.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge007/challenge007.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge007/challenge007.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge007.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge007/challenge007.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge007/challenge007.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge007/challenge007.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550CB70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge007\\challenge007.py', 25, 22, '    print challenge007()\n')), <traceback object at 0x00000000054E1CC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550CB70>
self       = <DoctestModule 'pemjh/challenge007/challenge007.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge007/challenge007.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge007/challenge007.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge007/challenge007.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge007\\challenge007.py')
modname = 'challenge007', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge007\challenge007.py", line 25
E               print challenge007()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge007'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge007')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge007\\challenge007.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge008/challenge008.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge008.py, line 45)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge008/challenge008.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge008/challenge008.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge008.py, line 45)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge008/challenge008.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge008/challenge008.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge008/challenge008.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550CD90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge008\\challenge008.py', 45, 22, '    print challenge008()\n')), <traceback object at 0x00000000054A2B48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550CD90>
self       = <DoctestModule 'pemjh/challenge008/challenge008.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge008/challenge008.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge008/challenge008.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge008/challenge008.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge008\\challenge008.py')
modname = 'challenge008', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge008\challenge008.py", line 45
E               print challenge008()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge008'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge008')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge008\\challenge008.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge009/challenge009.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge009.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge009/challenge009.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge009/challenge009.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge009.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge009/challenge009.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge009/challenge009.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge009/challenge009.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550CE18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge009\\challenge009.py', 22, 22, '    print challenge009()\n')), <traceback object at 0x00000000054D9B08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550CE18>
self       = <DoctestModule 'pemjh/challenge009/challenge009.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge009/challenge009.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge009/challenge009.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge009/challenge009.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge009\\challenge009.py')
modname = 'challenge009', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge009\challenge009.py", line 22
E               print challenge009()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge009'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge009')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge009\\challenge009.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge010/challenge010.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge010.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge010/challenge010.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge010/challenge010.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge010.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge010/challenge010.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge010/challenge010.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge010/challenge010.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550CF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge010\\challenge010.py', 19, 22, '    print challenge010()\n')), <traceback object at 0x00000000054EAAC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000550CF28>
self       = <DoctestModule 'pemjh/challenge010/challenge010.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge010/challenge010.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge010/challenge010.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge010/challenge010.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge010\\challenge010.py')
modname = 'challenge010', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge010\challenge010.py", line 19
E               print challenge010()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge010'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge010')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge010\\challenge010.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge011/challenge011.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge011.py, line 62)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge011/challenge011.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge011/challenge011.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge011.py, line 62)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge011/challenge011.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge011/challenge011.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge011/challenge011.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge011\\challenge011.py', 62, 22, '    print challenge011()\n')), <traceback object at 0x00000000055E9A88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8488>
self       = <DoctestModule 'pemjh/challenge011/challenge011.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge011/challenge011.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge011/challenge011.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge011/challenge011.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge011\\challenge011.py')
modname = 'challenge011', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge011\challenge011.py", line 62
E               print challenge011()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge011'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge011')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge011\\challenge011.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge012/challenge012.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E86A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x0000000005640748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E86A8>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge012\\__pycache__\\challenge012.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x00000000054DC978>
__name__   = 'challenge012'
__package__ = ''
__spec__   = ModuleSpec(name='challenge012', loader=<_frozen_importlib.SourceFileLoader object at 0x00000000054DC978>, origin='D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
sqrt       = <built-in function sqrt>

pemjh\challenge012\challenge012.py:6: ImportError
_____________ ERROR collecting pemjh/challenge013/challenge013.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge013.py, line 115)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge013/challenge013.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge013/challenge013.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge013.py, line 115)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge013/challenge013.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge013/challenge013.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge013/challenge013.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge013\\challenge013.py', 115, 22, '    print challenge013()\n')), <traceback object at 0x00000000056BAF48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8620>
self       = <DoctestModule 'pemjh/challenge013/challenge013.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge013/challenge013.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge013/challenge013.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge013/challenge013.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge013\\challenge013.py')
modname = 'challenge013', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge013\challenge013.py", line 115
E               print challenge013()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge013'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge013')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge013\\challenge013.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge015/challenge015.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E88C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x000000000574A788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E88C8>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge015\\__pycache__\\challenge015.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x00000000055F4860>
__name__   = 'challenge015'
__package__ = ''
__spec__   = ModuleSpec(name='challenge015', loader=<_frozen_importlib.SourceFileLoader object at 0x00000000055F4860>, origin='D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

pemjh\challenge015\challenge015.py:5: ImportError
_____________ ERROR collecting pemjh/challenge016/challenge016.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge016.py, line 18)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge016/challenge016.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge016/challenge016.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge016.py, line 18)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge016/challenge016.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge016/challenge016.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge016/challenge016.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8BF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge016\\challenge016.py', 18, 22, '    print challenge016()\n')), <traceback object at 0x00000000055EC608>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8BF8>
self       = <DoctestModule 'pemjh/challenge016/challenge016.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge016/challenge016.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge016/challenge016.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge016/challenge016.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge016\\challenge016.py')
modname = 'challenge016', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge016\challenge016.py", line 18
E               print challenge016()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge016'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge016')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge016\\challenge016.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge017/challenge017.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge017.py, line 110)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge017/challenge017.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge017/challenge017.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge017.py, line 110)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge017/challenge017.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge017/challenge017.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge017/challenge017.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8D08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge017\\challenge017.py', 110, 22, '    print challenge017()\n')), <traceback object at 0x0000000005553948>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8D08>
self       = <DoctestModule 'pemjh/challenge017/challenge017.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge017/challenge017.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge017/challenge017.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge017/challenge017.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge017\\challenge017.py')
modname = 'challenge017', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge017\challenge017.py", line 110
E               print challenge017()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge017'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge017')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge017\\challenge017.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge018/challenge018.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge018.py, line 31)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge018.py, line 31)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py', 31, 22, '    print challenge018()\n')), <traceback object at 0x0000000005618788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8E18>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge018\challenge018.py", line 31
E               print challenge018()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge019/challenge019.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge019.py, line 46)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge019/challenge019.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge019/challenge019.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge019.py, line 46)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge019/challenge019.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge019/challenge019.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge019/challenge019.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge019\\challenge019.py', 46, 22, '    print challenge019()\n')), <traceback object at 0x00000000055ED788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054E8F28>
self       = <DoctestModule 'pemjh/challenge019/challenge019.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge019/challenge019.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge019/challenge019.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge019/challenge019.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge019\\challenge019.py')
modname = 'challenge019', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge019\challenge019.py", line 46
E               print challenge019()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge019'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge019')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge019\\challenge019.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge020/challenge020.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge020.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge020/challenge020.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge020/challenge020.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge020.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge020/challenge020.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge020/challenge020.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge020/challenge020.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge020\\challenge020.py', 22, 22, '    print challenge020()\n')), <traceback object at 0x000000000561C888>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558488>
self       = <DoctestModule 'pemjh/challenge020/challenge020.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge020/challenge020.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge020/challenge020.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge020/challenge020.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge020\\challenge020.py')
modname = 'challenge020', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge020\challenge020.py", line 22
E               print challenge020()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge020'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge020')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge020\\challenge020.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge021/challenge021.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge021.py, line 33)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge021.py, line 33)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055586A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py', 33, 22, '    print challenge021()\n')), <traceback object at 0x00000000054B4488>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055586A8>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge021\challenge021.py", line 33
E               print challenge021()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge022/challenge022.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge022.py, line 38)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge022/challenge022.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge022/challenge022.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge022.py, line 38)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge022/challenge022.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge022/challenge022.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge022/challenge022.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055588C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge022\\challenge022.py', 38, 22, '    print challenge022()\n')), <traceback object at 0x00000000054B07C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055588C8>
self       = <DoctestModule 'pemjh/challenge022/challenge022.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge022/challenge022.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge022/challenge022.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge022/challenge022.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge022\\challenge022.py')
modname = 'challenge022', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge022\challenge022.py", line 38
E               print challenge022()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge022'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge022')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge022\\challenge022.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge023/challenge023.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge023.py, line 34)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge023/challenge023.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge023/challenge023.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge023.py, line 34)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge023/challenge023.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge023/challenge023.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge023/challenge023.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558AE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge023\\challenge023.py', 34, 22, '    print challenge023()\n')), <traceback object at 0x0000000005512A88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558AE8>
self       = <DoctestModule 'pemjh/challenge023/challenge023.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge023/challenge023.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge023/challenge023.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge023/challenge023.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge023\\challenge023.py')
modname = 'challenge023', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge023\challenge023.py", line 34
E               print challenge023()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge023'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge023')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge023\\challenge023.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge024/challenge024.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge024.py, line 18)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge024.py, line 18)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558D08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py', 18, 22, '    print challenge024()\n')), <traceback object at 0x0000000005638148>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558D08>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge024\challenge024.py", line 18
E               print challenge024()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge025/challenge025.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge025.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge025.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py', 19, 22, '    print challenge025()\n')), <traceback object at 0x00000000055E7748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558F28>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge025\challenge025.py", line 19
E               print challenge025()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge026/challenge026.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge026.py, line 29)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge026/challenge026.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge026/challenge026.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge026.py, line 29)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge026/challenge026.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge026/challenge026.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge026/challenge026.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge026\\challenge026.py', 29, 22, '    print challenge026()\n')), <traceback object at 0x00000000055FD948>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005558D90>
self       = <DoctestModule 'pemjh/challenge026/challenge026.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge026/challenge026.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge026/challenge026.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge026/challenge026.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge026\\challenge026.py')
modname = 'challenge026', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge026\challenge026.py", line 29
E               print challenge026()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge026'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge026')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge026\\challenge026.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge027/challenge027.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge027.py, line 36)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge027.py, line 36)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py', 36, 22, '    print challenge027()\n')), <traceback object at 0x000000000569AF88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2400>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge027\challenge027.py", line 36
E               print challenge027()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge028/challenge028.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge028.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge028/challenge028.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge028/challenge028.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge028.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge028/challenge028.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge028/challenge028.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge028/challenge028.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge028\\challenge028.py', 19, 22, '    print challenge028()\n')), <traceback object at 0x000000000552E5C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2620>
self       = <DoctestModule 'pemjh/challenge028/challenge028.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge028/challenge028.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge028/challenge028.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge028/challenge028.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge028\\challenge028.py')
modname = 'challenge028', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge028\challenge028.py", line 19
E               print challenge028()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge028'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge028')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge028\\challenge028.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge029/challenge029.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge029.py, line 18)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge029/challenge029.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge029/challenge029.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge029.py, line 18)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge029/challenge029.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge029/challenge029.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge029/challenge029.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge029\\challenge029.py', 18, 22, '    print challenge029()\n')), <traceback object at 0x00000000054BE588>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2840>
self       = <DoctestModule 'pemjh/challenge029/challenge029.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge029/challenge029.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge029/challenge029.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge029/challenge029.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge029\\challenge029.py')
modname = 'challenge029', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge029\challenge029.py", line 18
E               print challenge029()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge029'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge029')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge029\\challenge029.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge030/challenge030.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge030.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge030/challenge030.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge030/challenge030.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge030.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge030/challenge030.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge030/challenge030.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge030/challenge030.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2A60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge030\\challenge030.py', 22, 22, '    print challenge030()\n')), <traceback object at 0x000000000561DB08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2A60>
self       = <DoctestModule 'pemjh/challenge030/challenge030.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge030/challenge030.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge030/challenge030.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge030/challenge030.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge030\\challenge030.py')
modname = 'challenge030', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge030\challenge030.py", line 22
E               print challenge030()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge030'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge030')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge030\\challenge030.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge031/challenge031.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge031.py, line 23)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge031/challenge031.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge031/challenge031.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge031.py, line 23)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge031/challenge031.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge031/challenge031.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge031/challenge031.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2C80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge031\\challenge031.py', 23, 22, '    print challenge031()\n')), <traceback object at 0x000000000553B148>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2C80>
self       = <DoctestModule 'pemjh/challenge031/challenge031.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge031/challenge031.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge031/challenge031.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge031/challenge031.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge031\\challenge031.py')
modname = 'challenge031', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge031\challenge031.py", line 23
E               print challenge031()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge031'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge031')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge031\\challenge031.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge032/challenge032.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge032.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge032.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py', 27, 22, '    print challenge032()\n')), <traceback object at 0x00000000056A61C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2EA0>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge032\challenge032.py", line 27
E               print challenge032()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge033/challenge033.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge033.py, line 48)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge033.py, line 48)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py', 48, 22, '    print challenge033()\n')), <traceback object at 0x0000000005736F88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000054C2F28>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge033\challenge033.py", line 48
E               print challenge033()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge034/challenge034.py _____________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge034.py, line 14)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge034.py, line 14)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AA378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py', 14, 20, '        print digits, factSum\n')), <traceback object at 0x00000000057261C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AA378>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge034\challenge034.py", line 14
E               print digits, factSum
E                          ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge035/challenge035.py _____________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge035.py, line 11)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge035.py, line 11)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AA510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py', 11, 18, '        print nStr\n')), <traceback object at 0x000000000547C488>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AA510>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge035\challenge035.py", line 11
E               print nStr
E                        ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge036/challenge036.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge036.py, line 30)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge036/challenge036.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge036/challenge036.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge036.py, line 30)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge036/challenge036.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge036/challenge036.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge036/challenge036.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AA6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge036\\challenge036.py', 30, 22, '    print challenge036()\n')), <traceback object at 0x00000000055795C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AA6A8>
self       = <DoctestModule 'pemjh/challenge036/challenge036.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge036/challenge036.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge036/challenge036.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge036/challenge036.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge036\\challenge036.py')
modname = 'challenge036', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge036\challenge036.py", line 30
E               print challenge036()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge036'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge036')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge036\\challenge036.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge037/challenge037.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge037.py, line 36)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge037.py, line 36)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AA8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py', 36, 22, '    print challenge037()\n')), <traceback object at 0x00000000054BFA08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AA8C8>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge037\challenge037.py", line 36
E               print challenge037()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge038/challenge038.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge038.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge038/challenge038.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge038/challenge038.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge038.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge038/challenge038.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge038/challenge038.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge038/challenge038.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AAAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge038\\challenge038.py', 27, 22, '    print challenge038()\n')), <traceback object at 0x00000000055EF0C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AAAE8>
self       = <DoctestModule 'pemjh/challenge038/challenge038.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge038/challenge038.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge038/challenge038.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge038/challenge038.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge038\\challenge038.py')
modname = 'challenge038', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge038\challenge038.py", line 27
E               print challenge038()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge038'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge038')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge038\\challenge038.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge039/challenge039.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge039.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge039/challenge039.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge039/challenge039.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge039.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge039/challenge039.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge039/challenge039.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge039/challenge039.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AAD08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge039\\challenge039.py', 40, 22, '    print challenge039()\n')), <traceback object at 0x00000000054B2E48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AAD08>
self       = <DoctestModule 'pemjh/challenge039/challenge039.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge039/challenge039.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge039/challenge039.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge039/challenge039.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge039\\challenge039.py')
modname = 'challenge039', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge039\challenge039.py", line 40
E               print challenge039()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge039'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge039')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge039\\challenge039.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge040/challenge040.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge040.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge040/challenge040.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge040/challenge040.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge040.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge040/challenge040.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge040/challenge040.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge040/challenge040.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AAF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge040\\challenge040.py', 19, 22, '    print challenge040()\n')), <traceback object at 0x00000000055C5188>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AAF28>
self       = <DoctestModule 'pemjh/challenge040/challenge040.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge040/challenge040.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge040/challenge040.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge040/challenge040.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge040\\challenge040.py')
modname = 'challenge040', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge040\challenge040.py", line 19
E               print challenge040()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge040'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge040')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge040\\challenge040.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge041/challenge041.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge041.py, line 23)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge041.py, line 23)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AAD90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py', 23, 22, '    print challenge041()\n')), <traceback object at 0x00000000055AC348>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056AAD90>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge041\challenge041.py", line 23
E               print challenge041()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge042/challenge042.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge042.py, line 42)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge042/challenge042.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge042/challenge042.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge042.py, line 42)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge042/challenge042.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge042/challenge042.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge042/challenge042.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CA400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge042\\challenge042.py', 42, 22, '    print challenge042()\n')), <traceback object at 0x00000000054BDF08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CA400>
self       = <DoctestModule 'pemjh/challenge042/challenge042.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge042/challenge042.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge042/challenge042.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge042/challenge042.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge042\\challenge042.py')
modname = 'challenge042', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge042\challenge042.py", line 42
E               print challenge042()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge042'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge042')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge042\\challenge042.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge043/challenge043.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge043.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge043.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CA620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py', 27, 22, '    print challenge043()\n')), <traceback object at 0x00000000055EDBC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CA620>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge043\challenge043.py", line 27
E               print challenge043()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge044/challenge044.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge044.py, line 35)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge044/challenge044.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge044/challenge044.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge044.py, line 35)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge044/challenge044.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge044/challenge044.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge044/challenge044.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CA840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge044\\challenge044.py', 35, 22, '    print challenge044()\n')), <traceback object at 0x000000000561FA88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CA840>
self       = <DoctestModule 'pemjh/challenge044/challenge044.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge044/challenge044.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge044/challenge044.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge044/challenge044.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge044\\challenge044.py')
modname = 'challenge044', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge044\challenge044.py", line 35
E               print challenge044()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge044'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge044')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge044\\challenge044.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge045/challenge045.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge045.py, line 35)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge045/challenge045.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge045/challenge045.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge045.py, line 35)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge045/challenge045.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge045/challenge045.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge045/challenge045.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAA60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge045\\challenge045.py', 35, 22, '    print challenge045()\n')), <traceback object at 0x0000000005730F08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAA60>
self       = <DoctestModule 'pemjh/challenge045/challenge045.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge045/challenge045.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge045/challenge045.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge045/challenge045.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge045\\challenge045.py')
modname = 'challenge045', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge045\challenge045.py", line 35
E               print challenge045()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge045'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge045')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge045\\challenge045.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge046/challenge046.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge046.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge046.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAC80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py', 32, 22, '    print challenge046()\n')), <traceback object at 0x0000000005542C08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAC80>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge046\challenge046.py", line 32
E               print challenge046()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge047/challenge047.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAEA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x00000000054BC888>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAEA0>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge047\\__pycache__\\challenge047.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x00000000054B8668>
__name__   = 'challenge047'
__package__ = ''
__spec__   = ModuleSpec(name='challenge047', loader=<_frozen_importlib.SourceFileLoader object at 0x00000000054B8668>, origin='D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
count      = <class 'itertools.count'>

pemjh\challenge047\challenge047.py:6: ImportError
_____________ ERROR collecting pemjh/challenge048/challenge048.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge048.py, line 10)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge048/challenge048.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge048/challenge048.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge048.py, line 10)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge048/challenge048.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge048/challenge048.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge048/challenge048.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAE18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge048\\challenge048.py', 10, 22, '    print challenge048()\n')), <traceback object at 0x0000000005772808>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAE18>
self       = <DoctestModule 'pemjh/challenge048/challenge048.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge048/challenge048.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge048/challenge048.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge048/challenge048.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge048\\challenge048.py')
modname = 'challenge048', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge048\challenge048.py", line 10
E               print challenge048()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge048'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge048')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge048\\challenge048.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge049/challenge049.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge049.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge049.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py', 32, 22, '    print challenge049()\n')), <traceback object at 0x0000000005581908>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056CAF28>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge049\challenge049.py", line 32
E               print challenge049()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge050/challenge050.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge050.py, line 30)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge050.py, line 30)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py', 30, 22, '    print challenge050()\n')), <traceback object at 0x000000000564B608>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9400>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge050\challenge050.py", line 30
E               print challenge050()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge051/challenge051.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge051.py, line 50)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge051.py, line 50)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py', 50, 22, '    print challenge051()\n')), <traceback object at 0x00000000056EAB08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9620>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge051\challenge051.py", line 50
E               print challenge051()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge052/challenge052.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge052.py, line 28)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge052/challenge052.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge052/challenge052.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge052.py, line 28)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge052/challenge052.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge052/challenge052.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge052/challenge052.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge052\\challenge052.py', 28, 22, '    print challenge052()\n')), <traceback object at 0x00000000054ED508>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9840>
self       = <DoctestModule 'pemjh/challenge052/challenge052.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge052/challenge052.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge052/challenge052.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge052/challenge052.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge052\\challenge052.py')
modname = 'challenge052', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge052\challenge052.py", line 28
E               print challenge052()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge052'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge052')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge052\\challenge052.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge053/challenge053.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge053.py, line 20)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge053.py, line 20)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9A60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py', 20, 22, '    print challenge053()\n')), <traceback object at 0x00000000055A96C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9A60>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge053\challenge053.py", line 20
E               print challenge053()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge054/challenge054.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge054.py, line 136)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge054/challenge054.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge054/challenge054.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge054.py, line 136)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge054/challenge054.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge054/challenge054.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge054/challenge054.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9C80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge054\\challenge054.py', 136, 22, '    print challenge054()\n')), <traceback object at 0x0000000005731A48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9C80>
self       = <DoctestModule 'pemjh/challenge054/challenge054.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge054/challenge054.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge054/challenge054.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge054/challenge054.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge054\\challenge054.py')
modname = 'challenge054', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge054\challenge054.py", line 136
E               print challenge054()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge054'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge054')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge054\\challenge054.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge055/challenge055.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge055.py, line 2)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge055/challenge055.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge055/challenge055.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge055.py, line 2)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge055/challenge055.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge055/challenge055.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge055/challenge055.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge055\\challenge055.py', 2, 16, '    workingN = `n`\n')), <traceback object at 0x00000000056734C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9EA0>
self       = <DoctestModule 'pemjh/challenge055/challenge055.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge055/challenge055.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge055/challenge055.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge055/challenge055.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge055\\challenge055.py')
modname = 'challenge055', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge055\challenge055.py", line 2
E               workingN = `n`
E                          ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge055'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge055')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge055\\challenge055.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge056/challenge056.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge056.py, line 17)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge056/challenge056.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge056/challenge056.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge056.py, line 17)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge056/challenge056.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge056/challenge056.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge056/challenge056.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge056\\challenge056.py', 17, 22, '    print challenge056()\n')), <traceback object at 0x00000000056774C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000055B9F28>
self       = <DoctestModule 'pemjh/challenge056/challenge056.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge056/challenge056.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge056/challenge056.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge056/challenge056.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge056\\challenge056.py')
modname = 'challenge056', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge056\challenge056.py", line 17
E               print challenge056()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge056'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge056')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge056\\challenge056.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge057/challenge057.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge057.py, line 21)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge057/challenge057.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge057/challenge057.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge057.py, line 21)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge057/challenge057.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge057/challenge057.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge057/challenge057.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge057\\challenge057.py', 21, 22, '    print challenge057()\n')), <traceback object at 0x0000000005531EC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2378>
self       = <DoctestModule 'pemjh/challenge057/challenge057.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge057/challenge057.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge057/challenge057.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge057/challenge057.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge057\\challenge057.py')
modname = 'challenge057', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge057\challenge057.py", line 21
E               print challenge057()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge057'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge057')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge057\\challenge057.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge058/challenge058.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x000000000577A688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2598>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge058\\__pycache__\\challenge058.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x00000000054B7390>
__name__   = 'challenge058'
__package__ = ''
__spec__   = ModuleSpec(name='challenge058', loader=<_frozen_importlib.SourceFileLoader object at 0x00000000054B7390>, origin='D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

pemjh\challenge058\challenge058.py:4: ImportError
_____________ ERROR collecting pemjh/challenge059/challenge059.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge059.py, line 49)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge059/challenge059.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge059/challenge059.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge059.py, line 49)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge059/challenge059.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge059/challenge059.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge059/challenge059.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge059\\challenge059.py', 49, 22, '    print challenge059()\n')), <traceback object at 0x000000000585DEC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2730>
self       = <DoctestModule 'pemjh/challenge059/challenge059.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge059/challenge059.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge059/challenge059.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge059/challenge059.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge059\\challenge059.py')
modname = 'challenge059', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge059\challenge059.py", line 49
E               print challenge059()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge059'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge059')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge059\\challenge059.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge060/challenge060.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge060.py, line 119)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge060.py, line 119)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py', 119, 22, '    print challenge060()\n')), <traceback object at 0x0000000005775548>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2840>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge060\challenge060.py", line 119
E               print challenge060()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge061/challenge061.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge061.py, line 104)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge061/challenge061.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge061/challenge061.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge061.py, line 104)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge061/challenge061.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge061/challenge061.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge061/challenge061.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2AE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge061\\challenge061.py', 104, 22, '    print challenge061()\n')), <traceback object at 0x000000000553C048>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2AE8>
self       = <DoctestModule 'pemjh/challenge061/challenge061.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge061/challenge061.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge061/challenge061.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge061/challenge061.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge061\\challenge061.py')
modname = 'challenge061', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge061\challenge061.py", line 104
E               print challenge061()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge061'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge061')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge061\\challenge061.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge062/challenge062.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge062.py, line 34)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge062/challenge062.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge062/challenge062.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge062.py, line 34)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge062/challenge062.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge062/challenge062.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge062/challenge062.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2D08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge062\\challenge062.py', 34, 22, '    print challenge062()\n')), <traceback object at 0x0000000005643AC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2D08>
self       = <DoctestModule 'pemjh/challenge062/challenge062.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge062/challenge062.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge062/challenge062.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge062/challenge062.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge062\\challenge062.py')
modname = 'challenge062', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge062\challenge062.py", line 34
E               print challenge062()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge062'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge062')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge062\\challenge062.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge063/challenge063.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge063.py, line 28)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge063/challenge063.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge063/challenge063.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge063.py, line 28)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge063/challenge063.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge063/challenge063.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge063/challenge063.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge063\\challenge063.py', 28, 22, '    print challenge063()\n')), <traceback object at 0x000000000568F948>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2F28>
self       = <DoctestModule 'pemjh/challenge063/challenge063.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge063/challenge063.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge063/challenge063.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge063/challenge063.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge063\\challenge063.py')
modname = 'challenge063', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge063\challenge063.py", line 28
E               print challenge063()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge063'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge063')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge063\\challenge063.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge064/challenge064.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge064.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge064.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py', 39, 22, '    print challenge064()\n')), <traceback object at 0x0000000005520988>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F2D90>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge064\challenge064.py", line 39
E               print challenge064()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge065/challenge065.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge065.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge065.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py', 37, 22, '    print challenge065()\n')), <traceback object at 0x0000000005703408>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0400>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge065\challenge065.py", line 37
E               print challenge065()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge066/challenge066.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge066.py, line 23)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge066.py, line 23)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py', 23, 22, '    print challenge066()\n')), <traceback object at 0x0000000005867C48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0620>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge066\challenge066.py", line 23
E               print challenge066()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge067/challenge067.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge067.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge067.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py', 25, 22, '    print challenge067()\n')), <traceback object at 0x0000000005578D48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0840>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge067\challenge067.py", line 25
E               print challenge067()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge068/challenge068.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge068.py, line 70)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge068/challenge068.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge068/challenge068.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge068.py, line 70)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge068/challenge068.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge068/challenge068.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge068/challenge068.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0A60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge068\\challenge068.py', 70, 22, '    print challenge068()\n')), <traceback object at 0x000000000574AB88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0A60>
self       = <DoctestModule 'pemjh/challenge068/challenge068.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge068/challenge068.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge068/challenge068.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge068/challenge068.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge068\\challenge068.py')
modname = 'challenge068', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge068\challenge068.py", line 70
E               print challenge068()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge068'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge068')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge068\\challenge068.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge069/challenge069.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge069.py, line 24)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge069.py, line 24)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0C80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py', 24, 22, '    print challenge069()\n')), <traceback object at 0x00000000056DD1C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0C80>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge069\challenge069.py", line 24
E               print challenge069()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge070/challenge070.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x00000000056F1048>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0EA0>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge070\\__pycache__\\challenge070.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x00000000055F2E10>
__name__   = 'challenge070'
__package__ = ''
__spec__   = ModuleSpec(name='challenge070', loader=<_frozen_importlib.SourceFileLoader object at 0x00000000055F2E10>, origin='D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

pemjh\challenge070\challenge070.py:4: ImportError
_____________ ERROR collecting pemjh/challenge071/challenge071.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge071.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge071/challenge071.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge071/challenge071.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge071.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge071/challenge071.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge071/challenge071.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge071/challenge071.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge071\\challenge071.py', 32, 22, '    print challenge071()\n')), <traceback object at 0x00000000055CC708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0E18>
self       = <DoctestModule 'pemjh/challenge071/challenge071.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge071/challenge071.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge071/challenge071.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge071/challenge071.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge071\\challenge071.py')
modname = 'challenge071', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge071\challenge071.py", line 32
E               print challenge071()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge071'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge071')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge071\\challenge071.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge072/challenge072.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge072.py, line 14)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge072.py, line 14)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py', 14, 22, '    print challenge072()\n')), <traceback object at 0x0000000005766848>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056F0F28>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge072\challenge072.py", line 14
E               print challenge072()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge073/challenge073.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge073.py, line 42)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge073.py, line 42)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py', 42, 22, '    print challenge073()\n')), <traceback object at 0x00000000055FEF48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5400>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge073\challenge073.py", line 42
E               print challenge073()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge074/challenge074.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge074.py, line 41)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge074/challenge074.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge074/challenge074.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge074.py, line 41)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge074/challenge074.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge074/challenge074.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge074/challenge074.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge074\\challenge074.py', 41, 22, '    print challenge074()\n')), <traceback object at 0x00000000055BF4C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5620>
self       = <DoctestModule 'pemjh/challenge074/challenge074.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge074/challenge074.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge074/challenge074.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge074/challenge074.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge074\\challenge074.py')
modname = 'challenge074', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge074\challenge074.py", line 41
E               print challenge074()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge074'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge074')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge074\\challenge074.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge075/challenge075.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge075.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge075.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py', 27, 22, '    print challenge075()\n')), <traceback object at 0x0000000005878648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5840>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge075\challenge075.py", line 27
E               print challenge075()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge076/challenge076.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge076.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge076/challenge076.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge076/challenge076.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge076.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge076/challenge076.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge076/challenge076.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge076/challenge076.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5A60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge076\\challenge076.py', 37, 22, '    print challenge076()\n')), <traceback object at 0x00000000055E8AC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5A60>
self       = <DoctestModule 'pemjh/challenge076/challenge076.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge076/challenge076.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge076/challenge076.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge076/challenge076.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge076\\challenge076.py')
modname = 'challenge076', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge076\challenge076.py", line 37
E               print challenge076()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge076'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge076')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge076\\challenge076.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge077/challenge077.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge077.py, line 34)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge077.py, line 34)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5C80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py', 34, 22, '    print challenge077()\n')), <traceback object at 0x0000000005862448>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5C80>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge077\challenge077.py", line 34
E               print challenge077()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge078/challenge078.py _____________

self = <CallInfo when='memocollect' exception: inconsistent use of tabs and spaces in indentation (challenge078.py, line 6)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge078/challenge078.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge078/challenge078.py'>>
self       = <CallInfo when='memocollect' exception: inconsistent use of tabs and spaces in indentation (challenge078.py, line 6)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge078/challenge078.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge078/challenge078.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge078/challenge078.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'TabError'>, TabError('inconsistent use of tabs and spaces in indentation', ('D:\\Development\\pemjh\\pemjh\\challenge078\\challenge078.py', 6, 19, '\tj, k, s = 1, 1, 0\n')), <traceback object at 0x00000000056A1B88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5EA0>
self       = <DoctestModule 'pemjh/challenge078/challenge078.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge078/challenge078.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge078/challenge078.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge078/challenge078.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge078\\challenge078.py')
modname = 'challenge078', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge078\challenge078.py", line 6
E               j, k, s = 1, 1, 0
E                               ^
E           TabError: inconsistent use of tabs and spaces in indentation

ensuresyspath = True
modname    = 'challenge078'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge078')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge078\\challenge078.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: TabError
_____________ ERROR collecting pemjh/challenge079/challenge079.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge079.py, line 15)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge079/challenge079.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge079/challenge079.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge079.py, line 15)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge079/challenge079.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge079/challenge079.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge079/challenge079.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge079\\challenge079.py', 15, 22, '    print challenge079()\n')), <traceback object at 0x00000000057ACCC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5F28>
self       = <DoctestModule 'pemjh/challenge079/challenge079.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge079/challenge079.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge079/challenge079.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge079/challenge079.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge079\\challenge079.py')
modname = 'challenge079', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge079\challenge079.py", line 15
E               print challenge079()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge079'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge079')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge079\\challenge079.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge080/challenge080.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge080.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge080/challenge080.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge080/challenge080.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge080.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge080/challenge080.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge080/challenge080.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge080/challenge080.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge080\\challenge080.py', 39, 22, '    print challenge080()\n')), <traceback object at 0x000000000558DB08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000056E5E18>
self       = <DoctestModule 'pemjh/challenge080/challenge080.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge080/challenge080.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge080/challenge080.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge080/challenge080.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge080\\challenge080.py')
modname = 'challenge080', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge080\challenge080.py", line 39
E               print challenge080()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge080'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge080')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge080\\challenge080.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge081/challenge081.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge081.py, line 46)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge081/challenge081.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge081/challenge081.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge081.py, line 46)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge081/challenge081.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge081/challenge081.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge081/challenge081.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge081\\challenge081.py', 46, 22, '    print challenge081()\n')), <traceback object at 0x00000000055D9208>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655510>
self       = <DoctestModule 'pemjh/challenge081/challenge081.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge081/challenge081.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge081/challenge081.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge081/challenge081.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge081\\challenge081.py')
modname = 'challenge081', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge081\challenge081.py", line 46
E               print challenge081()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge081'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge081')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge081\\challenge081.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge082/challenge082.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge082.py, line 53)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge082/challenge082.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge082/challenge082.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge082.py, line 53)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge082/challenge082.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge082/challenge082.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge082/challenge082.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge082\\challenge082.py', 53, 22, '    print challenge082()\n')), <traceback object at 0x00000000054C6DC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655730>
self       = <DoctestModule 'pemjh/challenge082/challenge082.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge082/challenge082.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge082/challenge082.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge082/challenge082.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge082\\challenge082.py')
modname = 'challenge082', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge082\challenge082.py", line 53
E               print challenge082()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge082'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge082')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge082\\challenge082.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge083/challenge083.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge083.py, line 80)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge083/challenge083.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge083/challenge083.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge083.py, line 80)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge083/challenge083.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge083/challenge083.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge083/challenge083.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge083\\challenge083.py', 80, 22, '    print challenge083()\n')), <traceback object at 0x0000000005683B08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655950>
self       = <DoctestModule 'pemjh/challenge083/challenge083.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge083/challenge083.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge083/challenge083.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge083/challenge083.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge083\\challenge083.py')
modname = 'challenge083', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge083\challenge083.py", line 80
E               print challenge083()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge083'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge083')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge083\\challenge083.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge084/challenge084.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge084.py, line 114)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge084/challenge084.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge084/challenge084.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge084.py, line 114)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge084/challenge084.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge084/challenge084.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge084/challenge084.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655B70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge084\\challenge084.py', 114, 22, '    print challenge084()\n')), <traceback object at 0x00000000055C3848>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655B70>
self       = <DoctestModule 'pemjh/challenge084/challenge084.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge084/challenge084.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge084/challenge084.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge084/challenge084.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge084\\challenge084.py')
modname = 'challenge084', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge084\challenge084.py", line 114
E               print challenge084()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge084'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge084')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge084\\challenge084.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge085/challenge085.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge085.py, line 51)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge085/challenge085.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge085/challenge085.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge085.py, line 51)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge085/challenge085.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge085/challenge085.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge085/challenge085.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge085\\challenge085.py', 51, 22, '    print challenge085()\n')), <traceback object at 0x000000000561B4C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655D90>
self       = <DoctestModule 'pemjh/challenge085/challenge085.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge085/challenge085.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge085/challenge085.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge085/challenge085.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge085\\challenge085.py')
modname = 'challenge085', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge085\challenge085.py", line 51
E               print challenge085()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge085'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge085')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge085\\challenge085.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge086/challenge086.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge086.py, line 44)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge086/challenge086.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge086/challenge086.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge086.py, line 44)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge086/challenge086.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge086/challenge086.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge086/challenge086.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge086\\challenge086.py', 44, 22, '    print challenge086()\n')), <traceback object at 0x0000000005719B88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655E18>
self       = <DoctestModule 'pemjh/challenge086/challenge086.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge086/challenge086.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge086/challenge086.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge086/challenge086.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge086\\challenge086.py')
modname = 'challenge086', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge086\challenge086.py", line 44
E               print challenge086()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge086'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge086')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge086\\challenge086.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge087/challenge087.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge087.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge087.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py', 40, 22, '    print challenge087()\n')), <traceback object at 0x0000000005757688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005655F28>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge087\challenge087.py", line 40
E               print challenge087()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge088/challenge088.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge088.py, line 36)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge088/challenge088.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge088/challenge088.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge088.py, line 36)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge088/challenge088.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge088/challenge088.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge088/challenge088.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge088\\challenge088.py', 36, 22, '    print challenge088()\n')), <traceback object at 0x0000000005873F08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881488>
self       = <DoctestModule 'pemjh/challenge088/challenge088.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge088/challenge088.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge088/challenge088.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge088/challenge088.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge088\\challenge088.py')
modname = 'challenge088', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge088\challenge088.py", line 36
E               print challenge088()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge088'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge088')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge088\\challenge088.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge089/challenge089.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge089.py, line 90)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge089/challenge089.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge089/challenge089.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge089.py, line 90)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge089/challenge089.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge089/challenge089.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge089/challenge089.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058816A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge089\\challenge089.py', 90, 22, '    print challenge089()\n')), <traceback object at 0x000000000555B3C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058816A8>
self       = <DoctestModule 'pemjh/challenge089/challenge089.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge089/challenge089.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge089/challenge089.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge089/challenge089.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge089\\challenge089.py')
modname = 'challenge089', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge089\challenge089.py", line 90
E               print challenge089()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge089'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge089')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge089\\challenge089.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge090/challenge090.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge090.py, line 132)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge090/challenge090.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge090/challenge090.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge090.py, line 132)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge090/challenge090.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge090/challenge090.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge090/challenge090.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058818C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge090\\challenge090.py', 132, 22, '    print challenge090()\n')), <traceback object at 0x0000000005821208>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058818C8>
self       = <DoctestModule 'pemjh/challenge090/challenge090.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge090/challenge090.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge090/challenge090.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge090/challenge090.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge090\\challenge090.py')
modname = 'challenge090', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge090\challenge090.py", line 132
E               print challenge090()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge090'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge090')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge090\\challenge090.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge091/challenge091.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge091.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge091/challenge091.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge091/challenge091.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge091.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge091/challenge091.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge091/challenge091.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge091/challenge091.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881AE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge091\\challenge091.py', 40, 22, '    print challenge091()\n')), <traceback object at 0x00000000055DB388>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881AE8>
self       = <DoctestModule 'pemjh/challenge091/challenge091.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge091/challenge091.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge091/challenge091.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge091/challenge091.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge091\\challenge091.py')
modname = 'challenge091', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge091\challenge091.py", line 40
E               print challenge091()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge091'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge091')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge091\\challenge091.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge092/challenge092.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge092.py, line 124)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge092.py, line 124)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881D08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py', 124, 22, '    print challenge092()\n')), <traceback object at 0x00000000054C6F48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881D08>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge092\challenge092.py", line 124
E               print challenge092()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge093/challenge093.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge093.py, line 102)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge093/challenge093.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge093/challenge093.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge093.py, line 102)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge093/challenge093.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge093/challenge093.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge093/challenge093.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge093\\challenge093.py', 102, 22, '    print challenge093()\n')), <traceback object at 0x00000000057BF188>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881F28>
self       = <DoctestModule 'pemjh/challenge093/challenge093.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge093/challenge093.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge093/challenge093.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge093/challenge093.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge093\\challenge093.py')
modname = 'challenge093', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge093\challenge093.py", line 102
E               print challenge093()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge093'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge093')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge093\\challenge093.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge094/challenge094.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge094.py, line 54)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge094/challenge094.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge094/challenge094.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge094.py, line 54)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge094/challenge094.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge094/challenge094.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge094/challenge094.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge094\\challenge094.py', 54, 22, '    print challenge094()\n')), <traceback object at 0x00000000055AC848>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005881D90>
self       = <DoctestModule 'pemjh/challenge094/challenge094.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge094/challenge094.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge094/challenge094.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge094/challenge094.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge094\\challenge094.py')
modname = 'challenge094', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge094\challenge094.py", line 54
E               print challenge094()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge094'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge094')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge094\\challenge094.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge095/challenge095.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge095.py, line 61)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge095/challenge095.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge095/challenge095.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge095.py, line 61)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge095/challenge095.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge095/challenge095.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge095/challenge095.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583E400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge095\\challenge095.py', 61, 22, '    print challenge095()\n')), <traceback object at 0x00000000055E3C48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583E400>
self       = <DoctestModule 'pemjh/challenge095/challenge095.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge095/challenge095.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge095/challenge095.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge095/challenge095.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge095\\challenge095.py')
modname = 'challenge095', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge095\challenge095.py", line 61
E               print challenge095()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge095'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge095')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge095\\challenge095.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge096/challenge096.py _____________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge096.py, line 271)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge096/challenge096.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge096/challenge096.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge096.py, line 271)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge096/challenge096.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge096/challenge096.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge096/challenge096.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583E620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge096\\challenge096.py', 271, 50, '                print "!!!!!!!!BROKEN!!!!!!!!!!!!"\n')), <traceback object at 0x0000000005646088>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583E620>
self       = <DoctestModule 'pemjh/challenge096/challenge096.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge096/challenge096.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge096/challenge096.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge096/challenge096.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge096\\challenge096.py')
modname = 'challenge096', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge096\challenge096.py", line 271
E               print "!!!!!!!!BROKEN!!!!!!!!!!!!"
E                                                ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'challenge096'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge096')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge096\\challenge096.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge097/challenge097.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge097.py, line 8)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge097/challenge097.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge097/challenge097.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge097.py, line 8)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge097/challenge097.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge097/challenge097.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge097/challenge097.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583E7B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge097\\challenge097.py', 8, 22, '    print challenge097()\n')), <traceback object at 0x0000000005686C88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583E7B8>
self       = <DoctestModule 'pemjh/challenge097/challenge097.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge097/challenge097.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge097/challenge097.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge097/challenge097.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge097\\challenge097.py')
modname = 'challenge097', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge097\challenge097.py", line 8
E               print challenge097()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge097'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge097')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge097\\challenge097.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge098/challenge098.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge098.py, line 98)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge098/challenge098.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge098/challenge098.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge098.py, line 98)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge098/challenge098.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge098/challenge098.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge098/challenge098.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583E9D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge098\\challenge098.py', 98, 22, '    print challenge098()\n')), <traceback object at 0x00000000058596C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583E9D8>
self       = <DoctestModule 'pemjh/challenge098/challenge098.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge098/challenge098.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge098/challenge098.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge098/challenge098.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge098\\challenge098.py')
modname = 'challenge098', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge098\challenge098.py", line 98
E               print challenge098()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge098'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge098')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge098\\challenge098.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge099/challenge099.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge099.py, line 20)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge099/challenge099.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge099/challenge099.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge099.py, line 20)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge099/challenge099.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge099/challenge099.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge099/challenge099.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583EBF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge099\\challenge099.py', 20, 22, '    print challenge099()\n')), <traceback object at 0x00000000057316C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583EBF8>
self       = <DoctestModule 'pemjh/challenge099/challenge099.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge099/challenge099.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge099/challenge099.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge099/challenge099.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge099\\challenge099.py')
modname = 'challenge099', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge099\challenge099.py", line 20
E               print challenge099()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge099'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge099')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge099\\challenge099.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge100/challenge100.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge100.py, line 11)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge100/challenge100.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge100/challenge100.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge100.py, line 11)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge100/challenge100.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge100/challenge100.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge100/challenge100.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583EE18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge100\\challenge100.py', 11, 22, '    print challenge100()\n')), <traceback object at 0x0000000005879348>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583EE18>
self       = <DoctestModule 'pemjh/challenge100/challenge100.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge100/challenge100.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge100/challenge100.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge100/challenge100.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge100\\challenge100.py')
modname = 'challenge100', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge100\challenge100.py", line 11
E               print challenge100()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge100'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge100')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge100\\challenge100.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge101/challenge101.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge101.py, line 43)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge101/challenge101.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge101/challenge101.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge101.py, line 43)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge101/challenge101.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge101/challenge101.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge101/challenge101.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583EEA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge101\\challenge101.py', 43, 22, '    print challenge101()\n')), <traceback object at 0x0000000005835D88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000583EEA0>
self       = <DoctestModule 'pemjh/challenge101/challenge101.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge101/challenge101.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge101/challenge101.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge101/challenge101.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge101\\challenge101.py')
modname = 'challenge101', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge101\challenge101.py", line 43
E               print challenge101()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge101'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge101')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge101\\challenge101.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge102/challenge102.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge102.py, line 59)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge102/challenge102.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge102/challenge102.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge102.py, line 59)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge102/challenge102.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge102/challenge102.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge102/challenge102.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576D2F0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge102\\challenge102.py', 59, 22, '    print challenge102()\n')), <traceback object at 0x00000000057338C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576D2F0>
self       = <DoctestModule 'pemjh/challenge102/challenge102.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge102/challenge102.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge102/challenge102.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge102/challenge102.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge102\\challenge102.py')
modname = 'challenge102', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge102\challenge102.py", line 59
E               print challenge102()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge102'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge102')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge102\\challenge102.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge103/challenge103.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge103.py, line 61)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge103/challenge103.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge103/challenge103.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge103.py, line 61)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge103/challenge103.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge103/challenge103.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge103/challenge103.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576D510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge103\\challenge103.py', 61, 22, '    print challenge103()\n')), <traceback object at 0x0000000005490BC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576D510>
self       = <DoctestModule 'pemjh/challenge103/challenge103.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge103/challenge103.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge103/challenge103.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge103/challenge103.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge103\\challenge103.py')
modname = 'challenge103', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge103\challenge103.py", line 61
E               print challenge103()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge103'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge103')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge103\\challenge103.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge104/challenge104.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge104.py, line 50)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge104.py, line 50)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576D730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py', 50, 22, '    print challenge104()\n')), <traceback object at 0x0000000005722788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576D730>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge104\challenge104.py", line 50
E               print challenge104()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge105/challenge105.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge105.py, line 65)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge105/challenge105.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge105/challenge105.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge105.py, line 65)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge105/challenge105.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge105/challenge105.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge105/challenge105.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576D950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge105\\challenge105.py', 65, 22, '    print challenge105()\n')), <traceback object at 0x0000000005862408>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576D950>
self       = <DoctestModule 'pemjh/challenge105/challenge105.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge105/challenge105.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge105/challenge105.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge105/challenge105.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge105\\challenge105.py')
modname = 'challenge105', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge105\challenge105.py", line 65
E               print challenge105()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge105'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge105')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge105\\challenge105.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge106/challenge106.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge106.py, line 68)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge106/challenge106.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge106/challenge106.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge106.py, line 68)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge106/challenge106.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge106/challenge106.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge106/challenge106.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576DB70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge106\\challenge106.py', 68, 22, '    print challenge106()\n')), <traceback object at 0x00000000057A95C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576DB70>
self       = <DoctestModule 'pemjh/challenge106/challenge106.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge106/challenge106.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge106/challenge106.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge106/challenge106.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge106\\challenge106.py')
modname = 'challenge106', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge106\challenge106.py", line 68
E               print challenge106()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge106'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge106')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge106\\challenge106.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge107/challenge107.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge107.py, line 70)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge107/challenge107.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge107/challenge107.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge107.py, line 70)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge107/challenge107.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge107/challenge107.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge107/challenge107.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576DD90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge107\\challenge107.py', 70, 22, '    print challenge107()\n')), <traceback object at 0x00000000056CB088>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576DD90>
self       = <DoctestModule 'pemjh/challenge107/challenge107.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge107/challenge107.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge107/challenge107.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge107/challenge107.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge107\\challenge107.py')
modname = 'challenge107', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge107\challenge107.py", line 70
E               print challenge107()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge107'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge107')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge107\\challenge107.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge108/challenge108.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge108.py, line 59)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge108.py, line 59)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576DE18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py', 59, 22, '    print challenge108()\n')), <traceback object at 0x00000000057E7C48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576DE18>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge108\challenge108.py", line 59
E               print challenge108()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge109/challenge109.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge109.py, line 50)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge109/challenge109.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge109/challenge109.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge109.py, line 50)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge109/challenge109.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge109/challenge109.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge109/challenge109.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576DF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge109\\challenge109.py', 50, 22, '    print challenge109()\n')), <traceback object at 0x0000000005635708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000576DF28>
self       = <DoctestModule 'pemjh/challenge109/challenge109.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge109/challenge109.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge109/challenge109.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge109/challenge109.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge109\\challenge109.py')
modname = 'challenge109', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge109\challenge109.py", line 50
E               print challenge109()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge109'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge109')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge109\\challenge109.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge110/challenge110.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge110.py, line 59)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge110.py, line 59)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py', 59, 22, '    print challenge110()\n')), <traceback object at 0x00000000057F7908>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802488>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge110\challenge110.py", line 59
E               print challenge110()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge111/challenge111.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge111.py, line 54)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge111.py, line 54)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058026A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py', 54, 22, '    print challenge111()\n')), <traceback object at 0x00000000055F9288>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058026A8>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge111\challenge111.py", line 54
E               print challenge111()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge112/challenge112.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge112.py, line 48)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge112/challenge112.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge112/challenge112.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge112.py, line 48)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge112/challenge112.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge112/challenge112.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge112/challenge112.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058028C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge112\\challenge112.py', 48, 22, '    print challenge112()\n')), <traceback object at 0x000000000589D648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058028C8>
self       = <DoctestModule 'pemjh/challenge112/challenge112.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge112/challenge112.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge112/challenge112.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge112/challenge112.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge112\\challenge112.py')
modname = 'challenge112', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge112\challenge112.py", line 48
E               print challenge112()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge112'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge112')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge112\\challenge112.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge113/challenge113.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge113.py, line 61)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge113.py, line 61)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802AE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py', 61, 22, '    print challenge113()\n')), <traceback object at 0x000000000556A848>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802AE8>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge113\challenge113.py", line 61
E               print challenge113()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge114/challenge114.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge114.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge114/challenge114.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge114/challenge114.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge114.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge114/challenge114.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge114/challenge114.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge114/challenge114.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802D08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge114\\challenge114.py', 37, 22, '    print challenge114()\n')), <traceback object at 0x0000000005683448>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802D08>
self       = <DoctestModule 'pemjh/challenge114/challenge114.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge114/challenge114.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge114/challenge114.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge114/challenge114.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge114\\challenge114.py')
modname = 'challenge114', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge114\challenge114.py", line 37
E               print challenge114()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge114'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge114')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge114\\challenge114.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge115/challenge115.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge115.py, line 43)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge115/challenge115.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge115/challenge115.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge115.py, line 43)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge115/challenge115.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge115/challenge115.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge115/challenge115.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge115\\challenge115.py', 43, 22, '    print challenge115()\n')), <traceback object at 0x000000000563AC08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802F28>
self       = <DoctestModule 'pemjh/challenge115/challenge115.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge115/challenge115.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge115/challenge115.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge115/challenge115.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge115\\challenge115.py')
modname = 'challenge115', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge115\challenge115.py", line 43
E               print challenge115()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge115'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge115')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge115\\challenge115.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge116/challenge116.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge116.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge116/challenge116.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge116/challenge116.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge116.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge116/challenge116.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge116/challenge116.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge116/challenge116.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge116\\challenge116.py', 37, 22, '    print challenge116()\n')), <traceback object at 0x0000000005852A88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005802D90>
self       = <DoctestModule 'pemjh/challenge116/challenge116.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge116/challenge116.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge116/challenge116.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge116/challenge116.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge116\\challenge116.py')
modname = 'challenge116', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge116\challenge116.py", line 37
E               print challenge116()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge116'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge116')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge116\\challenge116.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge117/challenge117.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge117.py, line 33)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge117/challenge117.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge117/challenge117.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge117.py, line 33)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge117/challenge117.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge117/challenge117.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge117/challenge117.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579D400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge117\\challenge117.py', 33, 22, '    print challenge117()\n')), <traceback object at 0x00000000057EAF08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579D400>
self       = <DoctestModule 'pemjh/challenge117/challenge117.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge117/challenge117.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge117/challenge117.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge117/challenge117.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge117\\challenge117.py')
modname = 'challenge117', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge117\challenge117.py", line 33
E               print challenge117()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge117'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge117')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge117\\challenge117.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge118/challenge118.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge118.py, line 52)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge118.py, line 52)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579D620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py', 52, 22, '    print challenge118()\n')), <traceback object at 0x0000000005649C08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579D620>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge118\challenge118.py", line 52
E               print challenge118()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge119/challenge119.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge119.py, line 33)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge119/challenge119.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge119/challenge119.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge119.py, line 33)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge119/challenge119.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge119/challenge119.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge119/challenge119.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579D840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge119\\challenge119.py', 33, 22, '    print challenge119()\n')), <traceback object at 0x0000000005534348>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579D840>
self       = <DoctestModule 'pemjh/challenge119/challenge119.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge119/challenge119.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge119/challenge119.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge119/challenge119.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge119\\challenge119.py')
modname = 'challenge119', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge119\challenge119.py", line 33
E               print challenge119()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge119'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge119')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge119\\challenge119.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge120/challenge120.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge120.py, line 15)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge120/challenge120.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge120/challenge120.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge120.py, line 15)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge120/challenge120.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge120/challenge120.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge120/challenge120.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579DA60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge120\\challenge120.py', 15, 22, '    print challenge120()\n')), <traceback object at 0x00000000055A4D48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579DA60>
self       = <DoctestModule 'pemjh/challenge120/challenge120.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge120/challenge120.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge120/challenge120.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge120/challenge120.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge120\\challenge120.py')
modname = 'challenge120', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge120\challenge120.py", line 15
E               print challenge120()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge120'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge120')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge120\\challenge120.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge121/challenge121.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge121.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge121.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579DC80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py', 39, 22, '    print challenge121()\n')), <traceback object at 0x00000000056D8188>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579DC80>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge121\challenge121.py", line 39
E               print challenge121()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge122/challenge122.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge122.py, line 28)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge122/challenge122.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge122/challenge122.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge122.py, line 28)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge122/challenge122.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge122/challenge122.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge122/challenge122.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579DEA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge122\\challenge122.py', 28, 22, '    print challenge122()\n')), <traceback object at 0x00000000058A7208>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579DEA0>
self       = <DoctestModule 'pemjh/challenge122/challenge122.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge122/challenge122.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge122/challenge122.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge122/challenge122.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge122\\challenge122.py')
modname = 'challenge122', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge122\challenge122.py", line 28
E               print challenge122()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge122'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge122')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge122\\challenge122.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge123/challenge123.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge123.py, line 20)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge123.py, line 20)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579DF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py', 20, 22, '    print challenge123()\n')), <traceback object at 0x0000000005798A48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000579DF28>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge123\challenge123.py", line 20
E               print challenge123()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge124/challenge124.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge124.py, line 41)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge124.py, line 41)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py', 41, 22, '    print challenge124()\n')), <traceback object at 0x000000000560BDC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7378>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge124\challenge124.py", line 41
E               print challenge124()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge125/challenge125.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge125.py, line 29)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge125/challenge125.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge125/challenge125.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge125.py, line 29)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge125/challenge125.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge125/challenge125.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge125/challenge125.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge125\\challenge125.py', 29, 22, '    print challenge125()\n')), <traceback object at 0x000000000552B688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7598>
self       = <DoctestModule 'pemjh/challenge125/challenge125.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge125/challenge125.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge125/challenge125.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge125/challenge125.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge125\\challenge125.py')
modname = 'challenge125', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge125\challenge125.py", line 29
E               print challenge125()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge125'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge125')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge125\\challenge125.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge126/challenge126.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge126.py, line 41)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge126/challenge126.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge126/challenge126.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge126.py, line 41)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge126/challenge126.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge126/challenge126.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge126/challenge126.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C77B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge126\\challenge126.py', 41, 22, '    print challenge126()\n')), <traceback object at 0x0000000005610408>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C77B8>
self       = <DoctestModule 'pemjh/challenge126/challenge126.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge126/challenge126.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge126/challenge126.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge126/challenge126.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge126\\challenge126.py')
modname = 'challenge126', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge126\challenge126.py", line 41
E               print challenge126()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge126'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge126')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge126\\challenge126.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge127/challenge127.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge127.py, line 35)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge127.py, line 35)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C79D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py', 35, 22, '    print challenge127()\n')), <traceback object at 0x000000000560F808>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C79D8>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge127\challenge127.py", line 35
E               print challenge127()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge128/challenge128.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge128.py, line 33)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge128.py, line 33)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7BF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py', 33, 22, '    print challenge128()\n')), <traceback object at 0x0000000005553E08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7BF8>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge128\challenge128.py", line 33
E               print challenge128()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge129/challenge129.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge129.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge129/challenge129.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge129/challenge129.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge129.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge129/challenge129.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge129/challenge129.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge129/challenge129.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge129\\challenge129.py', 27, 22, '    print challenge129()\n')), <traceback object at 0x0000000005812108>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7E18>
self       = <DoctestModule 'pemjh/challenge129/challenge129.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge129/challenge129.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge129/challenge129.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge129/challenge129.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge129\\challenge129.py')
modname = 'challenge129', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge129\challenge129.py", line 27
E               print challenge129()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge129'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge129')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge129\\challenge129.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge130/challenge130.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge130.py, line 30)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge130.py, line 30)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py', 30, 22, '    print challenge130()\n')), <traceback object at 0x00000000055DA748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000057C7EA0>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge130\challenge130.py", line 30
E               print challenge130()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge131/challenge131.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge131.py, line 41)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge131.py, line 41)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C02F0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py', 41, 22, '    print challenge131()\n')), <traceback object at 0x000000000698C048>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C02F0>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge131\challenge131.py", line 41
E               print challenge131()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge132/challenge132.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge132.py, line 24)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge132.py, line 24)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py', 24, 22, '    print challenge132()\n')), <traceback object at 0x00000000068E3E08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0510>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge132\challenge132.py", line 24
E               print challenge132()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge133/challenge133.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge133.py, line 16)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge133.py, line 16)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py', 16, 22, '    print challenge133()\n')), <traceback object at 0x0000000005674A48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0730>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge133\challenge133.py", line 16
E               print challenge133()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge134/challenge134.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge134.py, line 72)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge134.py, line 72)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py', 72, 22, '    print challenge134()\n')), <traceback object at 0x0000000005872488>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0950>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge134\challenge134.py", line 72
E               print challenge134()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge135/challenge135.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge135.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge135/challenge135.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge135/challenge135.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge135.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge135/challenge135.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge135/challenge135.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge135/challenge135.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0B70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge135\\challenge135.py', 25, 22, '    print challenge135()\n')), <traceback object at 0x00000000057A72C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0B70>
self       = <DoctestModule 'pemjh/challenge135/challenge135.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge135/challenge135.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge135/challenge135.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge135/challenge135.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge135\\challenge135.py')
modname = 'challenge135', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge135\challenge135.py", line 25
E               print challenge135()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge135'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge135')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge135\\challenge135.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge136/challenge136.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge136.py, line 26)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge136.py, line 26)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py', 26, 22, '    print challenge136()\n')), <traceback object at 0x0000000006926EC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0D90>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge136\challenge136.py", line 26
E               print challenge136()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge137/challenge137.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge137.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge137/challenge137.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge137/challenge137.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge137.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge137/challenge137.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge137/challenge137.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge137/challenge137.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge137\\challenge137.py', 25, 22, '    print challenge137()\n')), <traceback object at 0x0000000005664A08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0E18>
self       = <DoctestModule 'pemjh/challenge137/challenge137.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge137/challenge137.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge137/challenge137.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge137/challenge137.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge137\\challenge137.py')
modname = 'challenge137', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge137\challenge137.py", line 25
E               print challenge137()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge137'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge137')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge137\\challenge137.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge138/challenge138.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge138.py, line 34)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge138.py, line 34)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py', 34, 22, '    print challenge138()\n')), <traceback object at 0x000000000692A308>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058C0F28>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge138\challenge138.py", line 34
E               print challenge138()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge139/challenge139.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge139.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge139.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BD488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py', 19, 22, '    print challenge139()\n')), <traceback object at 0x000000000692EC08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BD488>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge139\challenge139.py", line 19
E               print challenge139()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge142/challenge142.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge142.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge142/challenge142.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge142/challenge142.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge142.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge142/challenge142.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge142/challenge142.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge142/challenge142.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BD6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge142\\challenge142.py', 39, 22, '    print challenge142()\n')), <traceback object at 0x00000000056A0788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BD6A8>
self       = <DoctestModule 'pemjh/challenge142/challenge142.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge142/challenge142.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge142/challenge142.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge142/challenge142.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge142\\challenge142.py')
modname = 'challenge142', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge142\challenge142.py", line 39
E               print challenge142()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge142'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge142')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge142\\challenge142.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge144/challenge144.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge144.py, line 72)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge144/challenge144.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge144/challenge144.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge144.py, line 72)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge144/challenge144.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge144/challenge144.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge144/challenge144.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BD8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge144\\challenge144.py', 72, 22, '    print challenge144()\n')), <traceback object at 0x0000000006A02F08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BD8C8>
self       = <DoctestModule 'pemjh/challenge144/challenge144.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge144/challenge144.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge144/challenge144.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge144/challenge144.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge144\\challenge144.py')
modname = 'challenge144', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge144\challenge144.py", line 72
E               print challenge144()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge144'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge144')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge144\\challenge144.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge145/challenge145.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge145.py, line 15)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge145/challenge145.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge145/challenge145.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge145.py, line 15)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge145/challenge145.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge145/challenge145.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge145/challenge145.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BDAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge145\\challenge145.py', 15, 22, '    print challenge145()\n')), <traceback object at 0x0000000005870248>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BDAE8>
self       = <DoctestModule 'pemjh/challenge145/challenge145.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge145/challenge145.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge145/challenge145.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge145/challenge145.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge145\\challenge145.py')
modname = 'challenge145', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge145\challenge145.py", line 15
E               print challenge145()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge145'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge145')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge145\\challenge145.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge146/challenge146.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge146.py, line 31)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge146/challenge146.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge146/challenge146.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge146.py, line 31)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge146/challenge146.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge146/challenge146.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge146/challenge146.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BDD08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge146\\challenge146.py', 31, 22, '    print challenge146()\n')), <traceback object at 0x00000000057C1E48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BDD08>
self       = <DoctestModule 'pemjh/challenge146/challenge146.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge146/challenge146.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge146/challenge146.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge146/challenge146.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge146\\challenge146.py')
modname = 'challenge146', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge146\challenge146.py", line 31
E               print challenge146()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge146'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge146')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge146\\challenge146.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge148/challenge148.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge148.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge148/challenge148.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge148/challenge148.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge148.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge148/challenge148.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge148/challenge148.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge148/challenge148.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BDF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge148\\challenge148.py', 39, 22, '    print challenge148()\n')), <traceback object at 0x0000000005739A08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BDF28>
self       = <DoctestModule 'pemjh/challenge148/challenge148.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge148/challenge148.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge148/challenge148.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge148/challenge148.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge148\\challenge148.py')
modname = 'challenge148', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge148\challenge148.py", line 39
E               print challenge148()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge148'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge148')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge148\\challenge148.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge149/challenge149.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge149.py, line 51)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge149/challenge149.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge149/challenge149.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge149.py, line 51)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge149/challenge149.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge149/challenge149.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge149/challenge149.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BDD90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge149\\challenge149.py', 51, 22, '    print challenge149()\n')), <traceback object at 0x000000000581D7C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000058BDD90>
self       = <DoctestModule 'pemjh/challenge149/challenge149.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge149/challenge149.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge149/challenge149.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge149/challenge149.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge149\\challenge149.py')
modname = 'challenge149', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge149\challenge149.py", line 51
E               print challenge149()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge149'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge149')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge149\\challenge149.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge151/challenge151.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge151.py, line 28)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge151/challenge151.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge151/challenge151.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge151.py, line 28)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge151/challenge151.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge151/challenge151.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge151/challenge151.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge151\\challenge151.py', 28, 22, '    print challenge151()\n')), <traceback object at 0x00000000069EB908>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972400>
self       = <DoctestModule 'pemjh/challenge151/challenge151.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge151/challenge151.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge151/challenge151.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge151/challenge151.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge151\\challenge151.py')
modname = 'challenge151', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge151\challenge151.py", line 28
E               print challenge151()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge151'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge151')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge151\\challenge151.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge162/challenge162.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge162.py, line 11)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge162/challenge162.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge162/challenge162.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge162.py, line 11)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge162/challenge162.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge162/challenge162.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge162/challenge162.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge162\\challenge162.py', 11, 22, '    print challenge162()\n')), <traceback object at 0x0000000006905048>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972620>
self       = <DoctestModule 'pemjh/challenge162/challenge162.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge162/challenge162.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge162/challenge162.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge162/challenge162.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge162\\challenge162.py')
modname = 'challenge162', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge162\challenge162.py", line 11
E               print challenge162()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge162'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge162')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge162\\challenge162.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge164/challenge164.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge164.py, line 36)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge164/challenge164.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge164/challenge164.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge164.py, line 36)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge164/challenge164.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge164/challenge164.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge164/challenge164.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge164\\challenge164.py', 36, 22, '    print challenge164()\n')), <traceback object at 0x00000000058A09C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972840>
self       = <DoctestModule 'pemjh/challenge164/challenge164.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge164/challenge164.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge164/challenge164.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge164/challenge164.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge164\\challenge164.py')
modname = 'challenge164', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge164\challenge164.py", line 36
E               print challenge164()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge164'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge164')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge164\\challenge164.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge166/challenge166.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge166.py, line 73)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge166/challenge166.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge166/challenge166.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge166.py, line 73)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge166/challenge166.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge166/challenge166.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge166/challenge166.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972A60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge166\\challenge166.py', 73, 22, '    print challenge166()\n')), <traceback object at 0x000000000574DC08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972A60>
self       = <DoctestModule 'pemjh/challenge166/challenge166.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge166/challenge166.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge166/challenge166.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge166/challenge166.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge166\\challenge166.py')
modname = 'challenge166', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge166\challenge166.py", line 73
E               print challenge166()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge166'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge166')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge166\\challenge166.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge173/challenge173.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge173.py, line 35)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge173/challenge173.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge173/challenge173.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge173.py, line 35)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge173/challenge173.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge173/challenge173.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge173/challenge173.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972C80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge173\\challenge173.py', 35, 22, '    print challenge173()\n')), <traceback object at 0x000000000586AF08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972C80>
self       = <DoctestModule 'pemjh/challenge173/challenge173.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge173/challenge173.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge173/challenge173.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge173/challenge173.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge173\\challenge173.py')
modname = 'challenge173', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge173\challenge173.py", line 35
E               print challenge173()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge173'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge173')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge173\\challenge173.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge174/challenge174.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge174.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge174.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py', 40, 22, '    print challenge174()\n')), <traceback object at 0x0000000005851388>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972EA0>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge174\challenge174.py", line 40
E               print challenge174()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge179/challenge179.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge179.py, line 26)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge179/challenge179.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge179/challenge179.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge179.py, line 26)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge179/challenge179.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge179/challenge179.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge179/challenge179.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge179\\challenge179.py', 26, 22, '    print challenge179()\n')), <traceback object at 0x0000000006A19048>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006972F28>
self       = <DoctestModule 'pemjh/challenge179/challenge179.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge179/challenge179.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge179/challenge179.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge179/challenge179.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge179\\challenge179.py')
modname = 'challenge179', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge179\challenge179.py", line 26
E               print challenge179()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge179'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge179')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge179\\challenge179.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge183/challenge183.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge183.py, line 56)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge183.py, line 56)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py', 56, 22, '    print challenge183()\n')), <traceback object at 0x00000000069E5F48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2378>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge183\challenge183.py", line 56
E               print challenge183()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge187/challenge187.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge187.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge187.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py', 22, 22, '    print challenge187()\n')), <traceback object at 0x00000000058EFA08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2598>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge187\challenge187.py", line 22
E               print challenge187()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge188/challenge188.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge188.py, line 18)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge188/challenge188.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge188/challenge188.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge188.py, line 18)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge188/challenge188.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge188/challenge188.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge188/challenge188.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E27B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge188\\challenge188.py', 18, 22, '    print challenge188()\n')), <traceback object at 0x0000000006A0A648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E27B8>
self       = <DoctestModule 'pemjh/challenge188/challenge188.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge188/challenge188.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge188/challenge188.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge188/challenge188.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge188\\challenge188.py')
modname = 'challenge188', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge188\challenge188.py", line 18
E               print challenge188()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge188'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge188')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge188\\challenge188.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge190/challenge190.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge190.py, line 11)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge190/challenge190.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge190/challenge190.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge190.py, line 11)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge190/challenge190.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge190/challenge190.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge190/challenge190.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E29D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge190\\challenge190.py', 11, 22, '    print challenge190()\n')), <traceback object at 0x0000000005661948>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E29D8>
self       = <DoctestModule 'pemjh/challenge190/challenge190.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge190/challenge190.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge190/challenge190.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge190/challenge190.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge190\\challenge190.py')
modname = 'challenge190', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge190\challenge190.py", line 11
E               print challenge190()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge190'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge190')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge190\\challenge190.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge191/challenge191.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge191.py, line 83)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge191/challenge191.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge191/challenge191.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge191.py, line 83)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge191/challenge191.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge191/challenge191.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge191/challenge191.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2BF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge191\\challenge191.py', 83, 22, '    print challenge191()\n')), <traceback object at 0x0000000005535948>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2BF8>
self       = <DoctestModule 'pemjh/challenge191/challenge191.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge191/challenge191.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge191/challenge191.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge191/challenge191.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge191\\challenge191.py')
modname = 'challenge191', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge191\challenge191.py", line 83
E               print challenge191()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge191'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge191')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge191\\challenge191.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge197/challenge197.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge197.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge197/challenge197.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge197/challenge197.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge197.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge197/challenge197.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge197/challenge197.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge197/challenge197.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge197\\challenge197.py', 27, 22, '    print challenge197()\n')), <traceback object at 0x0000000005618088>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2E18>
self       = <DoctestModule 'pemjh/challenge197/challenge197.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge197/challenge197.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge197/challenge197.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge197/challenge197.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge197\\challenge197.py')
modname = 'challenge197', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge197\challenge197.py", line 27
E               print challenge197()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge197'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge197')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge197\\challenge197.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge203/challenge203.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge203.py, line 44)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge203.py, line 44)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py', 44, 22, '    print challenge203()\n')), <traceback object at 0x000000000579EE88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069E2EA0>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge203\challenge203.py", line 44
E               print challenge203()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge204/challenge204.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge204.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge204.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069302F0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py', 32, 22, '    print challenge204()\n')), <traceback object at 0x0000000006960A88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069302F0>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge204\challenge204.py", line 32
E               print challenge204()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge205/challenge205.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge205.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge205/challenge205.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge205/challenge205.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge205.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge205/challenge205.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge205/challenge205.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge205/challenge205.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge205\\challenge205.py', 32, 22, '    print challenge205()\n')), <traceback object at 0x0000000005541FC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930510>
self       = <DoctestModule 'pemjh/challenge205/challenge205.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge205/challenge205.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge205/challenge205.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge205/challenge205.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge205\\challenge205.py')
modname = 'challenge205', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge205\challenge205.py", line 32
E               print challenge205()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge205'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge205')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge205\\challenge205.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge206/challenge206.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge206.py, line 65)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge206/challenge206.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge206/challenge206.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge206.py, line 65)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge206/challenge206.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge206/challenge206.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge206/challenge206.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge206\\challenge206.py', 65, 22, '    print challenge206()\n')), <traceback object at 0x0000000006975EC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930730>
self       = <DoctestModule 'pemjh/challenge206/challenge206.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge206/challenge206.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge206/challenge206.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge206/challenge206.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge206\\challenge206.py')
modname = 'challenge206', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge206\challenge206.py", line 65
E               print challenge206()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge206'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge206')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge206\\challenge206.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge207/challenge207.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge207.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge207/challenge207.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge207/challenge207.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge207.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge207/challenge207.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge207/challenge207.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge207/challenge207.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge207\\challenge207.py', 25, 22, '    print challenge207()\n')), <traceback object at 0x00000000054BC948>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930950>
self       = <DoctestModule 'pemjh/challenge207/challenge207.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge207/challenge207.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge207/challenge207.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge207/challenge207.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge207\\challenge207.py')
modname = 'challenge207', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge207\challenge207.py", line 25
E               print challenge207()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge207'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge207')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge207\\challenge207.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge211/challenge211.py _____________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge211.py, line 50)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge211.py, line 50)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930B70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py', 50, 19, '            print x\n')), <traceback object at 0x000000000578A588>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930B70>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge211\challenge211.py", line 50
E               print x
E                     ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge214/challenge214.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge214.py, line 76)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge214.py, line 76)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930D08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py', 76, 22, '    print challenge214()\n')), <traceback object at 0x000000000698CE88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930D08>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge214\challenge214.py", line 76
E               print challenge214()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge215/challenge215.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge215.py, line 64)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge215/challenge215.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge215/challenge215.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge215.py, line 64)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge215/challenge215.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge215/challenge215.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge215/challenge215.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge215\\challenge215.py', 64, 22, '    print challenge215()\n')), <traceback object at 0x0000000005649888>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930F28>
self       = <DoctestModule 'pemjh/challenge215/challenge215.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge215/challenge215.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge215/challenge215.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge215/challenge215.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge215\\challenge215.py')
modname = 'challenge215', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge215\challenge215.py", line 64
E               print challenge215()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge215'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge215')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge215\\challenge215.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge216/challenge216.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge216.py, line 81)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge216/challenge216.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge216/challenge216.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge216.py, line 81)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge216/challenge216.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge216/challenge216.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge216/challenge216.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge216\\challenge216.py', 81, 22, '    print challenge216()\n')), <traceback object at 0x0000000006967948>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006930D90>
self       = <DoctestModule 'pemjh/challenge216/challenge216.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge216/challenge216.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge216/challenge216.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge216/challenge216.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge216\\challenge216.py')
modname = 'challenge216', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge216\challenge216.py", line 81
E               print challenge216()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge216'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge216')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge216\\challenge216.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge220/challenge220.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge220.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge220/challenge220.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge220/challenge220.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge220.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge220/challenge220.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge220/challenge220.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge220/challenge220.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694A400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge220\\challenge220.py', 22, 22, '    print challenge220()\n')), <traceback object at 0x000000000588F148>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694A400>
self       = <DoctestModule 'pemjh/challenge220/challenge220.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge220/challenge220.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge220/challenge220.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge220/challenge220.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge220\\challenge220.py')
modname = 'challenge220', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge220\challenge220.py", line 22
E               print challenge220()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge220'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge220')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge220\\challenge220.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge225/challenge225.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge225.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge225/challenge225.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge225/challenge225.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge225.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge225/challenge225.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge225/challenge225.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge225/challenge225.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694A620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge225\\challenge225.py', 19, 22, '    print challenge225()\n')), <traceback object at 0x0000000005768548>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694A620>
self       = <DoctestModule 'pemjh/challenge225/challenge225.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge225/challenge225.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge225/challenge225.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge225/challenge225.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge225\\challenge225.py')
modname = 'challenge225', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge225\challenge225.py", line 19
E               print challenge225()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge225'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge225')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge225\\challenge225.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge230/challenge230.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge230.py, line 53)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge230/challenge230.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge230/challenge230.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge230.py, line 53)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge230/challenge230.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge230/challenge230.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge230/challenge230.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694A840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge230\\challenge230.py', 53, 22, '    print challenge230()\n')), <traceback object at 0x000000000692C808>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694A840>
self       = <DoctestModule 'pemjh/challenge230/challenge230.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge230/challenge230.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge230/challenge230.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge230/challenge230.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge230\\challenge230.py')
modname = 'challenge230', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge230\challenge230.py", line 53
E               print challenge230()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge230'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge230')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge230\\challenge230.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge231/challenge231.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge231.py, line 72)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge231.py, line 72)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694AA60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py', 72, 22, '    print challenge231()\n')), <traceback object at 0x0000000006A08C48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694AA60>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge231\challenge231.py", line 72
E               print challenge231()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge234/challenge234.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge234.py, line 44)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge234.py, line 44)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694AC80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py', 44, 22, '    print challenge234()\n')), <traceback object at 0x0000000005588CC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694AC80>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge234\challenge234.py", line 44
E               print challenge234()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge235/challenge235.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge235.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge235/challenge235.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge235/challenge235.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge235.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge235/challenge235.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge235/challenge235.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge235/challenge235.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694AEA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge235\\challenge235.py', 19, 22, '    print challenge235()\n')), <traceback object at 0x00000000069D1908>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694AEA0>
self       = <DoctestModule 'pemjh/challenge235/challenge235.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge235/challenge235.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge235/challenge235.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge235/challenge235.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge235\\challenge235.py')
modname = 'challenge235', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge235\challenge235.py", line 19
E               print challenge235()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge235'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge235')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge235\\challenge235.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge243/challenge243.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge243.py, line 49)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge243.py, line 49)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694AF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py', 49, 22, '    print challenge243()\n')), <traceback object at 0x00000000069E1208>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x000000000694AF28>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge243\challenge243.py", line 49
E               print challenge243()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge250/challenge250.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge250.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge250/challenge250.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge250/challenge250.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge250.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge250/challenge250.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge250/challenge250.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge250/challenge250.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006902378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge250\\challenge250.py', 27, 22, '    print challenge250()\n')), <traceback object at 0x0000000006917348>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006902378>
self       = <DoctestModule 'pemjh/challenge250/challenge250.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge250/challenge250.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge250/challenge250.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge250/challenge250.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge250\\challenge250.py')
modname = 'challenge250', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge250\challenge250.py", line 27
E               print challenge250()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge250'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge250')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge250\\challenge250.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge259/challenge259.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge259.py, line 66)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge259/challenge259.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge259/challenge259.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge259.py, line 66)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge259/challenge259.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge259/challenge259.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge259/challenge259.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006902598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge259\\challenge259.py', 66, 22, '    print challenge259()\n')), <traceback object at 0x000000000556A108>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006902598>
self       = <DoctestModule 'pemjh/challenge259/challenge259.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge259/challenge259.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge259/challenge259.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge259/challenge259.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge259\\challenge259.py')
modname = 'challenge259', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge259\challenge259.py", line 66
E               print challenge259()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge259'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge259')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge259\\challenge259.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge265/challenge265.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge265.py, line 55)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge265/challenge265.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge265/challenge265.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge265.py, line 55)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge265/challenge265.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge265/challenge265.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge265/challenge265.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069027B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge265\\challenge265.py', 55, 22, '    print challenge265()\n')), <traceback object at 0x00000000058E2148>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000069027B8>
self       = <DoctestModule 'pemjh/challenge265/challenge265.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge265/challenge265.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge265/challenge265.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge265/challenge265.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge265\\challenge265.py')
modname = 'challenge265', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge265\challenge265.py", line 55
E               print challenge265()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge265'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge265')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge265\\challenge265.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
================================== FAILURES ===================================
______________________________ [pylint] setup.py ______________________________
C: 36, 0: No space allowed around keyword argument assignment
    name = "pemjh",
         ^ (bad-whitespace)
C: 37, 0: No space allowed around keyword argument assignment
    version = "0.0.1",
            ^ (bad-whitespace)
C: 38, 0: No space allowed around keyword argument assignment
    author = "Matthew Hussey",
           ^ (bad-whitespace)
C: 39, 0: No space allowed around keyword argument assignment
    author_email = "matthew.hussey@googlemail.com",
                 ^ (bad-whitespace)
C: 40, 0: No space allowed around keyword argument assignment
    description = ("Project euler (https://projecteuler.net/) challenge "
                ^ (bad-whitespace)
C: 42, 0: No space allowed around keyword argument assignment
    license = "None, private use by myself only",
            ^ (bad-whitespace)
C: 43, 0: No space allowed around keyword argument assignment
    keywords = "code challenge euler",
             ^ (bad-whitespace)
C: 44, 0: No space allowed around keyword argument assignment
    url = "none.non",
        ^ (bad-whitespace)
C: 45, 0: No space allowed around keyword argument assignment
    packages = ["pemjh"],
             ^ (bad-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
    long_description = read("README"),
                     ^ (bad-whitespace)
C: 50, 0: No space allowed around keyword argument assignment
    cmdclass = {"test": Tox},
             ^ (bad-whitespace)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing class docstring (missing-docstring)
F: 27, 8: Unable to import 'tox' (import-error)
W: 24, 8: Attribute 'test_suite' defined outside __init__ (attribute-defined-outside-init)
W: 23, 8: Attribute 'test_args' defined outside __init__ (attribute-defined-outside-init)
W: 20, 8: Attribute 'tox_args' defined outside __init__ (attribute-defined-outside-init)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\setup.py:6:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\setup.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:18:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:21:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:25:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:26:9: E265 block comment should start with '# '
D:\Development\pemjh\setup.py:36:9: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:36:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:12: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:14: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:13: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:19: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:18: E251 unexpected spaces around keyword / parameter equals

___________________________ [pylint] pemjh/main.py ____________________________
E:  8, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\main.py:8:26: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\main.py:13:15: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\main.py:32:18: W291 trailing whitespace
D:\Development\pemjh\pemjh\main.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\main.py:58:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge001/challenge001.py _________________
E: 10, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge001\challenge001.py:10:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge002/challenge002.py _________________
E: 16, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge002\challenge002.py:16:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge003/challenge003.py _________________
E: 29, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge003\challenge003.py:29:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge004/challenge004.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge004\challenge004.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge005/challenge005.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge005\challenge005.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge006/challenge006.py _________________
E: 24, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:24:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge007/challenge007.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge007\challenge007.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge008/challenge008.py _________________
E: 45, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge008\challenge008.py:45:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge009/challenge009.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge010/challenge010.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge010\challenge010.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge011/challenge011.py _________________
E: 62, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:62:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge012/challenge012.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
E:  6, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
E:  7, 0: No name 'izip' in module 'itertools' (no-name-in-module)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 15, 0: Invalid function name "triangleDivisors" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 16, 4: Invalid variable name "n" (invalid-name)
C: 17, 4: Invalid variable name "nOdd" (invalid-name)
C: 18, 4: Invalid variable name "nEven" (invalid-name)
C: 19, 4: Invalid variable name "knownDivisors" (invalid-name)
C: 24,12: Invalid variable name "nOdd" (invalid-name)
C: 27,12: Invalid variable name "nEven" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36,22: More than one statement on a single line (multiple-statements)
W: 38,12: Using possibly undefined loop variable 'n' (undefined-loop-variable)
W: 38,17: Using possibly undefined loop variable 'n' (undefined-loop-variable)
C: 40, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge013/challenge013.py _________________
E:115, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:115:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge014/challenge014.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getChainSize" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "knownChains" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "knownChains" (invalid-name)
E: 30,13: Undefined variable 'xrange' (undefined-variable)
C: 31, 8: Invalid variable name "newChain" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge014\challenge014.py:30:14: F821 undefined name 'xrange'
D:\Development\pemjh\pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge015/challenge015.py _________________
C:  7, 0: No space allowed around keyword argument assignment
def multiplierGen(n = 0):
                    ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
E:  5, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "multiplierGen" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid function name "getRoutes" (invalid-name)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge016/challenge016.py _________________
E: 18, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge016\challenge016.py:18:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge017/challenge017.py _________________
E:110, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:110:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge018/challenge018.py _________________
E: 31, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge018\challenge018.py:31:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge019/challenge019.py _________________
E: 46, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:46:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge020/challenge020.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge020\challenge020.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge021/challenge021.py _________________
E: 33, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge021\challenge021.py:33:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge022/challenge022.py _________________
E: 38, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:38:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge023/challenge023.py _________________
E: 34, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:34:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge024/challenge024.py _________________
E: 18, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge024\challenge024.py:18:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge025/challenge025.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge025\challenge025.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge026/challenge026.py _________________
E: 29, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:29:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge027/challenge027.py _________________
E: 36, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge027\challenge027.py:36:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge028/challenge028.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge028\challenge028.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge029/challenge029.py _________________
E: 18, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge029\challenge029.py:18:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge030/challenge030.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge030\challenge030.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge031/challenge031.py _________________
E: 23, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge031\challenge031.py:23:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge032/challenge032.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge032\challenge032.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge033/challenge033.py _________________
E: 48, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:48:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge034/challenge034.py _________________
E: 14, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:14:21: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge035/challenge035.py _________________
E: 11, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:11:19: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
D:\Development\pemjh\pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge036/challenge036.py _________________
E: 30, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge036\challenge036.py:30:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge037/challenge037.py _________________
E: 36, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge037\challenge037.py:36:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge038/challenge038.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge038\challenge038.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge039/challenge039.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge039\challenge039.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge040/challenge040.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
D:\Development\pemjh\pemjh\challenge040\challenge040.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge041/challenge041.py _________________
E: 23, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge041\challenge041.py:23:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge042/challenge042.py _________________
E: 42, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge042\challenge042.py:42:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge043/challenge043.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge044/challenge044.py _________________
E: 35, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge044\challenge044.py:35:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge045/challenge045.py _________________
E: 35, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:35:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge046/challenge046.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge046\challenge046.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge047/challenge047.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
E:  6, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "numPrimeFactors" (invalid-name)
C:  8, 0: Invalid argument name "nPrimes" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "n" (invalid-name)
C: 11, 8: Invalid variable name "pf" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Invalid function name "hasNumPrimes" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 20,30: More than one statement on a single line (multiple-statements)
C: 24, 0: Missing function docstring (missing-docstring)
W: 30, 4: Redefining name 'count' from outer scope (line 1) (redefined-outer-name)
C: 31, 8: Invalid variable name "p" (invalid-name)
E: 31,13: Undefined variable 'xrange' (undefined-variable)
E: 35,28: Undefined variable 'xrange' (undefined-variable)
C: 45, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused count imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
D:\Development\pemjh\pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:31:14: F821 undefined name 'xrange'
D:\Development\pemjh\pemjh\challenge047\challenge047.py:35:29: F821 undefined name 'xrange'
D:\Development\pemjh\pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge048/challenge048.py _________________
E: 10, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge048\challenge048.py:10:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge049/challenge049.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge049\challenge049.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge050/challenge050.py _________________
E: 30, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge050\challenge050.py:30:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge051/challenge051.py _________________
E: 50, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:50:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge052/challenge052.py _________________
E: 28, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:28:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge053/challenge053.py _________________
E: 20, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge053\challenge053.py:20:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge054/challenge054.py _________________
E:136, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:136:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge055/challenge055.py _________________
E:  2, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:17: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge056/challenge056.py _________________
E: 17, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge056\challenge056.py:17:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge057/challenge057.py _________________
E: 21, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge057\challenge057.py:21:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge058/challenge058.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
E:  4, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nPrimes" (invalid-name)
C: 13, 4: Invalid variable name "primeChecker" (invalid-name)
E: 18,17: Undefined variable 'xrange' (undefined-variable)
C: 22,16: Invalid variable name "nPrimes" (invalid-name)
W:  9, 4: Unused variable 'total' (unused-variable)
W: 18,12: Unused variable 'j' (unused-variable)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
D:\Development\pemjh\pemjh\challenge058\challenge058.py:18:18: F821 undefined name 'xrange'
D:\Development\pemjh\pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge059/challenge059.py _________________
E: 49, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:49:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge060/challenge060.py _________________
E:119, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:119:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge061/challenge061.py _________________
E:104, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge061\challenge061.py:104:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge062/challenge062.py _________________
E: 34, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge062\challenge062.py:34:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge063/challenge063.py _________________
E: 28, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:28:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge064/challenge064.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge064\challenge064.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge065/challenge065.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge065\challenge065.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge066/challenge066.py _________________
E: 23, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)
D:\Development\pemjh\pemjh\challenge066\challenge066.py:23:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge067/challenge067.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge067\challenge067.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge068/challenge068.py _________________
E: 70, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge068\challenge068.py:70:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge069/challenge069.py _________________
E: 24, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge069\challenge069.py:24:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge070/challenge070.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
E:  4, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
E:  5, 0: No name 'izip' in module 'itertools' (no-name-in-module)
C:  8, 0: Invalid function name "isPermutation" (invalid-name)
C:  8, 0: Invalid argument name "a" (invalid-name)
C:  8, 0: Invalid argument name "b" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 17,11: Invalid variable name "p" (invalid-name)
E: 17,21: Undefined variable 'xrange' (undefined-variable)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused import string (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:17:22: F821 undefined name 'xrange'

_________________ [pylint] pemjh/challenge071/challenge071.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge071\challenge071.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge072/challenge072.py _________________
E: 14, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge072\challenge072.py:14:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge073/challenge073.py _________________
E: 42, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:42:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge074/challenge074.py _________________
E: 41, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
D:\Development\pemjh\pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:41:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge075/challenge075.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge075\challenge075.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge076/challenge076.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge076\challenge076.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge077/challenge077.py _________________
E: 34, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge077\challenge077.py:34:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge078/challenge078.py _________________
E:  6, 0: inconsistent use of tabs and spaces in indentation (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:20: E901 TabError: inconsistent use of tabs and spaces in indentation
D:\Development\pemjh\pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge079/challenge079.py _________________
E: 15, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge079\challenge079.py:15:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge080/challenge080.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge081/challenge081.py _________________
E: 46, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:46:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge082/challenge082.py _________________
E: 53, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:53:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge083/challenge083.py _________________
E: 80, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'
D:\Development\pemjh\pemjh\challenge083\challenge083.py:80:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge084/challenge084.py _________________
E:114, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:114:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge085/challenge085.py _________________
E: 51, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:51:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge086/challenge086.py _________________
E: 44, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:44:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge087/challenge087.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge087\challenge087.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge088/challenge088.py _________________
E: 36, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge088\challenge088.py:36:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge089/challenge089.py _________________
E: 90, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
D:\Development\pemjh\pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:90:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge090/challenge090.py _________________
E:132, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:132:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge091/challenge091.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge091\challenge091.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge092/challenge092.py _________________
E:124, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:124:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge093/challenge093.py _________________
E:102, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:102:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge094/challenge094.py _________________
E: 54, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge094\challenge094.py:54:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge095/challenge095.py _________________
E: 61, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:61:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge096/challenge096.py _________________
E:271, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:271:51: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge097/challenge097.py _________________
E:  8, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge097\challenge097.py:8:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge098/challenge098.py _________________
E: 98, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:98:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge099/challenge099.py _________________
E: 20, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge099\challenge099.py:20:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge100/challenge100.py _________________
E: 11, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge100\challenge100.py:11:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge101/challenge101.py _________________
E: 43, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
D:\Development\pemjh\pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge101\challenge101.py:43:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge102/challenge102.py _________________
E: 59, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge102\challenge102.py:59:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge103/challenge103.py _________________
E: 61, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:61:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge104/challenge104.py _________________
E: 50, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge104\challenge104.py:50:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge105/challenge105.py _________________
E: 65, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:65:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge106/challenge106.py _________________
E: 68, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:68:23: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge107/challenge107.py _________________
E: 70, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:70:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge108/challenge108.py _________________
E: 59, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:59:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge109/challenge109.py _________________
E: 50, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:50:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge110/challenge110.py _________________
E: 59, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:59:23: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge111/challenge111.py _________________
E: 54, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:54:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge112/challenge112.py _________________
E: 48, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge112\challenge112.py:48:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge113/challenge113.py _________________
E: 61, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge113\challenge113.py:61:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge114/challenge114.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge115/challenge115.py _________________
E: 43, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:43:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge116/challenge116.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge117/challenge117.py _________________
E: 33, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:33:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge118/challenge118.py _________________
E: 52, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:52:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge119/challenge119.py _________________
E: 33, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:33:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge120/challenge120.py _________________
E: 15, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge120\challenge120.py:15:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge121/challenge121.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge122/challenge122.py _________________
E: 28, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:28:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge123/challenge123.py _________________
E: 20, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:20:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge124/challenge124.py _________________
E: 41, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:41:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge125/challenge125.py _________________
E: 29, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge125\challenge125.py:29:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge126/challenge126.py _________________
E: 41, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:41:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge127/challenge127.py _________________
E: 35, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge127\challenge127.py:35:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge128/challenge128.py _________________
E: 33, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:33:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge129/challenge129.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge129\challenge129.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge130/challenge130.py _________________
E: 30, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge130\challenge130.py:30:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge131/challenge131.py _________________
E: 41, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge131\challenge131.py:41:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge132/challenge132.py _________________
E: 24, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:24:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge133/challenge133.py _________________
E: 16, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge133\challenge133.py:16:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge134/challenge134.py _________________
E: 72, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge134\challenge134.py:72:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge135/challenge135.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge135\challenge135.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge136/challenge136.py _________________
E: 26, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:26:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge137/challenge137.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge138/challenge138.py _________________
E: 34, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)
D:\Development\pemjh\pemjh\challenge138\challenge138.py:34:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge139/challenge139.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge139\challenge139.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge142/challenge142.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge142\challenge142.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge144/challenge144.py _________________
E: 72, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:72:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge145/challenge145.py _________________
E: 15, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge145\challenge145.py:15:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge146/challenge146.py _________________
E: 31, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge146\challenge146.py:31:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge148/challenge148.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge149/challenge149.py _________________
E: 51, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:51:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge151/challenge151.py _________________
E: 28, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge151\challenge151.py:28:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge162/challenge162.py _________________
E: 11, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge162\challenge162.py:11:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge164/challenge164.py _________________
E: 36, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:36:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge166/challenge166.py _________________
E: 73, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:73:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge173/challenge173.py _________________
E: 35, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge173\challenge173.py:35:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge174/challenge174.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge174\challenge174.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge179/challenge179.py _________________
E: 26, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge179\challenge179.py:26:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge183/challenge183.py _________________
E: 56, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:56:23: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge187/challenge187.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge188/challenge188.py _________________
E: 18, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge188\challenge188.py:18:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge190/challenge190.py _________________
E: 11, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge190\challenge190.py:11:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge191/challenge191.py _________________
E: 83, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:83:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge197/challenge197.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge197\challenge197.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge203/challenge203.py _________________
E: 44, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
D:\Development\pemjh\pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:44:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge204/challenge204.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge205/challenge205.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge206/challenge206.py _________________
E: 65, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge206\challenge206.py:65:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge207/challenge207.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge207\challenge207.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge211/challenge211.py _________________
E: 50, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
D:\Development\pemjh\pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:50:20: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge214/challenge214.py _________________
E: 76, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:76:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge215/challenge215.py _________________
E: 64, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge215\challenge215.py:64:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge216/challenge216.py _________________
E: 81, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:81:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge220/challenge220.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge220\challenge220.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge225/challenge225.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)
D:\Development\pemjh\pemjh\challenge225\challenge225.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge230/challenge230.py _________________
E: 53, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:53:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge231/challenge231.py _________________
E: 72, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge231\challenge231.py:72:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge234/challenge234.py _________________
E: 44, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:44:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge235/challenge235.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge235\challenge235.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge243/challenge243.py _________________
E: 49, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge243\challenge243.py:49:23: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge250/challenge250.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge250\challenge250.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge259/challenge259.py _________________
E: 66, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge259\challenge259.py:66:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge265/challenge265.py _________________
E: 55, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:55:23: E901 SyntaxError: invalid syntax

--------------- coverage: platform win32, python 3.4.3-final-0 ----------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge012\challenge012      31     28     10      9    10%   2-3, 7-44
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      6      5    11%   2-3, 7-32
pemjh\challenge047\challenge047      37     34     20     19     7%   4-5, 8-50
pemjh\challenge058\challenge058      26     24     10      9     8%   2-3, 6-38
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
-----------------------------------------------------------------------------
TOTAL                               168    152     70     64     9%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\python34_64\Lib\runpy.py", line 170, in _run_module_as_main
    "__main__", mod_spec)
  File "E:\software_tools\python\python34_64\Lib\runpy.py", line 85, in _run_code
    exec(code, run_globals)
  File "D:\Development\pemjh\.tox\py34\Scripts\py.test.EXE\__main__.py", line 9, in <module>
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
pytest_cov.plugin.CoverageError: Required test coverage of 100% not reached. Total coverage: 9.24%
ERROR: InvocationError: 'D:\\Development\\pemjh\\.tox\\py34\\Scripts\\py.test.EXE --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100'
py34_64 inst-nodeps: D:\Development\pemjh\.tox\dist\pemjh-0.0.1.zip
py34_64 installed: apipkg==1.4,astroid==1.3.8,colorama==0.3.3,coverage==3.7.1,execnet==1.4.1,flake8==2.4.1,logilab-common==1.0.2,mccabe==0.3.1,pemjh==0.0.1,pep8==1.5.7,py==1.4.30,pyflakes==0.8.1,pylint==1.4.4,pytest==2.7.2,pytest-cache==1.0,pytest-cov==2.1.0,pytest-flake8==0.1,pytest-pylint==0.3.0,six==1.9.0,wheel==0.24.0
py34_64 runtests: PYTHONHASHSEED='850'
py34_64 runtests: commands[0] | py.test --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100
============================= test session starts =============================
platform win32 -- Python 2.7.10 -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh, inifile: 
plugins: cache, cov, flake8, pylint
collected 358 items / 65 errors

setup.py FF
pemjh\main.py FF
pemjh\challenge001\challenge001.py FF
pemjh\challenge002\challenge002.py FF
pemjh\challenge003\challenge003.py FF
pemjh\challenge004\challenge004.py FF
pemjh\challenge005\challenge005.py FF
pemjh\challenge006\challenge006.py FF
pemjh\challenge007\challenge007.py FF
pemjh\challenge008\challenge008.py FF
pemjh\challenge009\challenge009.py FF
pemjh\challenge010\challenge010.py FF
pemjh\challenge011\challenge011.py FF
pemjh\challenge012\challenge012.py FF
pemjh\challenge013\challenge013.py FF
pemjh\challenge014\challenge014.py FF
pemjh\challenge015\challenge015.py FF
pemjh\challenge016\challenge016.py FF
pemjh\challenge017\challenge017.py FF
pemjh\challenge018\challenge018.py FF
pemjh\challenge019\challenge019.py FF
pemjh\challenge020\challenge020.py FF
pemjh\challenge021\challenge021.py FF
pemjh\challenge022\challenge022.py FF
pemjh\challenge023\challenge023.py FF
pemjh\challenge024\challenge024.py FF
pemjh\challenge025\challenge025.py FF
pemjh\challenge026\challenge026.py FF
pemjh\challenge027\challenge027.py FF
pemjh\challenge028\challenge028.py FF
pemjh\challenge029\challenge029.py FF
pemjh\challenge030\challenge030.py FF
pemjh\challenge031\challenge031.py FF
pemjh\challenge032\challenge032.py FF
pemjh\challenge033\challenge033.py FF
pemjh\challenge034\challenge034.py FF
pemjh\challenge035\challenge035.py FF
pemjh\challenge036\challenge036.py FF
pemjh\challenge037\challenge037.py FF
pemjh\challenge038\challenge038.py FF
pemjh\challenge039\challenge039.py FF
pemjh\challenge040\challenge040.py FF
pemjh\challenge041\challenge041.py FF
pemjh\challenge042\challenge042.py FF
pemjh\challenge043\challenge043.py FF
pemjh\challenge044\challenge044.py FF
pemjh\challenge045\challenge045.py FF
pemjh\challenge046\challenge046.py FF
pemjh\challenge047\challenge047.py FF
pemjh\challenge048\challenge048.py FF
pemjh\challenge049\challenge049.py FF
pemjh\challenge050\challenge050.py FF
pemjh\challenge051\challenge051.py FF
pemjh\challenge052\challenge052.py FF
pemjh\challenge053\challenge053.py FF
pemjh\challenge054\challenge054.py FF
pemjh\challenge055\challenge055.py FF
pemjh\challenge056\challenge056.py FF
pemjh\challenge057\challenge057.py FF
pemjh\challenge058\challenge058.py FF
pemjh\challenge059\challenge059.py FF
pemjh\challenge060\challenge060.py FF
pemjh\challenge061\challenge061.py FF
pemjh\challenge062\challenge062.py FF
pemjh\challenge063\challenge063.py FF
pemjh\challenge064\challenge064.py FF
pemjh\challenge065\challenge065.py FF
pemjh\challenge066\challenge066.py FF
pemjh\challenge067\challenge067.py FF
pemjh\challenge068\challenge068.py FF
pemjh\challenge069\challenge069.py FF
pemjh\challenge070\challenge070.py FF
pemjh\challenge071\challenge071.py FF
pemjh\challenge072\challenge072.py FF
pemjh\challenge073\challenge073.py FF
pemjh\challenge074\challenge074.py FF
pemjh\challenge075\challenge075.py FF
pemjh\challenge076\challenge076.py FF
pemjh\challenge077\challenge077.py FF
pemjh\challenge078\challenge078.py FF
pemjh\challenge079\challenge079.py FF
pemjh\challenge080\challenge080.py FF
pemjh\challenge081\challenge081.py FF
pemjh\challenge082\challenge082.py FF
pemjh\challenge083\challenge083.py FF
pemjh\challenge084\challenge084.py FF
pemjh\challenge085\challenge085.py FF
pemjh\challenge086\challenge086.py FF
pemjh\challenge087\challenge087.py FF
pemjh\challenge088\challenge088.py FF
pemjh\challenge089\challenge089.py FF
pemjh\challenge090\challenge090.py FF
pemjh\challenge091\challenge091.py FF
pemjh\challenge092\challenge092.py FF
pemjh\challenge093\challenge093.py FF
pemjh\challenge094\challenge094.py FF
pemjh\challenge095\challenge095.py FF
pemjh\challenge096\challenge096.py FF
pemjh\challenge097\challenge097.py FF
pemjh\challenge098\challenge098.py FF
pemjh\challenge099\challenge099.py FF
pemjh\challenge100\challenge100.py Fs
pemjh\challenge101\challenge101.py FF
pemjh\challenge102\challenge102.py FF
pemjh\challenge103\challenge103.py FF
pemjh\challenge104\challenge104.py FF
pemjh\challenge105\challenge105.py FF
pemjh\challenge106\challenge106.py FF
pemjh\challenge107\challenge107.py FF
pemjh\challenge108\challenge108.py FF
pemjh\challenge109\challenge109.py FF
pemjh\challenge110\challenge110.py FF
pemjh\challenge111\challenge111.py FF
pemjh\challenge112\challenge112.py FF
pemjh\challenge113\challenge113.py FF
pemjh\challenge114\challenge114.py FF
pemjh\challenge115\challenge115.py FF
pemjh\challenge116\challenge116.py FF
pemjh\challenge117\challenge117.py FF
pemjh\challenge118\challenge118.py FF
pemjh\challenge119\challenge119.py FF
pemjh\challenge120\challenge120.py FF
pemjh\challenge121\challenge121.py FF
pemjh\challenge122\challenge122.py FF
pemjh\challenge123\challenge123.py FF
pemjh\challenge124\challenge124.py FF
pemjh\challenge125\challenge125.py Fs
pemjh\challenge126\challenge126.py FF
pemjh\challenge127\challenge127.py FF
pemjh\challenge128\challenge128.py FF
pemjh\challenge129\challenge129.py FF
pemjh\challenge130\challenge130.py FF
pemjh\challenge131\challenge131.py FF
pemjh\challenge132\challenge132.py FF
pemjh\challenge133\challenge133.py FF
pemjh\challenge134\challenge134.py FF
pemjh\challenge135\challenge135.py FF
pemjh\challenge136\challenge136.py FF
pemjh\challenge137\challenge137.py FF
pemjh\challenge138\challenge138.py FF
pemjh\challenge139\challenge139.py FF
pemjh\challenge142\challenge142.py FF
pemjh\challenge144\challenge144.py FF
pemjh\challenge145\challenge145.py Fs
pemjh\challenge146\challenge146.py FF
pemjh\challenge148\challenge148.py FF
pemjh\challenge149\challenge149.py FF
pemjh\challenge151\challenge151.py FF
pemjh\challenge162\challenge162.py FF
pemjh\challenge164\challenge164.py FF
pemjh\challenge166\challenge166.py FF
pemjh\challenge173\challenge173.py FF
pemjh\challenge174\challenge174.py FF
pemjh\challenge179\challenge179.py FF
pemjh\challenge183\challenge183.py FF
pemjh\challenge187\challenge187.py FF
pemjh\challenge188\challenge188.py FF
pemjh\challenge190\challenge190.py FF
pemjh\challenge191\challenge191.py FF
pemjh\challenge197\challenge197.py FF
pemjh\challenge203\challenge203.py FF
pemjh\challenge204\challenge204.py FF
pemjh\challenge205\challenge205.py FF
pemjh\challenge206\challenge206.py FF
pemjh\challenge207\challenge207.py Fs
pemjh\challenge211\challenge211.py FF
pemjh\challenge214\challenge214.py FF
pemjh\challenge215\challenge215.py FF
pemjh\challenge216\challenge216.py FF
pemjh\challenge220\challenge220.py FF
pemjh\challenge225\challenge225.py FF
pemjh\challenge230\challenge230.py FF
pemjh\challenge231\challenge231.py FF
pemjh\challenge234\challenge234.py FF
pemjh\challenge235\challenge235.py FF
pemjh\challenge243\challenge243.py FF
pemjh\challenge250\challenge250.py FF
pemjh\challenge259\challenge259.py FF
pemjh\challenge265\challenge265.py FF

=================================== ERRORS ====================================
__________________________ ERROR collecting setup.py __________________________

self = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
func = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
self       = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003ECEAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = None
function   = <function <lambda> at 0x0000000003ECEAC8>
self       = <DoctestModule 'setup.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'setup.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\setup.py'), modname = 'setup'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'setup'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh')
self       = local('D:\\Development\\pemjh\\setup.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    https://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands"""
    
    import os
    import sys
    from setuptools import setup
    from setuptools.command.test import test as TestCommand
    
    def read(fname):
        return open(os.path.join(os.path.dirname(__file__), fname)).read()
    
    class Tox(TestCommand):
        user_options = [('tox-args=', 'a', "Arguments to pass to tox")]
        def initialize_options(self):
            TestCommand.initialize_options(self)
            self.tox_args = None
        def finalize_options(self):
            TestCommand.finalize_options(self)
            self.test_args = []
            self.test_suite = True
        def run_tests(self):
            #import here, cause outside the eggs aren't loaded
            import tox
            import shlex
            args = self.tox_args
            if args:
                args = shlex.split(self.tox_args)
            errno = tox.cmdline(args=args)
            sys.exit(errno)
    
    setup(
        name = "pemjh",
        version = "0.0.1",
        author = "Matthew Hussey",
        author_email = "matthew.hussey@googlemail.com",
        description = ("Project euler (https://projecteuler.net/) challenge "
                       "code in Python."),
        license = "None, private use by myself only",
        keywords = "code challenge euler",
        url = "none.non",
        packages = ["pemjh"],
        long_description = read("README"),
        classifiers=[
            "Development Status :: 1 - Planning"],
        tests_require=['tox'],
>       cmdclass = {"test": Tox},
    )

TestCommand = None
Tox        = None
__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
os         = None
read       = None
setup      = None
sys        = None

setup.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

attrs = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x00000000043F6528>}, ...}
klass = <class setuptools.dist.Distribution at 0x00000000043A3C48>
dist = <setuptools.dist.Distribution instance at 0x00000000043FF148>
msg = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

    def setup(**attrs):
        """The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
    
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
    
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
    
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.
        """
    
        global _setup_stop_after, _setup_distribution
    
        # Determine the distribution class -- either caller-supplied or
        # our Distribution (see below).
        klass = attrs.get('distclass')
        if klass:
            del attrs['distclass']
        else:
            klass = Distribution
    
        if 'script_name' not in attrs:
            attrs['script_name'] = os.path.basename(sys.argv[0])
        if 'script_args' not in attrs:
            attrs['script_args'] = sys.argv[1:]
    
        # Create the Distribution instance, using the remaining arguments
        # (ie. everything except distclass) to initialize it
        try:
            _setup_distribution = dist = klass(attrs)
        except DistutilsSetupError, msg:
            if 'name' in attrs:
                raise SystemExit, "error in %s setup command: %s" % \
                      (attrs['name'], msg)
            else:
                raise SystemExit, "error in setup command: %s" % msg
    
        if _setup_stop_after == "init":
            return dist
    
        # Find and parse the config file(s): they will override options from
        # the setup script, but be overridden by the command line.
        dist.parse_config_files()
    
        if DEBUG:
            print "options (after parsing config files):"
            dist.dump_option_dicts()
    
        if _setup_stop_after == "config":
            return dist
    
        # Parse the command line and override config files; any
        # command-line errors are the end user's fault, so turn them into
        # SystemExit to suppress tracebacks.
        try:
            ok = dist.parse_command_line()
        except DistutilsArgError, msg:
>           raise SystemExit, gen_usage(dist.script_name) + "\nerror: %s" % msg
E           SystemExit: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
E              or: py.test.EXE --help [cmd1 cmd2 ...]
E              or: py.test.EXE --help-commands
E              or: py.test.EXE cmd --help
E           
E           error: option --pylint not recognized

attrs      = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x00000000043F6528>}, ...}
dist       = <setuptools.dist.Distribution instance at 0x00000000043FF148>
klass      = <class setuptools.dist.Distribution at 0x00000000043A3C48>
msg        = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

E:\software_tools\python\python27_64\Lib\distutils\core.py:139: SystemExit
_____________ ERROR collecting pemjh/challenge002/challenge002.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044A9898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045F8EC8>)
function   = <function <lambda> at 0x00000000044A9898>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge002\challenge002.py:5: ImportError
_____________ ERROR collecting pemjh/challenge012/challenge012.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004758C18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000476E848>)
function   = <function <lambda> at 0x0000000004758C18>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge012\challenge012.py:6: ImportError
_____________ ERROR collecting pemjh/challenge015/challenge015.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000475AC88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045FDE48>)
function   = <function <lambda> at 0x000000000475AC88>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge015\challenge015.py:5: ImportError
_____________ ERROR collecting pemjh/challenge018/challenge018.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004488CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000470C7C8>)
function   = <function <lambda> at 0x0000000004488CF8>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge018\challenge018.py:4: ImportError
_____________ ERROR collecting pemjh/challenge021/challenge021.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004493278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002DFFC48>)
function   = <function <lambda> at 0x0000000004493278>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge021\challenge021.py:5: ImportError
_____________ ERROR collecting pemjh/challenge024/challenge024.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044937B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000002E713C8>)
function   = <function <lambda> at 0x00000000044937B8>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge024\challenge024.py:5: ImportError
_____________ ERROR collecting pemjh/challenge025/challenge025.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000003ECEAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EB8C48>)
function   = <function <lambda> at 0x0000000003ECEAC8>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge025\challenge025.py:4: ImportError
_____________ ERROR collecting pemjh/challenge027/challenge027.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045E5198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E8F848>)
function   = <function <lambda> at 0x00000000045E5198>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge027\challenge027.py:5: ImportError
_____________ ERROR collecting pemjh/challenge032/challenge032.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045E5358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x000000000458DEC8>)
function   = <function <lambda> at 0x00000000045E5358>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge032\challenge032.py:5: ImportError
_____________ ERROR collecting pemjh/challenge033/challenge033.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045E5748>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000458D548>)
function   = <function <lambda> at 0x00000000045E5748>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import lowestCommonTerms
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge033\challenge033.py:5: ImportError
_____________ ERROR collecting pemjh/challenge034/challenge034.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045E5B38>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047071C8>)
function   = <function <lambda> at 0x00000000045E5B38>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge034\challenge034.py:5: ImportError
_____________ ERROR collecting pemjh/challenge035/challenge035.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000304E048>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EAF088>)
function   = <function <lambda> at 0x000000000304E048>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge035\challenge035.py:5: ImportError
_____________ ERROR collecting pemjh/challenge037/challenge037.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000304E0B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003082E08>)
function   = <function <lambda> at 0x000000000304E0B8>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge037\challenge037.py:5: ImportError
_____________ ERROR collecting pemjh/challenge041/challenge041.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000304E4A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003073908>)
function   = <function <lambda> at 0x000000000304E4A8>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge041\challenge041.py:5: ImportError
_____________ ERROR collecting pemjh/challenge043/challenge043.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000304E7B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000004589708>)
function   = <function <lambda> at 0x000000000304E7B8>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge043\challenge043.py:4: ImportError
_____________ ERROR collecting pemjh/challenge046/challenge046.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000304EC88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E04588>)
function   = <function <lambda> at 0x000000000304EC88>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import sqrt
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge046\challenge046.py:6: ImportError
_____________ ERROR collecting pemjh/challenge047/challenge047.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030634A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004675E88>)
function   = <function <lambda> at 0x00000000030634A8>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
count      = None

pemjh\challenge047\challenge047.py:6: ImportError
_____________ ERROR collecting pemjh/challenge049/challenge049.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000003063438>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000306BD48>)
function   = <function <lambda> at 0x0000000003063438>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import string
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
string     = None

pemjh\challenge049\challenge049.py:6: ImportError
_____________ ERROR collecting pemjh/challenge050/challenge050.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030636D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E5EA48>)
function   = <function <lambda> at 0x00000000030636D8>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge050\challenge050.py:4: ImportError
_____________ ERROR collecting pemjh/challenge051/challenge051.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000003063978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045DF648>)
function   = <function <lambda> at 0x0000000003063978>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import cycle
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
cycle      = None

pemjh\challenge051\challenge051.py:6: ImportError
_____________ ERROR collecting pemjh/challenge053/challenge053.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000003063BA8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044FDC48>)
function   = <function <lambda> at 0x0000000003063BA8>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge053\challenge053.py:4: ImportError
_____________ ERROR collecting pemjh/challenge058/challenge058.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004592128>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000445D708>)
function   = <function <lambda> at 0x0000000004592128>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge058\challenge058.py:4: ImportError
_____________ ERROR collecting pemjh/challenge060/challenge060.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004592748>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E78A48>)
function   = <function <lambda> at 0x0000000004592748>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge060\challenge060.py:5: ImportError
_____________ ERROR collecting pemjh/challenge064/challenge064.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004592C18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004749A08>)
function   = <function <lambda> at 0x0000000004592C18>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import continueGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge064\challenge064.py:1: ImportError
_____________ ERROR collecting pemjh/challenge065/challenge065.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045822E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002FDAC08>)
function   = <function <lambda> at 0x00000000045822E8>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge065\challenge065.py:4: ImportError
_____________ ERROR collecting pemjh/challenge066/challenge066.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004582518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003076388>)
function   = <function <lambda> at 0x0000000004582518>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import rootConvergentGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge066\challenge066.py:1: ImportError
_____________ ERROR collecting pemjh/challenge067/challenge067.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045826D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000459D448>)
function   = <function <lambda> at 0x00000000045826D8>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import with_statement
    from os.path import dirname, abspath
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
abspath    = None
dirname    = None
with_statement = None

pemjh\challenge067\challenge067.py:9: ImportError
_____________ ERROR collecting pemjh/challenge069/challenge069.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004582978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004821188>)
function   = <function <lambda> at 0x0000000004582978>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge069\challenge069.py:4: ImportError
_____________ ERROR collecting pemjh/challenge070/challenge070.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004510198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EAFB08>)
function   = <function <lambda> at 0x0000000004510198>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge070\challenge070.py:4: ImportError
_____________ ERROR collecting pemjh/challenge072/challenge072.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004510358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004779408>)
function   = <function <lambda> at 0x0000000004510358>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge072\challenge072.py:5: ImportError
_____________ ERROR collecting pemjh/challenge073/challenge073.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045103C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004546EC8>)
function   = <function <lambda> at 0x00000000045103C8>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import ceil, floor
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
ceil       = None
floor      = None

pemjh\challenge073\challenge073.py:6: ImportError
_____________ ERROR collecting pemjh/challenge075/challenge075.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045106D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000444D388>)
function   = <function <lambda> at 0x00000000045106D8>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge075\challenge075.py:1: ImportError
_____________ ERROR collecting pemjh/challenge077/challenge077.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004510BA8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003054EC8>)
function   = <function <lambda> at 0x0000000004510BA8>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge077\challenge077.py:1: ImportError
_____________ ERROR collecting pemjh/challenge087/challenge087.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002FFB668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004893888>)
function   = <function <lambda> at 0x0000000002FFB668>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge087\challenge087.py:4: ImportError
_____________ ERROR collecting pemjh/challenge092/challenge092.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045C5EB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E33248>)
function   = <function <lambda> at 0x00000000045C5EB8>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge092\challenge092.py:4: ImportError
_____________ ERROR collecting pemjh/challenge104/challenge104.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045C5C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048ACE88>)
function   = <function <lambda> at 0x00000000045C5C88>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge104\challenge104.py:1: ImportError
_____________ ERROR collecting pemjh/challenge108/challenge108.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004832CF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000306A148>)
function   = <function <lambda> at 0x0000000004832CF8>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge108\challenge108.py:1: ImportError
_____________ ERROR collecting pemjh/challenge110/challenge110.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000456E668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004749288>)
function   = <function <lambda> at 0x000000000456E668>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge110\challenge110.py:1: ImportError
_____________ ERROR collecting pemjh/challenge111/challenge111.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000456EBA8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E4BEC8>)
function   = <function <lambda> at 0x000000000456EBA8>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, roughPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge111\challenge111.py:1: ImportError
_____________ ERROR collecting pemjh/challenge113/challenge113.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000465AF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004818148>)
function   = <function <lambda> at 0x000000000465AF28>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import polytopicNumbers
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge113\challenge113.py:4: ImportError
_____________ ERROR collecting pemjh/challenge118/challenge118.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000465A208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000049377C8>)
function   = <function <lambda> at 0x000000000465A208>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge118\challenge118.py:1: ImportError
_____________ ERROR collecting pemjh/challenge121/challenge121.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000465ACF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003082548>)
function   = <function <lambda> at 0x000000000465ACF8>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge121\challenge121.py:1: ImportError
_____________ ERROR collecting pemjh/challenge123/challenge123.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002DFB2E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004657448>)
function   = <function <lambda> at 0x0000000002DFB2E8>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge123\challenge123.py:1: ImportError
_____________ ERROR collecting pemjh/challenge124/challenge124.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002DFB3C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000003073288>)
function   = <function <lambda> at 0x0000000002DFB3C8>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge124\challenge124.py:1: ImportError
_____________ ERROR collecting pemjh/challenge127/challenge127.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002DFB278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004700C08>)
function   = <function <lambda> at 0x0000000002DFB278>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import gcd, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge127\challenge127.py:1: ImportError
_____________ ERROR collecting pemjh/challenge128/challenge128.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002DFB978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004855248>)
function   = <function <lambda> at 0x0000000002DFB978>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge128\challenge128.py:1: ImportError
_____________ ERROR collecting pemjh/challenge130/challenge130.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002DFBEB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002FE8188>)
function   = <function <lambda> at 0x0000000002DFBEB8>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge130\challenge130.py:1: ImportError
_____________ ERROR collecting pemjh/challenge131/challenge131.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000466D2E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004A39508>)
function   = <function <lambda> at 0x000000000466D2E8>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge131\challenge131.py:1: ImportError
_____________ ERROR collecting pemjh/challenge132/challenge132.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000466D208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E2D648>)
function   = <function <lambda> at 0x000000000466D208>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge132\challenge132.py:1: ImportError
_____________ ERROR collecting pemjh/challenge133/challenge133.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000466D198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002FD26C8>)
function   = <function <lambda> at 0x000000000466D198>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge133\challenge133.py:1: ImportError
_____________ ERROR collecting pemjh/challenge134/challenge134.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000466D588>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E83088>)
function   = <function <lambda> at 0x000000000466D588>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge134\challenge134.py:1: ImportError
_____________ ERROR collecting pemjh/challenge136/challenge136.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000466D908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048B7808>)
function   = <function <lambda> at 0x000000000466D908>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge136\challenge136.py:1: ImportError
_____________ ERROR collecting pemjh/challenge138/challenge138.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004442F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000472C248>)
function   = <function <lambda> at 0x0000000004442F28>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge138\challenge138.py:1: ImportError
_____________ ERROR collecting pemjh/challenge139/challenge139.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004442278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E78B08>)
function   = <function <lambda> at 0x0000000004442278>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge139\challenge139.py:1: ImportError
_____________ ERROR collecting pemjh/challenge174/challenge174.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004442128>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004C583C8>)
function   = <function <lambda> at 0x0000000004442128>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge174\challenge174.py:1: ImportError
_____________ ERROR collecting pemjh/challenge183/challenge183.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004947C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000049FC3C8>)
function   = <function <lambda> at 0x0000000004947C88>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge183\challenge183.py:1: ImportError
_____________ ERROR collecting pemjh/challenge187/challenge187.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004947F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000461D648>)
function   = <function <lambda> at 0x0000000004947F98>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge187\challenge187.py:1: ImportError
_____________ ERROR collecting pemjh/challenge203/challenge203.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047FC198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000464E248>)
function   = <function <lambda> at 0x00000000047FC198>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge203\challenge203.py:1: ImportError
_____________ ERROR collecting pemjh/challenge204/challenge204.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047FC9E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002FD4EC8>)
function   = <function <lambda> at 0x00000000047FC9E8>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge204\challenge204.py:1: ImportError
_____________ ERROR collecting pemjh/challenge211/challenge211.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047FCDD8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004446188>)
function   = <function <lambda> at 0x00000000047FCDD8>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge211\challenge211.py:1: ImportError
_____________ ERROR collecting pemjh/challenge214/challenge214.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047ED198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004777748>)
function   = <function <lambda> at 0x00000000047ED198>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes, primeFactors, phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge214\challenge214.py:1: ImportError
_____________ ERROR collecting pemjh/challenge231/challenge231.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047ED278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004C317C8>)
function   = <function <lambda> at 0x00000000047ED278>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge231\challenge231.py:1: ImportError
_____________ ERROR collecting pemjh/challenge234/challenge234.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002E88DD8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000486EB88>)
function   = <function <lambda> at 0x0000000002E88DD8>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge234\challenge234.py:1: ImportError
_____________ ERROR collecting pemjh/challenge243/challenge243.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py34_64\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002E88668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004778688>)
function   = <function <lambda> at 0x0000000002E88668>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34_64\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34_64\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

.tox\py34_64\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge243\challenge243.py:1: ImportError
================================== FAILURES ===================================
______________________________ [pylint] setup.py ______________________________
C: 36, 0: No space allowed around keyword argument assignment
    name = "pemjh",
         ^ (bad-whitespace)
C: 37, 0: No space allowed around keyword argument assignment
    version = "0.0.1",
            ^ (bad-whitespace)
C: 38, 0: No space allowed around keyword argument assignment
    author = "Matthew Hussey",
           ^ (bad-whitespace)
C: 39, 0: No space allowed around keyword argument assignment
    author_email = "matthew.hussey@googlemail.com",
                 ^ (bad-whitespace)
C: 40, 0: No space allowed around keyword argument assignment
    description = ("Project euler (https://projecteuler.net/) challenge "
                ^ (bad-whitespace)
C: 42, 0: No space allowed around keyword argument assignment
    license = "None, private use by myself only",
            ^ (bad-whitespace)
C: 43, 0: No space allowed around keyword argument assignment
    keywords = "code challenge euler",
             ^ (bad-whitespace)
C: 44, 0: No space allowed around keyword argument assignment
    url = "none.non",
        ^ (bad-whitespace)
C: 45, 0: No space allowed around keyword argument assignment
    packages = ["pemjh"],
             ^ (bad-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
    long_description = read("README"),
                     ^ (bad-whitespace)
C: 50, 0: No space allowed around keyword argument assignment
    cmdclass = {"test": Tox},
             ^ (bad-whitespace)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing class docstring (missing-docstring)
F: 27, 8: Unable to import 'tox' (import-error)
W: 24, 8: Attribute 'test_suite' defined outside __init__ (attribute-defined-outside-init)
W: 23, 8: Attribute 'test_args' defined outside __init__ (attribute-defined-outside-init)
W: 20, 8: Attribute 'tox_args' defined outside __init__ (attribute-defined-outside-init)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\setup.py:6:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\setup.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:18:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:21:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:25:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:26:9: E265 block comment should start with '# '
D:\Development\pemjh\setup.py:36:9: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:36:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:12: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:14: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:13: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:19: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:18: E251 unexpected spaces around keyword / parameter equals

___________________________ [pylint] pemjh/main.py ____________________________
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 58, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  9, 0: No exception type(s) specified (bare-except)
F:  6, 4: Unable to import 'psyco' (import-error)
C: 12, 0: Invalid function name "testFunction" (invalid-name)
C: 12, 0: Invalid argument name "id" (invalid-name)
C: 12, 0: Invalid argument name "knownAnswer" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
W: 12,27: Redefining name 'knownAnswer' from outer scope (line 46) (redefined-outer-name)
W: 12,17: Redefining built-in 'id' (redefined-builtin)
W: 12,21: Redefining name 'func' from outer scope (line 43) (redefined-outer-name)
C: 30, 0: Invalid constant name "wholeTime" (invalid-name)
C: 32, 0: Invalid constant name "failures" (invalid-name)
C: 34, 0: Invalid constant name "nChallenges" (invalid-name)
C: 60, 0: Invalid constant name "wholeTime" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\main.py:13:15: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\main.py:32:18: W291 trailing whitespace
D:\Development\pemjh\pemjh\main.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\main.py:58:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge001/challenge001.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid constant name "upper" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  4,15: Used builtin function 'filter' (bad-builtin)
W:  4,15: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C:  6, 0: Invalid constant name "answer" (invalid-name)
W:  9, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge001\challenge001.py:9:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge002/challenge002.py _________________
C: 10, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "numRange" (invalid-name)
C: 10, 4: Invalid variable name "evenNums" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge003/challenge003.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 19,26: More than one statement on a single line (multiple-statements)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import math (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge003\challenge003.py:1:1: F401 'math' imported but unused
D:\Development\pemjh\pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge003\challenge003.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge004/challenge004.py _________________
C:  8, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 18, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 26, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 18,61: More than one statement on a single line (multiple-statements)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W: 36, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge004\challenge004.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge005/challenge005.py _________________
C: 12, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  3, 4: Redefining built-in 'max' (redefined-builtin)
C:  6, 8: Invalid variable name "n" (invalid-name)
C: 14,16: Invalid variable name "n" (invalid-name)
C: 28,23: More than one statement on a single line (multiple-statements)
C: 31, 8: Invalid variable name "n" (invalid-name)
C: 31,11: Invalid variable name "p" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge005\challenge005.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge006/challenge006.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'max' (redefined-builtin)
W: 10, 4: Redefining built-in 'sum' (redefined-builtin)
C:  4, 4: Invalid variable name "sumOfSquares" (invalid-name)
C:  7, 8: Invalid variable name "sumOfSquares" (invalid-name)
C: 13, 4: Invalid variable name "squareOfSums" (invalid-name)
C: 20, 0: Invalid constant name "answer" (invalid-name)
W: 23, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:23:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge007/challenge007.py _________________
C: 14, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'max' (redefined-builtin)
C: 13, 8: Invalid variable name "primeRange" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
W: 24, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge007\challenge007.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge008/challenge008.py _________________
C: 29, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'input' (redefined-builtin)
C: 26, 8: Invalid variable name "testPart" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
W: 44, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge008\challenge008.py:44:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge009/challenge009.py _________________
C:  8, 0: Exactly one space required after comma
    for a in range(1,(max / 3)):
                    ^ (bad-whitespace)
C: 11, 0: Exactly one space required after comma
        for b in range((a + 1),(a + 1 + (remainder / 2))):
                              ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  4, 4: Redefining built-in 'max' (redefined-builtin)
W:  5, 4: Redefining name 'answer' from outer scope (line 18) (redefined-outer-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C: 11,12: Invalid variable name "b" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge010/challenge010.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  6, 4: Redefining built-in 'max' (redefined-builtin)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ifilter imported from itertools (unused-import)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge010\challenge010.py:1:1: F401 'ifilter' imported but unused
D:\Development\pemjh\pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge010\challenge010.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge011/challenge011.py _________________
C:  2, 0: Line too long (1212/100) (line-too-long)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCols" (invalid-name)
C: 10, 8: Invalid variable name "currentRow" (invalid-name)
C: 12,12: Invalid variable name "nextChunk" (invalid-name)
C: 31,36: More than one statement on a single line (multiple-statements)
C: 38,40: More than one statement on a single line (multiple-statements)
C: 45,40: More than one statement on a single line (multiple-statements)
C: 52,36: More than one statement on a single line (multiple-statements)
W: 11,12: Unused variable 'index' (unused-variable)
R:  1, 0: Too many branches (16/12) (too-many-branches)
C: 58, 0: Invalid constant name "answer" (invalid-name)
W: 61, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:61:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge012/challenge012.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 15, 0: Invalid function name "triangleDivisors" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 16, 4: Invalid variable name "n" (invalid-name)
C: 17, 4: Invalid variable name "nOdd" (invalid-name)
C: 18, 4: Invalid variable name "nEven" (invalid-name)
C: 19, 4: Invalid variable name "knownDivisors" (invalid-name)
C: 24,12: Invalid variable name "nOdd" (invalid-name)
C: 27,12: Invalid variable name "nEven" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36,22: More than one statement on a single line (multiple-statements)
W: 38,12: Using possibly undefined loop variable 'n' (undefined-loop-variable)
W: 38,17: Using possibly undefined loop variable 'n' (undefined-loop-variable)
C: 40, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge013/challenge013.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:111, 0: Invalid constant name "answer" (invalid-name)
W:114, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:114:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge014/challenge014.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getChainSize" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "knownChains" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "knownChains" (invalid-name)
C: 31, 8: Invalid variable name "newChain" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge015/challenge015.py _________________
C:  7, 0: No space allowed around keyword argument assignment
def multiplierGen(n = 0):
                    ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "multiplierGen" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid function name "getRoutes" (invalid-name)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge016/challenge016.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge016\challenge016.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge017/challenge017.py _________________
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 37, 0: Trailing whitespace (trailing-whitespace)
C:103, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumberLength" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "hundredRep" (invalid-name)
C:  1, 0: Invalid argument name "andRep" (invalid-name)
C:  1, 0: Invalid argument name "thousandRep" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "tempN" (invalid-name)
C:  7, 8: Invalid variable name "numberRepresentation" (invalid-name)
C: 13,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 16,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 18,12: Invalid variable name "tempN" (invalid-name)
C: 22,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 29,16: Invalid variable name "tempN" (invalid-name)
C: 31,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 35,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 41, 0: Missing function docstring (missing-docstring)
C: 70, 4: Invalid variable name "knownInts" (invalid-name)
C:100, 4: Invalid variable name "endLine" (invalid-name)
W: 70, 4: Unused variable 'knownInts' (unused-variable)
W:100, 4: Unused variable 'endLine' (unused-variable)
C:106, 0: Invalid constant name "answer" (invalid-name)
W:109, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:5: F841 local variable 'knownInts' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:100:5: F841 local variable 'endLine' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:109:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge018/challenge018.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge018\challenge018.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge019/challenge019.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isLeapYear" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "getYearDays" (invalid-name)
C:  5, 0: Invalid argument name "y" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "getFirstJan" (invalid-name)
C: 11, 0: Invalid argument name "y" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "totalDays" (invalid-name)
C: 14, 8: Invalid variable name "totalDays" (invalid-name)
C: 17, 0: Invalid function name "monthStartDays" (invalid-name)
C: 17, 0: Invalid argument name "y" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "monthLengths" (invalid-name)
C: 25, 8: Invalid variable name "m" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "totalDays" (invalid-name)
C: 34, 8: Invalid variable name "y" (invalid-name)
C: 36,12: Invalid variable name "d" (invalid-name)
C: 38,16: Invalid variable name "totalDays" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
W: 45, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge020/challenge020.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge020\challenge020.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge021/challenge021.py _________________
C: 18, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
W: 11, 4: Redefining built-in 'dict' (redefined-builtin)
C: 12, 8: Invalid variable name "a" (invalid-name)
C: 14, 8: Invalid variable name "b" (invalid-name)
C: 15,12: Invalid variable name "d" (invalid-name)
C: 16,12: Invalid variable name "b" (invalid-name)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'

_________________ [pylint] pemjh/challenge022/challenge022.py _________________
C: 25, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getNames" (invalid-name)
C:  4, 0: Invalid argument name "fp" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7,21: Invalid variable name "f" (invalid-name)
C: 16, 0: Invalid function name "scoredNames" (invalid-name)
C: 16, 0: Invalid argument name "f" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 21,12: Invalid variable name "c" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 29, 8: Invalid variable name "s" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W: 37, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:37:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge023/challenge023.py _________________
C: 10, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "sumOfDivisors" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "p" (invalid-name)
C: 13,12: Invalid variable name "p" (invalid-name)
C: 23, 0: Invalid function name "isSum" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 0: Missing function docstring (missing-docstring)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge024/challenge024.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge024\challenge024.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge025/challenge025.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8,11: Invalid variable name "c" (invalid-name)
C:  9, 8: Invalid variable name "l" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge026/challenge026.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "biggestD" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C: 14,12: Invalid variable name "newSize" (invalid-name)
C: 18,16: Invalid variable name "biggestD" (invalid-name)
C: 20,12: Invalid variable name "newSize" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import string (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge026\challenge026.py:1:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge027/challenge027.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "aMax" (invalid-name)
C: 13, 4: Invalid variable name "bMax" (invalid-name)
C: 16, 4: Invalid variable name "bS" (invalid-name)
C: 17, 8: Invalid variable name "b" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "n" (invalid-name)
C: 21,16: Invalid variable name "f" (invalid-name)
C: 22,35: More than one statement on a single line (multiple-statements)
C: 23,16: Invalid variable name "n" (invalid-name)
C: 27,16: Invalid variable name "aMax" (invalid-name)
C: 28,16: Invalid variable name "bMax" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge027\challenge027.py:6:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge027\challenge027.py:35:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge028/challenge028.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge028\challenge028.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge029/challenge029.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "aLower" (invalid-name)
C:  3, 4: Invalid variable name "aUpper" (invalid-name)
C:  4, 4: Invalid variable name "bLower" (invalid-name)
C:  5, 4: Invalid variable name "bUpper" (invalid-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  9,12: Invalid variable name "b" (invalid-name)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge029\challenge029.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge030/challenge030.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "perDigit" (invalid-name)
C:  7, 4: Invalid variable name "grandTotal" (invalid-name)
C: 11,12: Invalid variable name "c" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "grandTotal" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge030\challenge030.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge031/challenge031.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPatternCount" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid constant name "answer" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
W: 22, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge031\challenge031.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge032/challenge032.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge032\challenge032.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge033/challenge033.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "totalNum" (invalid-name)
C:  9, 4: Invalid variable name "totalDen" (invalid-name)
C: 20,16: Invalid variable name "n1" (invalid-name)
C: 21,16: Invalid variable name "n2" (invalid-name)
C: 22,16: Invalid variable name "d3" (invalid-name)
C: 23,16: Invalid variable name "d4" (invalid-name)
C: 29,24: Invalid variable name "totalNum" (invalid-name)
C: 30,24: Invalid variable name "totalDen" (invalid-name)
C: 37,24: Invalid variable name "totalNum" (invalid-name)
C: 38,24: Invalid variable name "totalDen" (invalid-name)
C: 40, 4: Invalid variable name "totalNum" (invalid-name)
C: 40,14: Invalid variable name "totalDen" (invalid-name)
C: 44, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:47:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge034/challenge034.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "getLimit" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "factSum" (invalid-name)
C:  9, 4: Invalid variable name "factNine" (invalid-name)
C: 13, 8: Invalid variable name "factSum" (invalid-name)
C: 15,29: More than one statement on a single line (multiple-statements)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 8: Invalid variable name "iStr" (invalid-name)
C: 35, 8: Invalid variable name "iTotal" (invalid-name)
C: 36,12: Invalid variable name "c" (invalid-name)
C: 37,12: Invalid variable name "iTotal" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge035/challenge035.py _________________
C: 32, 0: Wrong continued indentation.
              if b == True and
              ^   | (bad-continuation)
C: 33, 0: Wrong continued indentation.
              ((p < 10) or not any(c in str(p) for c in disallowedChars))])
              ^   | (bad-continuation)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "nStr" (invalid-name)
C: 15, 8: Invalid variable name "nextString" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "disallowedChars" (invalid-name)
C: 35, 4: Invalid variable name "circularCount" (invalid-name)
C: 39, 8: Invalid variable name "circularList" (invalid-name)
C: 42, 8: Invalid variable name "allFound" (invalid-name)
C: 48,16: Invalid variable name "allFound" (invalid-name)
C: 51,12: Invalid variable name "circularCount" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sievedPrimes imported from utils.numbers (unused-import)
W:  5, 0: Unused fact imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'fact' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'sievedPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
D:\Development\pemjh\pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge035\challenge035.py:58:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge036/challenge036.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getBinaryString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "binStr" (invalid-name)
C:  5, 8: Invalid variable name "binStr" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 18, 8: Invalid variable name "decStr" (invalid-name)
C: 21,12: Invalid variable name "binStr" (invalid-name)
W: 11, 4: Unused variable 'limit' (unused-variable)
W: 14, 4: Unused variable 'binary' (unused-variable)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W: 29, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge036\challenge036.py:11:5: F841 local variable 'limit' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:14:5: F841 local variable 'binary' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge037/challenge037.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "isTruncPrime" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 12,23: More than one statement on a single line (multiple-statements)
C: 13,45: More than one statement on a single line (multiple-statements)
C: 18,51: More than one statement on a single line (multiple-statements)
C: 23, 0: Missing function docstring (missing-docstring)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge038/challenge038.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "isPandigital" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "m" (invalid-name)
C: 12,11: Invalid variable name "l" (invalid-name)
C: 12,14: Invalid variable name "u" (invalid-name)
C: 13,12: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge038\challenge038.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge039/challenge039.py _________________
W: 18, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
W: 19, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numPerimeters" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "a" (invalid-name)
C: 16, 8: Invalid variable name "bLimit" (invalid-name)
C: 17,12: Invalid variable name "b" (invalid-name)
C: 18,11: Invalid variable name "c" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "highestVal" (invalid-name)
C: 30, 8: Invalid variable name "iCount" (invalid-name)
C: 33,12: Invalid variable name "highestVal" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge039\challenge039.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge040/challenge040.py _________________
C: 11, 0: No space allowed before bracket
        total *= int (str(currentValue)[index - currentN - 1])
                     ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "currentN" (invalid-name)
C:  5, 4: Invalid variable name "currentValue" (invalid-name)
C:  9,12: Invalid variable name "currentValue" (invalid-name)
C: 10,12: Invalid variable name "currentN" (invalid-name)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
D:\Development\pemjh\pemjh\challenge040\challenge040.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge041/challenge041.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
F:  6, 0: Unable to import 'utils.strings' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 15,36: More than one statement on a single line (multiple-statements)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge041\challenge041.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge042/challenge042.py _________________
C: 35, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "scoreWord" (invalid-name)
C:  4, 0: Invalid argument name "w" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "x" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12,62: Invalid variable name "f" (invalid-name)
C: 23, 8: Invalid variable name "nTriangleWords" (invalid-name)
C: 30,16: Invalid variable name "nTriangleWords" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge042\challenge042.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge043/challenge043.py _________________
C:  8, 0: Trailing whitespace (trailing-whitespace)
W: 19, 0: Bad indentation. Found 12 spaces, expected 8 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.strings' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge044/challenge044.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "isPent" (invalid-name)
C:  6, 0: Invalid argument name "p" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "n" (invalid-name)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "pk" (invalid-name)
C: 19, 8: Invalid variable name "performedOneStep" (invalid-name)
C: 20,12: Invalid variable name "pj" (invalid-name)
C: 21,12: Invalid variable name "diffPkPj" (invalid-name)
C: 22,45: More than one statement on a single line (multiple-statements)
C: 25,12: Invalid variable name "performedOneStep" (invalid-name)
C: 27,33: More than one statement on a single line (multiple-statements)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge044\challenge044.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge045/challenge045.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
W:  4, 0: Redefining built-in 'hex' (redefined-builtin)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "pentAndHex" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "p" (invalid-name)
C: 10, 4: Invalid variable name "h" (invalid-name)
C: 12, 8: Invalid variable name "pVal" (invalid-name)
C: 13, 8: Invalid variable name "hVal" (invalid-name)
C: 19,12: Invalid variable name "p" (invalid-name)
C: 21,12: Invalid variable name "h" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 26, 8: Redefining built-in 'next' (redefined-builtin)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge046/challenge046.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "hasCriteria" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "dSq" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "n" (invalid-name)
C: 25, 8: Invalid variable name "n" (invalid-name)
C: 26,36: More than one statement on a single line (multiple-statements)
C: 26,36: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge046\challenge046.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge047/challenge047.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "numPrimeFactors" (invalid-name)
C:  8, 0: Invalid argument name "nPrimes" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "n" (invalid-name)
C: 11, 8: Invalid variable name "pf" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Invalid function name "hasNumPrimes" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 20,30: More than one statement on a single line (multiple-statements)
C: 24, 0: Missing function docstring (missing-docstring)
W: 30, 4: Redefining name 'count' from outer scope (line 1) (redefined-outer-name)
C: 31, 8: Invalid variable name "p" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused count imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
D:\Development\pemjh\pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge048/challenge048.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid constant name "answer" (invalid-name)
W:  8, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge048\challenge048.py:8:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge049/challenge049.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 18, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 21,12: Invalid variable name "p1" (invalid-name)
C: 22,16: Invalid variable name "p2" (invalid-name)
C: 24,16: Invalid variable name "p3" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge049\challenge049.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge050/challenge050.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
W: 13, 4: Redefining name 'answer' from outer scope (line 26) (redefined-outer-name)
C:  9, 4: Invalid variable name "knownPrimes" (invalid-name)
C: 11, 4: Invalid variable name "nPrimes" (invalid-name)
C: 18,31: More than one statement on a single line (multiple-statements)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge050\challenge050.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge050\challenge050.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge051/challenge051.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "substitutePrimes" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid function name "has3SameDigits" (invalid-name)
C: 24, 0: Invalid argument name "n" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "w" (invalid-name)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
C: 39,12: Invalid variable name "w" (invalid-name)
C: 41,16: Invalid variable name "nPrimes" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge052/challenge052.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getSortedString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "x" (invalid-name)
C:  9, 8: Invalid variable name "x" (invalid-name)
C: 10, 8: Invalid variable name "xStr" (invalid-name)
C: 15,12: Invalid variable name "ix" (invalid-name)
C: 16,12: Invalid variable name "ixStr" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge053/challenge053.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge053\challenge053.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge054/challenge054.py _________________
C:122, 0: Trailing whitespace (trailing-whitespace)
C:131, 0: Trailing whitespace (trailing-whitespace)
C:133, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getDuplicateCounts" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "valCounts" (invalid-name)
C: 14, 0: Invalid function name "isStraight" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid function name "isFlush" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid function name "scoreHand" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 52, 8: Invalid variable name "c1" (invalid-name)
C: 52,12: Invalid variable name "c2" (invalid-name)
C: 53, 8: Invalid variable name "v1" (invalid-name)
C: 53,12: Invalid variable name "v2" (invalid-name)
R: 26, 0: Too many return statements (11/6) (too-many-return-statements)
R: 26, 0: Too many branches (15/12) (too-many-branches)
C: 96, 0: Invalid function name "compareHands" (invalid-name)
C: 96, 0: Invalid argument name "handOne" (invalid-name)
C: 96, 0: Invalid argument name "handTwo" (invalid-name)
C: 96, 0: Missing function docstring (missing-docstring)
C:100, 4: Invalid variable name "handOneScore" (invalid-name)
C:100,18: Invalid variable name "handTwoScore" (invalid-name)
C:106,12: Invalid variable name "c1" (invalid-name)
C:106,16: Invalid variable name "c2" (invalid-name)
C:114, 0: Missing function docstring (missing-docstring)
C:115, 4: Invalid variable name "faceConvert" (invalid-name)
C:118, 4: Invalid variable name "nHandOneWins" (invalid-name)
C:119,62: Invalid variable name "f" (invalid-name)
C:120,12: Invalid variable name "l" (invalid-name)
C:129,16: Invalid variable name "nHandOneWins" (invalid-name)
C:133, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace

_________________ [pylint] pemjh/challenge055/challenge055.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "becomesPalindrome" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "workingN" (invalid-name)
C:  6, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
D:\Development\pemjh\pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge055\challenge055.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge056/challenge056.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "a" (invalid-name)
C:  4,12: Invalid variable name "b" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
W: 16, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge056\challenge056.py:16:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge057/challenge057.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTopHeavy" (invalid-name)
C:  5, 8: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  8,15: Invalid variable name "d" (invalid-name)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 10,11: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nTopHeavy" (invalid-name)
W:  7,12: Unused variable 'i' (unused-variable)
C: 17, 0: Invalid constant name "answer" (invalid-name)
W: 20, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge057\challenge057.py:20:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge058/challenge058.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nPrimes" (invalid-name)
C: 13, 4: Invalid variable name "primeChecker" (invalid-name)
C: 22,16: Invalid variable name "nPrimes" (invalid-name)
W: 18,12: Unused variable 'j' (unused-variable)
W:  9, 4: Unused variable 'total' (unused-variable)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
D:\Development\pemjh\pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge059/challenge059.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 27,64: Invalid variable name "f" (invalid-name)
C: 29,12: Invalid variable name "l" (invalid-name)
W: 48, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge060/challenge060.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 64, 0: Line too long (118/100) (line-too-long)
C: 69, 0: Trailing whitespace (trailing-whitespace)
C: 85, 0: Line too long (141/100) (line-too-long)
C: 94, 0: Trailing whitespace (trailing-whitespace)
C: 95, 0: Trailing whitespace (trailing-whitespace)
C: 97, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid constant name "primeSet" (invalid-name)
C:  8, 0: Invalid constant name "maxPrime" (invalid-name)
C: 10, 0: Invalid function name "getNumLength" (invalid-name)
C: 10, 0: Invalid argument name "n" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 14, 8: Invalid variable name "l" (invalid-name)
C: 17, 0: Invalid argument name "m" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "isConcatPrime" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "newFirst" (invalid-name)
C: 25, 4: Invalid variable name "newLast" (invalid-name)
C: 29, 0: Invalid function name "getPrimePairs" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "nPrimes" (invalid-name)
C: 33, 8: Invalid variable name "m" (invalid-name)
C: 34, 8: Invalid variable name "p" (invalid-name)
C: 38,12: Invalid variable name "n" (invalid-name)
C: 39,12: Invalid variable name "q" (invalid-name)
C: 47, 0: Invalid function name "nextDigits" (invalid-name)
C: 47, 0: Invalid argument name "nToFind" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "currentSum" (invalid-name)
C: 49, 4: Invalid variable name "currentSolution" (invalid-name)
C: 50, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 61,16: Invalid variable name "foundSolution" (invalid-name)
C: 64,16: Invalid variable name "foundSolution" (invalid-name)
C: 67,16: Invalid variable name "currentSolution" (invalid-name)
C: 68,16: Invalid variable name "currentSolutionSum" (invalid-name)
C: 71, 0: Invalid function name "nextDigitsDict" (invalid-name)
C: 71, 0: Invalid argument name "nToFind" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 72, 4: Invalid variable name "currentSum" (invalid-name)
C: 73, 4: Invalid variable name "currentSolution" (invalid-name)
C: 74, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 77, 8: Invalid variable name "p" (invalid-name)
C: 83,12: Invalid variable name "foundSolution" (invalid-name)
C: 86,12: Invalid variable name "newPotential" (invalid-name)
C: 87,12: Invalid variable name "foundSolution" (invalid-name)
C: 92,12: Invalid variable name "currentSolution" (invalid-name)
C: 93,12: Invalid variable name "currentSolutionSum" (invalid-name)
C: 98, 0: Missing function docstring (missing-docstring)
W:109, 4: Redefining name 'answer' from outer scope (line 116) (redefined-outer-name)
C:116, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace

_________________ [pylint] pemjh/challenge061/challenge061.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "hasDuplicates" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "eachInList" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 17,12: Invalid variable name "newNums" (invalid-name)
C: 18,12: Invalid variable name "newLists" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
W: 51, 4: Redefining built-in 'oct' (redefined-builtin)
W: 55, 4: Redefining built-in 'all' (redefined-builtin)
W: 43, 4: Redefining built-in 'hex' (redefined-builtin)
R: 24, 0: Too many local variables (27/15) (too-many-locals)
C: 28, 4: Invalid variable name "allLists" (invalid-name)
C: 35, 4: Invalid variable name "sq" (invalid-name)
C: 56, 4: Invalid variable name "d" (invalid-name)
C: 57, 8: Invalid variable name "n" (invalid-name)
C: 64, 8: Invalid variable name "n" (invalid-name)
C: 70,16: Invalid variable name "l" (invalid-name)
C: 76, 8: Invalid variable name "n1" (invalid-name)
C: 79,12: Invalid variable name "n2" (invalid-name)
C: 82,16: Invalid variable name "n3" (invalid-name)
C: 85,20: Invalid variable name "n4" (invalid-name)
C: 88,24: Invalid variable name "n5" (invalid-name)
C: 91,28: Invalid variable name "n6" (invalid-name)
C: 94,32: Invalid variable name "n7" (invalid-name)
R: 24, 0: Too many branches (17/12) (too-many-branches)
C:101, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'

_________________ [pylint] pemjh/challenge062/challenge062.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "n" (invalid-name)
C:  8, 8: Invalid variable name "potentialAnswer" (invalid-name)
C: 19,20: Invalid variable name "nCubes" (invalid-name)
C: 21,12: Invalid variable name "nCubes" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge063/challenge063.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14,26: More than one statement on a single line (multiple-statements)
C: 20,29: More than one statement on a single line (multiple-statements)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge064/challenge064.py _________________
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getPeriodLength" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "pathGen" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 4: Invalid variable name "nOdd" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 32,12: Invalid variable name "nOdd" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge065/challenge065.py _________________
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "nextDen" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused divisors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge065\challenge065.py:4:1: F401 'divisors' imported but unused
D:\Development\pemjh\pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge066/challenge066.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "diophantineX" (invalid-name)
C:  8, 0: Invalid argument name "d" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "x" (invalid-name)
C: 10,11: Invalid variable name "y" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)

_________________ [pylint] pemjh/challenge067/challenge067.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  9, 0: Unable to import 'utils.numbers' (import-error)
C: 11, 0: Missing function docstring (missing-docstring)
W: 14,65: Redefining built-in 'file' (redefined-builtin)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge067\challenge067.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge068/challenge068.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPairs" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "getSpokes" (invalid-name)
C:  7, 0: Invalid argument name "startIndex" (invalid-name)
C:  7, 0: Invalid argument name "nSpokes" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 18,16: Invalid variable name "nextSpokes" (invalid-name)
C: 19,16: Invalid variable name "y" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 54,20: Unused variable 'move' (unused-variable)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)

_________________ [pylint] pemjh/challenge069/challenge069.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "sp" (invalid-name)
C: 11, 4: Invalid variable name "nPhi" (invalid-name)
C: 12,11: Invalid variable name "n" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge070/challenge070.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "isPermutation" (invalid-name)
C:  8, 0: Invalid argument name "a" (invalid-name)
C:  8, 0: Invalid argument name "b" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 17,11: Invalid variable name "p" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused import string (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge071/challenge071.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "targetNum" (invalid-name)
C:  5, 4: Invalid variable name "targetDen" (invalid-name)
C:  8, 4: Invalid variable name "bestNum" (invalid-name)
C:  9, 4: Invalid variable name "bestDen" (invalid-name)
C: 13, 8: Invalid variable name "highNum" (invalid-name)
C: 14, 8: Invalid variable name "lowNum" (invalid-name)
C: 18,55: More than one statement on a single line (multiple-statements)
C: 20,12: Invalid variable name "leftSide" (invalid-name)
C: 21,12: Invalid variable name "rightSide" (invalid-name)
C: 23,16: Invalid variable name "bestNum" (invalid-name)
C: 23,25: Invalid variable name "bestDen" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge072/challenge072.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge073/challenge073.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "shareDivisors" (invalid-name)
C:  8, 0: Invalid argument name "n1" (invalid-name)
C:  8, 0: Invalid argument name "n2" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "d" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "upperNum" (invalid-name)
C: 19, 4: Invalid variable name "upperDen" (invalid-name)
C: 20, 4: Invalid variable name "lowerNum" (invalid-name)
C: 21, 4: Invalid variable name "lowerDen" (invalid-name)
C: 25, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 26, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 28, 8: Invalid variable name "upperLimit" (invalid-name)
C: 29, 8: Invalid variable name "upperLimit" (invalid-name)
C: 31, 8: Invalid variable name "rangeLimits" (invalid-name)
W: 31, 8: Unused variable 'rangeLimits' (unused-variable)
C: 39, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:31:9: F841 local variable 'rangeLimits' is assigned to but never used

_________________ [pylint] pemjh/challenge074/challenge074.py _________________
C:  2, 0: Line too long (109/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "factSum" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "chainSize" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "w" (invalid-name)
C:  8, 4: Invalid variable name "firstW" (invalid-name)
C:  9, 4: Invalid variable name "routeLen" (invalid-name)
C: 17,12: Invalid variable name "routeLen" (invalid-name)
C: 19,12: Invalid variable name "w" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 27, 4: Unused variable 'target' (unused-variable)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
D:\Development\pemjh\pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:27:5: F841 local variable 'target' is assigned to but never used

_________________ [pylint] pemjh/challenge075/challenge075.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "l" (invalid-name)
C:  8,15: Invalid variable name "a" (invalid-name)
C:  8,18: Invalid variable name "b" (invalid-name)
C:  8,21: Invalid variable name "c" (invalid-name)
C: 21, 4: Invalid variable name "l" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge076/challenge076.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numBreakDowns" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  9, 8: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nBreakDowns" (invalid-name)
C: 12,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 14,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge077/challenge077.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "pc" (invalid-name)
C: 17,12: Invalid variable name "a" (invalid-name)
C: 18,12: Invalid variable name "b" (invalid-name)
C: 21,16: Invalid variable name "abSums" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)

_________________ [pylint] pemjh/challenge078/challenge078.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
W:  6, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W:  7, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W: 15, 0: Found indentation with tabs instead of spaces (mixed-indentation)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "n" (invalid-name)
C:  3, 4: Invalid variable name "p" (invalid-name)
C:  6, 7: Invalid variable name "s" (invalid-name)
C: 10,16: Invalid variable name "s" (invalid-name)
C: 13,16: Invalid variable name "s" (invalid-name)
C: 17, 8: Invalid variable name "m" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge079/challenge079.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
W:  2, 0: Unused import string (unused-import)
W: 14, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge079\challenge079.py:2:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge079\challenge079.py:14:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge080/challenge080.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "buildRoot" (invalid-name)
C:  3, 0: Invalid argument name "sq" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W: 14, 4: Redefining name 'answer' from outer scope (line 36) (redefined-outer-name)
W: 18, 8: Redefining built-in 'next' (redefined-builtin)
C:  5, 4: Invalid function name "getNextNum" (invalid-name)
C:  5, 4: Missing function docstring (missing-docstring)
W:  5,19: Unused argument 'target' (unused-argument)
C: 13, 4: Invalid variable name "prevNum" (invalid-name)
C: 24, 8: Invalid variable name "prevNum" (invalid-name)
W: 16, 8: Unused variable 'i' (unused-variable)
C: 28, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge081/challenge081.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "addRows" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "r1" (invalid-name)
C:  7, 8: Invalid variable name "r2" (invalid-name)
C: 10,12: Invalid variable name "i1" (invalid-name)
C: 11,12: Invalid variable name "i2" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 21,63: Invalid variable name "f" (invalid-name)
C: 22, 8: Invalid variable name "tr" (invalid-name)
C: 26,12: Invalid variable name "n" (invalid-name)
C: 26,15: Invalid variable name "l" (invalid-name)
W: 28,26: Using possibly undefined loop variable 'i' (undefined-loop-variable)
C: 39, 4: Invalid variable name "tr" (invalid-name)
C: 43, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge082/challenge082.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "combineColumns" (invalid-name)
C:  5, 0: Invalid argument name "c1" (invalid-name)
C:  5, 0: Invalid argument name "c2" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "downRow" (invalid-name)
C: 11, 8: Invalid variable name "v1" (invalid-name)
C: 11,12: Invalid variable name "v2" (invalid-name)
C: 23, 4: Invalid variable name "newRow" (invalid-name)
C: 26, 8: Invalid variable name "v1" (invalid-name)
C: 26,12: Invalid variable name "v2" (invalid-name)
C: 39, 0: Missing function docstring (missing-docstring)
C: 42,23: Invalid variable name "f" (invalid-name)
W: 44,16: Used builtin function 'map' (bad-builtin)
W: 48,26: Lambda may not be necessary (unnecessary-lambda)
C: 50, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused izip imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge082\challenge082.py:3:1: F401 'izip' imported but unused
D:\Development\pemjh\pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge083/challenge083.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getGrid" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6,63: Invalid variable name "f" (invalid-name)
C:  9,12: Invalid variable name "nextLine" (invalid-name)
C: 16, 0: Invalid function name "compareToProcess" (invalid-name)
C: 16, 0: Invalid argument name "m" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 27, 0: Missing function docstring (missing-docstring)
W: 35,11: Used builtin function 'map' (bad-builtin)
W: 35,11: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 35,27: Used builtin function 'map' (bad-builtin)
W: 35,27: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C: 38, 4: Invalid variable name "toProcess" (invalid-name)
C: 45, 8: Invalid variable name "x" (invalid-name)
C: 45,11: Invalid variable name "y" (invalid-name)
C: 55,12: Invalid variable name "nx" (invalid-name)
C: 55,16: Invalid variable name "ny" (invalid-name)
C: 56,12: Invalid variable name "newSquare" (invalid-name)
C: 59,12: Invalid variable name "newLength" (invalid-name)
W: 40, 4: Unused variable 'processed' (unused-variable)
C: 77, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge083\challenge083.py:40:5: F841 local variable 'processed' is assigned to but never used
D:\Development\pemjh\pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'

_________________ [pylint] pemjh/challenge084/challenge084.py _________________
C:  8, 0: No space allowed around keyword argument assignment
def chanceCardMove(current, prev = [0]):
                                 ^ (bad-whitespace)
C: 52, 0: No space allowed around keyword argument assignment
def communityChestCardMove(current, prev = [0]):
                                         ^ (bad-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C: 77, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:100, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "rollDice" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  8, 0: Dangerous default value [] as argument (dangerous-default-value)
C:  8, 0: Invalid function name "chanceCardMove" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
R:  8, 0: Too many return statements (13/6) (too-many-return-statements)
R:  8, 0: Too many branches (14/12) (too-many-branches)
W: 52, 0: Dangerous default value [] as argument (dangerous-default-value)
C: 52, 0: Invalid function name "communityChestCardMove" (invalid-name)
C: 52, 0: Missing function docstring (missing-docstring)
C: 68, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "doubleCount" (invalid-name)
C: 85,12: Invalid variable name "doubleCount" (invalid-name)
C: 87,12: Invalid variable name "doubleCount" (invalid-name)
C: 94,12: Invalid variable name "doubleCount" (invalid-name)
C:111, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace

_________________ [pylint] pemjh/challenge085/challenge085.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numRects" (invalid-name)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Invalid argument name "w" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "rh" (invalid-name)
C:  5,12: Invalid variable name "rw" (invalid-name)
C:  6,12: Invalid variable name "numAcross" (invalid-name)
C:  7,12: Invalid variable name "numDown" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 32,16: Invalid variable name "areaRectangles" (invalid-name)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge086/challenge086.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def isInt(a, msq, sqLib, found = list()):
                               ^ (bad-whitespace)
C:  2, 0: Unnecessary parens after 'return' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value list() (__builtin__.list) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "isInt" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "sqLib" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  1,25: Unused argument 'found' (unused-argument)
C:  4, 0: Invalid function name "getNumPairs" (invalid-name)
C:  4, 0: Invalid argument name "pairSum" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nPairs" (invalid-name)
C:  8, 4: Invalid variable name "a" (invalid-name)
C:  9, 4: Invalid variable name "b" (invalid-name)
C: 11, 8: Invalid variable name "a" (invalid-name)
C: 12, 8: Invalid variable name "b" (invalid-name)
C: 16,12: Invalid variable name "nPairs" (invalid-name)
C: 19, 0: Invalid function name "getStepSize" (invalid-name)
C: 19, 0: Invalid argument name "m" (invalid-name)
C: 19, 0: Invalid argument name "sqLib" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "nStep" (invalid-name)
W: 25, 4: Unreachable code (unreachable)
C: 27, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "sqLimit" (invalid-name)
C: 33, 4: Invalid variable name "m" (invalid-name)
C: 36, 8: Invalid variable name "m" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge087/challenge087.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sqLimit" (invalid-name)
C: 13, 4: Invalid variable name "sqPrimes" (invalid-name)
C: 16, 4: Invalid variable name "cuLimit" (invalid-name)
C: 17, 4: Invalid variable name "cuPrimes" (invalid-name)
C: 20, 4: Invalid variable name "foLimit" (invalid-name)
C: 21, 4: Invalid variable name "foPrimes" (invalid-name)
C: 23, 4: Invalid variable name "nAnswers" (invalid-name)
C: 24, 8: Invalid variable name "s" (invalid-name)
C: 25,12: Invalid variable name "c" (invalid-name)
C: 26,12: Invalid variable name "sc" (invalid-name)
C: 29,16: Invalid variable name "f" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge087\challenge087.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge088/challenge088.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def findPossibleProducts(limit, known = dict()):
                                      ^ (bad-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "findPossibleProducts" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12,20: Invalid variable name "s" (invalid-name)
C: 12,23: Invalid variable name "d" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 25, 8: Invalid variable name "pr" (invalid-name)
C: 25,12: Invalid variable name "s" (invalid-name)
C: 25,15: Invalid variable name "d" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ceil imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge088\challenge088.py:1:1: F401 'ceil' imported but unused
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace

_________________ [pylint] pemjh/challenge089/challenge089.py _________________
C: 56, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C: 17, 0: Invalid function name "convertChar" (invalid-name)
C: 17, 0: Invalid argument name "c" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
R: 17, 0: Too many return statements (7/6) (too-many-return-statements)
C: 33, 0: Invalid function name "decypherNumeral" (invalid-name)
C: 33, 0: Invalid argument name "s" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "currentTotal" (invalid-name)
C: 38, 8: Invalid variable name "v" (invalid-name)
C: 41,12: Invalid variable name "currentTotal" (invalid-name)
C: 43,12: Invalid variable name "currentTotal" (invalid-name)
C: 46,12: Invalid variable name "currentTotal" (invalid-name)
C: 53, 0: Invalid function name "getNumeral" (invalid-name)
C: 53, 0: Invalid argument name "n" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 61,13: Invalid variable name "c" (invalid-name)
C: 62, 8: Invalid variable name "nDiv" (invalid-name)
C: 67, 0: Invalid function name "getRomanNumeralSaving" (invalid-name)
C: 67, 0: Invalid argument name "s" (invalid-name)
C: 67, 0: Missing function docstring (missing-docstring)
C: 69, 4: Invalid variable name "preLength" (invalid-name)
C: 75, 4: Invalid variable name "newNumeral" (invalid-name)
C: 76, 4: Invalid variable name "newLength" (invalid-name)
C: 81, 0: Missing function docstring (missing-docstring)
C: 83,62: Invalid variable name "f" (invalid-name)
C: 87, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
D:\Development\pemjh\pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge090/challenge090.py _________________
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 78, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "get6Combs" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "c6" (invalid-name)
C: 10, 8: Invalid variable name "i6" (invalid-name)
C: 15, 8: Invalid variable name "i6" (invalid-name)
C: 20, 0: Invalid function name "fillRemaining" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid function name "validAddition" (invalid-name)
C: 29, 0: Invalid argument name "newFace" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 35, 0: Invalid function name "amendCubesForSquare" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "newCube1" (invalid-name)
C: 56, 8: Invalid variable name "newCube0" (invalid-name)
C: 62, 4: Invalid variable name "newCube0" (invalid-name)
C: 63, 4: Invalid variable name "newCube1" (invalid-name)
C: 71, 0: Invalid function name "buildCubes" (invalid-name)
C: 71, 0: Invalid argument name "squaresLeft" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nextSquare" (invalid-name)
C: 77, 4: Invalid variable name "suitableCubes" (invalid-name)
C:109,16: Invalid variable name "c0" (invalid-name)
C:110,20: Invalid variable name "c1" (invalid-name)
R: 71, 0: Too many branches (13/12) (too-many-branches)
C:116, 0: Missing function docstring (missing-docstring)
C:117, 4: Invalid variable name "squareNumbers" (invalid-name)
C:119, 4: Invalid variable name "possibleNumbers" (invalid-name)
C:125, 8: Invalid variable name "c" (invalid-name)
W:119, 4: Unused variable 'possibleNumbers' (unused-variable)
W:125, 8: Unused variable 'c' (unused-variable)
C:129, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:119:5: F841 local variable 'possibleNumbers' is assigned to but never used

_________________ [pylint] pemjh/challenge091/challenge091.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "bruteForce" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTriangles" (invalid-name)
C:  5, 8: Invalid variable name "x1" (invalid-name)
C:  6,12: Invalid variable name "y1" (invalid-name)
C:  9,16: Invalid variable name "nTriangles" (invalid-name)
C: 12,16: Invalid variable name "nTriangles" (invalid-name)
C: 15,20: Invalid variable name "x2" (invalid-name)
C: 16,24: Invalid variable name "y2" (invalid-name)
C: 29,32: Invalid variable name "nTriangles" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "gridSize" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge092/challenge092.py _________________
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 87, 0: Trailing whitespace (trailing-whitespace)
C:112, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Invalid function name "getDigits" (invalid-name)
C:  6, 0: Invalid argument name "n" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "workingN" (invalid-name)
C: 11, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 20, 8: Invalid variable name "workingN" (invalid-name)
C: 29,20: Invalid variable name "d" (invalid-name)
C: 31,16: Invalid variable name "workingN" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "n" (invalid-name)
C: 41, 8: Invalid variable name "workingN" (invalid-name)
C: 45,12: Invalid variable name "workingN" (invalid-name)
C: 46,19: Invalid variable name "c" (invalid-name)
C: 52,12: Invalid variable name "workingN" (invalid-name)
W: 42, 8: Unused variable 'route' (unused-variable)
C: 58, 0: Invalid function name "buildNumber" (invalid-name)
C: 58, 0: Missing function docstring (missing-docstring)
C: 61, 0: Missing function docstring (missing-docstring)
C: 73, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "prevI" (invalid-name)
C: 75, 4: Invalid variable name "nI" (invalid-name)
C: 80,12: Invalid variable name "nI" (invalid-name)
C: 83,12: Invalid variable name "prevI" (invalid-name)
C: 84,12: Invalid variable name "nI" (invalid-name)
C: 90, 0: Invalid function name "squareVal" (invalid-name)
C: 90, 0: Missing function docstring (missing-docstring)
C: 91, 4: Invalid variable name "n" (invalid-name)
C: 96, 8: Invalid variable name "n" (invalid-name)
C:100, 0: Missing function docstring (missing-docstring)
C:101, 4: Invalid variable name "n" (invalid-name)
C:108,12: Invalid variable name "n" (invalid-name)
C:110, 0: Missing function docstring (missing-docstring)
C:111, 4: Invalid variable name "nDigits" (invalid-name)
C:120, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:42:9: F841 local variable 'route' is assigned to but never used
D:\Development\pemjh\pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:123:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge093/challenge093.py _________________
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 96, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nLeft" (invalid-name)
C: 12, 0: Invalid argument name "a" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "op" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid argument name "l" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "v" (invalid-name)
C: 34, 0: Invalid function name "equatedNumbers" (invalid-name)
C: 34, 0: Invalid argument name "a" (invalid-name)
C: 34, 0: Invalid argument name "b" (invalid-name)
C: 34, 0: Invalid argument name "c" (invalid-name)
C: 34, 0: Invalid argument name "d" (invalid-name)
C: 34, 0: Missing function docstring (missing-docstring)
W: 40, 8: No exception type(s) specified (bare-except)
C: 39,13: More than one statement on a single line (multiple-statements)
C: 40,16: More than one statement on a single line (multiple-statements)
W: 44, 8: No exception type(s) specified (bare-except)
C: 43,13: More than one statement on a single line (multiple-statements)
C: 44,16: More than one statement on a single line (multiple-statements)
W: 48, 8: No exception type(s) specified (bare-except)
C: 47,13: More than one statement on a single line (multiple-statements)
C: 48,16: More than one statement on a single line (multiple-statements)
W: 52, 8: No exception type(s) specified (bare-except)
C: 51,13: More than one statement on a single line (multiple-statements)
C: 52,16: More than one statement on a single line (multiple-statements)
W: 56, 8: No exception type(s) specified (bare-except)
C: 55,13: More than one statement on a single line (multiple-statements)
C: 56,16: More than one statement on a single line (multiple-statements)
C: 60, 0: Missing function docstring (missing-docstring)
C: 68, 8: Invalid variable name "a" (invalid-name)
C: 69,12: Invalid variable name "b" (invalid-name)
C: 70,16: Invalid variable name "c" (invalid-name)
C: 71,20: Invalid variable name "d" (invalid-name)
C: 77,28: Invalid variable name "n" (invalid-name)
W: 90,19: Using possibly undefined loop variable 'd' (undefined-loop-variable)
W: 92,15: Using possibly undefined loop variable 'c' (undefined-loop-variable)
W: 94,11: Using possibly undefined loop variable 'b' (undefined-loop-variable)
C: 99, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge094/challenge094.py _________________
C: 11, 0: Exactly one space required after comma
    prev_2 = (4,  0)
               ^ (bad-whitespace)
C: 12, 0: Exactly one space required after comma
    prev_1 = (15,  1)
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "n" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
W: 38,12: Redefining built-in 'long' (redefined-builtin)
C: 31, 8: Invalid variable name "c" (invalid-name)
C: 33, 8: Invalid variable name "rt" (invalid-name)
C: 50, 0: Invalid constant name "desc" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge095/challenge095.py _________________
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 47, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid function name "chainLengths" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "x" (invalid-name)
C: 38,12: Invalid variable name "lChain" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge096/challenge096.py _________________
C:104, 0: Trailing whitespace (trailing-whitespace)
C:120, 0: Line too long (150/100) (line-too-long)
C:228, 0: Trailing whitespace (trailing-whitespace)
C:240, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  6, 0: Invalid function name "sortSquareLengths" (invalid-name)
C:  6, 0: Invalid argument name "a" (invalid-name)
C:  6, 0: Invalid argument name "b" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "la" (invalid-name)
C:  8, 4: Invalid variable name "lb" (invalid-name)
C: 16, 0: Missing class docstring (missing-docstring)
C: 16, 0: Old-style class defined. (old-style-class)
C: 20, 4: Invalid argument name "s" (invalid-name)
W: 23,50: Unused variable 'i' (unused-variable)
C: 36, 4: Invalid method name "__loadData" (invalid-name)
C: 36, 4: Invalid argument name "s" (invalid-name)
C: 36, 4: Missing method docstring (missing-docstring)
C: 40,12: Invalid variable name "r" (invalid-name)
C: 42,16: Invalid variable name "c" (invalid-name)
C: 46, 4: Invalid method name "__getBox" (invalid-name)
C: 46, 4: Invalid argument name "r" (invalid-name)
C: 46, 4: Invalid argument name "c" (invalid-name)
C: 46, 4: Missing method docstring (missing-docstring)
C: 47, 8: Invalid function name "getStartIndex" (invalid-name)
C: 47, 8: Missing function docstring (missing-docstring)
C: 55, 8: Invalid variable name "rowStart" (invalid-name)
C: 57,12: Invalid variable name "columnStart" (invalid-name)
C: 61, 4: Invalid method name "__removeValueFromList" (invalid-name)
C: 61, 4: Invalid argument name "l" (invalid-name)
C: 61, 4: Missing method docstring (missing-docstring)
C: 62, 8: Invalid variable name "nRemoved" (invalid-name)
C: 64,12: Invalid variable name "sq" (invalid-name)
C: 66,16: Invalid variable name "nRemoved" (invalid-name)
R: 61, 4: Method could be a function (no-self-use)
C: 71, 4: Invalid method name "__setValue" (invalid-name)
C: 71, 4: Invalid argument name "r" (invalid-name)
C: 71, 4: Invalid argument name "c" (invalid-name)
C: 71, 4: Missing method docstring (missing-docstring)
C: 85, 8: Invalid variable name "sq" (invalid-name)
C: 96, 4: Invalid method name "__getAllBlocks" (invalid-name)
C: 96, 4: Missing method docstring (missing-docstring)
C:100,12: Invalid variable name "r" (invalid-name)
C:101,16: Invalid variable name "c" (invalid-name)
C:107, 4: Invalid method name "__processCompletedSquares" (invalid-name)
C:107, 4: Missing method docstring (missing-docstring)
C:110,12: Invalid variable name "r" (invalid-name)
C:111,16: Invalid variable name "sq" (invalid-name)
C:117, 4: Invalid method name "__processGroups" (invalid-name)
C:117, 4: Missing method docstring (missing-docstring)
C:124,16: Invalid variable name "sq" (invalid-name)
C:131,24: Invalid variable name "lSq" (invalid-name)
C:137,28: Invalid variable name "nRemoved" (invalid-name)
C:148, 4: Invalid method name "__getLocation" (invalid-name)
C:148, 4: Invalid argument name "sq" (invalid-name)
C:148, 4: Missing method docstring (missing-docstring)
C:150,12: Invalid variable name "r" (invalid-name)
C:151,16: Invalid variable name "c" (invalid-name)
C:157, 4: Invalid method name "__processOnlyInOneSquare" (invalid-name)
C:157, 4: Missing method docstring (missing-docstring)
C:176, 4: Missing method docstring (missing-docstring)
C:178,12: Invalid variable name "sRow" (invalid-name)
C:178,18: Invalid variable name "tRow" (invalid-name)
W:178,30: Access to a protected member __rows of a client class (protected-access)
C:179,16: Invalid variable name "sSquare" (invalid-name)
C:179,25: Invalid variable name "tSquare" (invalid-name)
C:183, 4: Missing method docstring (missing-docstring)
C:184, 8: Invalid variable name "progressMade" (invalid-name)
C:187,12: Invalid variable name "progressMade" (invalid-name)
C:189,12: Invalid variable name "progressMade" (invalid-name)
C:191,12: Invalid variable name "progressMade" (invalid-name)
C:195,12: Invalid variable name "unsolvedSquares" (invalid-name)
C:196,16: Invalid variable name "r" (invalid-name)
C:197,20: Invalid variable name "c" (invalid-name)
C:205,16: Invalid variable name "sq" (invalid-name)
W:211,20: Access to a protected member __setValue of a client class (protected-access)
W:214,24: Access to a protected member __solve of a client class (protected-access)
C:223, 4: Missing method docstring (missing-docstring)
C:224,12: Invalid variable name "r" (invalid-name)
C:225,16: Invalid variable name "sq" (invalid-name)
C:230, 4: Missing method docstring (missing-docstring)
C:231,12: Invalid variable name "r" (invalid-name)
C:232,16: Invalid variable name "sq" (invalid-name)
W:244, 8: Redefining built-in 'repr' (redefined-builtin)
C:245,12: Invalid variable name "r" (invalid-name)
C:247,16: Invalid variable name "sq" (invalid-name)
C:249,16: Invalid variable name "f1" (invalid-name)
C:250,16: Invalid variable name "f2" (invalid-name)
C:256, 0: Missing function docstring (missing-docstring)
W:267,12: Redefining built-in 'input' (redefined-builtin)
C:257,63: Invalid variable name "f" (invalid-name)
C:260, 8: Invalid variable name "nBroken" (invalid-name)
C:273,16: Invalid variable name "nBroken" (invalid-name)
W:263,12: Unused variable 'i' (unused-variable)
W:267,46: Unused variable 'j' (unused-variable)
W:260, 8: Unused variable 'nBroken' (unused-variable)
C:279, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge096\challenge096.py:3:1: F401 'sys' imported but unused
D:\Development\pemjh\pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge097/challenge097.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid constant name "answer" (invalid-name)
W:  7, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge097\challenge097.py:7:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge098/challenge098.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getMap" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'map' (redefined-builtin)
C:  6, 8: Invalid variable name "w" (invalid-name)
C:  6,11: Invalid variable name "s" (invalid-name)
C: 15, 0: Invalid function name "uniqueRight" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
W: 15,16: Redefining built-in 'map' (redefined-builtin)
C: 25, 0: Invalid function name "mapWord" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 25,18: Redefining built-in 'map' (redefined-builtin)
C: 27, 8: Invalid variable name "c" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
W: 81,16: Redefining built-in 'map' (redefined-builtin)
R: 32, 0: Too many local variables (19/15) (too-many-locals)
C: 35, 4: Invalid variable name "groupedWords" (invalid-name)
C: 37,62: Invalid variable name "f" (invalid-name)
C: 40,16: Invalid variable name "orderedWord" (invalid-name)
C: 46, 4: Invalid variable name "groupedWords" (invalid-name)
C: 70, 8: Invalid variable name "nWords" (invalid-name)
C: 75,12: Invalid variable name "lWord" (invalid-name)
C: 78,16: Invalid variable name "potentialSquare" (invalid-name)
C: 87,24: Invalid variable name "word2Square" (invalid-name)
C: 95, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)

_________________ [pylint] pemjh/challenge099/challenge099.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5,65: Invalid variable name "f" (invalid-name)
C:  6, 8: Invalid variable name "highestIndex" (invalid-name)
C:  7, 8: Invalid variable name "highestNumber" (invalid-name)
C:  8, 8: Invalid variable name "highestLine" (invalid-name)
C:  9,12: Invalid variable name "nL" (invalid-name)
C:  9,16: Invalid variable name "l" (invalid-name)
C: 10,12: Invalid variable name "n" (invalid-name)
C: 11,12: Invalid variable name "rootedPower" (invalid-name)
C: 13,16: Invalid variable name "highestNumber" (invalid-name)
C: 13,31: Invalid variable name "highestIndex" (invalid-name)
C: 13,45: Invalid variable name "highestLine" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
W: 19, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge099\challenge099.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge100/challenge100.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "b" (invalid-name)
C:  3, 4: Invalid variable name "n" (invalid-name)
C:  5, 8: Invalid variable name "b" (invalid-name)
C:  5,11: Invalid variable name "n" (invalid-name)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge101/challenge101.py _________________
C:  5, 0: Line too long (123/100) (line-too-long)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "highestPower" (invalid-name)
C: 14, 8: Invalid variable name "workedSequence" (invalid-name)
C: 16,12: Invalid variable name "x" (invalid-name)
C: 17,12: Invalid variable name "y" (invalid-name)
C: 28,16: Invalid variable name "y" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
D:\Development\pemjh\pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge102/challenge102.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "enclosesOrigin" (invalid-name)
C:  4, 0: Invalid argument name "x1" (invalid-name)
C:  4, 0: Invalid argument name "y1" (invalid-name)
C:  4, 0: Invalid argument name "x2" (invalid-name)
C:  4, 0: Invalid argument name "y2" (invalid-name)
C:  4, 0: Invalid argument name "x3" (invalid-name)
C:  4, 0: Invalid argument name "y3" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
R:  4, 0: Too many arguments (6/5) (too-many-arguments)
C: 17,12: Invalid variable name "i1" (invalid-name)
C: 18,12: Invalid variable name "i2" (invalid-name)
C: 21,12: Invalid variable name "i1" (invalid-name)
C: 22,12: Invalid variable name "i2" (invalid-name)
C: 25,12: Invalid variable name "i1" (invalid-name)
C: 26,12: Invalid variable name "i2" (invalid-name)
C: 33, 0: Invalid function name "getYIntercept" (invalid-name)
C: 33, 0: Invalid argument name "x1" (invalid-name)
C: 33, 0: Invalid argument name "y1" (invalid-name)
C: 33, 0: Invalid argument name "x2" (invalid-name)
C: 33, 0: Invalid argument name "y2" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "m" (invalid-name)
C: 38, 4: Invalid variable name "c" (invalid-name)
C: 43, 0: Missing function docstring (missing-docstring)
C: 46, 4: Invalid variable name "nEnclosing" (invalid-name)
C: 47,23: Invalid variable name "f" (invalid-name)
C: 48,12: Invalid variable name "l" (invalid-name)
C: 49,12: Invalid variable name "ax" (invalid-name)
C: 49,16: Invalid variable name "ay" (invalid-name)
C: 49,20: Invalid variable name "bx" (invalid-name)
C: 49,24: Invalid variable name "by" (invalid-name)
C: 49,28: Invalid variable name "cx" (invalid-name)
C: 49,32: Invalid variable name "cy" (invalid-name)
C: 51,16: Invalid variable name "nEnclosing" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge103/challenge103.py _________________
C: 41, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "subSets" (invalid-name)
C:  1, 0: Invalid argument name "l" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "setA" (invalid-name)
C:  5, 8: Invalid variable name "setB" (invalid-name)
C: 14, 0: Invalid argument name "l" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "B" (invalid-name)
C: 16,11: Invalid variable name "CPart" (invalid-name)
C: 19,16: Invalid variable name "C" (invalid-name)
C: 19,19: Invalid variable name "notUsed" (invalid-name)
C: 23,24: Invalid variable name "wB" (invalid-name)
C: 23,28: Invalid variable name "wC" (invalid-name)
C: 25,24: Invalid variable name "wB" (invalid-name)
C: 25,28: Invalid variable name "wC" (invalid-name)
W: 19,19: Unused variable 'notUsed' (unused-variable)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "midPoint" (invalid-name)
C: 48, 4: Invalid variable name "sumAns" (invalid-name)
C: 49, 8: Invalid variable name "b" (invalid-name)
C: 50, 8: Invalid variable name "newSet" (invalid-name)
C: 54,16: Invalid variable name "sumAns" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge104/challenge104.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "myEnumerate" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Invalid function name "fiboTrunc" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "aStart" (invalid-name)
C: 10,12: Invalid variable name "bStart" (invalid-name)
C: 11, 4: Invalid variable name "aEnd" (invalid-name)
C: 11,10: Invalid variable name "bEnd" (invalid-name)
C: 13, 4: Invalid variable name "endTrunc" (invalid-name)
C: 14, 4: Invalid variable name "startTrunc" (invalid-name)
C: 18, 8: Invalid variable name "aStart" (invalid-name)
C: 18,16: Invalid variable name "bStart" (invalid-name)
C: 19, 8: Invalid variable name "aEnd" (invalid-name)
C: 19,14: Invalid variable name "bEnd" (invalid-name)
C: 22, 8: Invalid variable name "aEnd" (invalid-name)
C: 23, 8: Invalid variable name "bEnd" (invalid-name)
C: 26,12: Invalid variable name "aStart" (invalid-name)
C: 27,12: Invalid variable name "bStart" (invalid-name)
C: 29, 8: Invalid variable name "aStartRet" (invalid-name)
C: 31,12: Invalid variable name "aStartRet" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "lowerLimit" (invalid-name)
C: 38,11: Invalid variable name "f" (invalid-name)
C: 39, 8: Invalid variable name "s" (invalid-name)
C: 40, 8: Invalid variable name "e" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused fibo imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge104\challenge104.py:1:1: F401 'fibo' imported but unused
D:\Development\pemjh\pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge105/challenge105.py _________________
C: 61, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "sizedSubsets" (invalid-name)
C:  4, 0: Invalid argument name "l" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "sizeL" (invalid-name)
C: 21, 0: Invalid function name "checkForDuplicateSetSums" (invalid-name)
C: 21, 0: Invalid argument name "l" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 22, 8: Invalid variable name "setSize" (invalid-name)
C: 23, 8: Invalid variable name "sumSub" (invalid-name)
C: 30, 0: Invalid argument name "l" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "nItems" (invalid-name)
C: 49, 0: Missing function docstring (missing-docstring)
C: 51,61: Invalid variable name "f" (invalid-name)
C: 60, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge106/challenge106.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "incrementTrilist" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "rightIndex" (invalid-name)
C: 16, 0: Invalid function name "allSubsets" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17, 4: Invalid variable name "triList" (invalid-name)
C: 28, 0: Invalid argument name "l" (invalid-name)
C: 28, 0: Missing function docstring (missing-docstring)
C: 48, 0: Invalid function name "getRequiredCompares" (invalid-name)
C: 48, 0: Missing function docstring (missing-docstring)
C: 49, 4: Invalid variable name "allS" (invalid-name)
C: 52, 4: Invalid variable name "workingS" (invalid-name)
C: 55, 4: Invalid variable name "workingS" (invalid-name)
C: 58, 4: Invalid variable name "workingS" (invalid-name)
C: 62, 0: Missing function docstring (missing-docstring)
C: 65, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge107/challenge107.py _________________
C: 22, 0: Line too long (102/100) (line-too-long)
C: 25, 0: Line too long (139/100) (line-too-long)
C: 25, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "skimNetwork" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "connectedRows" (invalid-name)
C:  7, 4: Invalid variable name "availableConnections" (invalid-name)
C: 22, 8: Invalid variable name "availableConnections" (invalid-name)
C: 30, 4: Invalid variable name "newGrid" (invalid-name)
W: 30,35: Unused variable 'row' (unused-variable)
C: 36, 0: Invalid function name "scoreGrid" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "r" (invalid-name)
C: 41,12: Invalid variable name "v" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 50,64: Invalid variable name "f" (invalid-name)
C: 56, 4: Invalid variable name "originalScore" (invalid-name)
C: 59, 4: Invalid variable name "newGrid" (invalid-name)
C: 62, 4: Invalid variable name "newScore" (invalid-name)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)

_________________ [pylint] pemjh/challenge108/challenge108.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge109/challenge109.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def getNonDoubleOuts(n, darts, nums, known = dict()):
                                           ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "getNonDoubleOuts" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nCount" (invalid-name)
C:  7, 8: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "nCount" (invalid-name)
C: 21, 0: Invalid function name "getDoubleOuts" (invalid-name)
C: 21, 0: Invalid argument name "n" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "nCount" (invalid-name)
C: 24,14: Invalid variable name "d" (invalid-name)
C: 26,12: Invalid variable name "nCount" (invalid-name)
C: 28,12: Invalid variable name "nCount" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "nCount" (invalid-name)
C: 43, 8: Invalid variable name "nCount" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge110/challenge110.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge111/challenge111.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def isPrime(p, pc = PrimeChecker()):
                  ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "isPrime" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "pc" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid function name "buildNums" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17,16: Invalid variable name "b" (invalid-name)
C: 24,16: Invalid variable name "b" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "M" (invalid-name)
C: 31, 4: Invalid variable name "N" (invalid-name)
C: 32, 4: Invalid variable name "S" (invalid-name)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36, 8: Invalid variable name "s" (invalid-name)
C: 38,12: Invalid variable name "m" (invalid-name)
C: 40,20: Invalid variable name "b" (invalid-name)
C: 44,28: Invalid variable name "n" (invalid-name)
C: 45,28: Invalid variable name "s" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused roughPrimes imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge111\challenge111.py:1:1: F401 'roughPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge112/challenge112.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isBouncy" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  6,11: Invalid variable name "nextM" (invalid-name)
C:  9,12: Invalid variable name "nextMovement" (invalid-name)
C: 11,12: Invalid variable name "nextMovement" (invalid-name)
C: 13,12: Invalid variable name "nextMovement" (invalid-name)
C: 15, 8: Invalid variable name "m" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "currentBouncy" (invalid-name)
C: 32, 4: Invalid variable name "currentNumber" (invalid-name)
C: 36,12: Invalid variable name "currentBouncy" (invalid-name)
C: 39,54: More than one statement on a single line (multiple-statements)
C: 41, 8: Invalid variable name "currentNumber" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge113/challenge113.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 21, 8: Invalid variable name "d" (invalid-name)
C: 22, 8: Invalid variable name "p" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge114/challenge114.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 14,16: Invalid variable name "nVariations" (invalid-name)
C: 17, 8: Invalid variable name "nVariations" (invalid-name)
C: 20, 8: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 4: Invalid variable name "n" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge115/challenge115.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, minimum, tileSizes, known = dict()):
                                                    ^ (bad-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 15,12: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 21, 8: Invalid variable name "nVariations" (invalid-name)
C: 27, 0: Invalid function name "f" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "b" (invalid-name)
C: 38, 8: Invalid variable name "b" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge116/challenge116.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                        ^ (bad-whitespace)
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                                      ^ (bad-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSize" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  9,12: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 15, 8: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "n2" (invalid-name)
C: 26, 4: Invalid variable name "n3" (invalid-name)
C: 27, 4: Invalid variable name "n4" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge117/challenge117.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 10,16: Invalid variable name "nVariations" (invalid-name)
C: 13, 8: Invalid variable name "nVariations" (invalid-name)
C: 16, 8: Invalid variable name "nVariations" (invalid-name)
C: 22, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "n" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge118/challenge118.py _________________
C: 10, 0: No space allowed around keyword argument assignment
def build_sets(existing, left, lExist = 0):
                                      ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 0: Invalid argument name "lExist" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "lLeft" (invalid-name)
C: 16, 8: Invalid variable name "lNew" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
W: 37,12: Used builtin function 'map' (bad-builtin)
C: 45, 0: Missing function docstring (missing-docstring)
C: 49, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge119/challenge119.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "sumDigits" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "w" (invalid-name)
C:  5, 8: Invalid variable name "w" (invalid-name)
C:  5,11: Invalid variable name "m" (invalid-name)
C:  9, 0: Invalid function name "an" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 16,12: Invalid variable name "p" (invalid-name)
C: 18,12: Invalid variable name "s" (invalid-name)
W: 16,12: Unused variable 'p' (unused-variable)
C: 25, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge120/challenge120.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "highestMod" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge121/challenge121.py _________________
C: 21, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "winChance" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "lossesAllowed" (invalid-name)
C: 22, 8: Invalid variable name "lossesAllowed" (invalid-name)
C: 27, 8: Invalid variable name "wc" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge122/challenge122.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12,16: Invalid variable name "f" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge123/challenge123.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getRemainder" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 11, 8: Invalid variable name "r" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 17, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge124/challenge124.py _________________
C:  5, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] > b[1]))):
        ^   | (bad-continuation)
C: 12, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] < b[1]))):
        ^   | (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 8: Invalid variable name "p" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge125/challenge125.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "rtLimit" (invalid-name)
C:  8, 8: Invalid variable name "rtLimit" (invalid-name)
C:  9, 4: Invalid variable name "rtLimit" (invalid-name)
C: 13, 8: Invalid variable name "sq" (invalid-name)
C: 15,12: Invalid variable name "sq" (invalid-name)
C: 26, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge126/challenge126.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 16, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 20, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 24, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 29, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "surroundingCubes" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Invalid argument name "z" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "maximumResult" (invalid-name)
C: 10, 4: Invalid variable name "maximumDepth" (invalid-name)
C: 12, 8: Invalid variable name "maximumDepth" (invalid-name)
C: 15, 8: Invalid variable name "maximumA" (invalid-name)
C: 17,12: Invalid variable name "maximumA" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "maximumB" (invalid-name)
C: 21,16: Invalid variable name "maximumB" (invalid-name)
C: 22,16: Invalid variable name "b" (invalid-name)
C: 23,16: Invalid variable name "maximumC" (invalid-name)
C: 25,20: Invalid variable name "maximumC" (invalid-name)
C: 26,20: Invalid variable name "c" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)

_________________ [pylint] pemjh/challenge127/challenge127.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 20,12: Redefining built-in 'next' (redefined-builtin)
C: 19, 8: Invalid variable name "c" (invalid-name)
C: 21,12: Invalid variable name "a" (invalid-name)
C: 24,12: Invalid variable name "b" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','

_________________ [pylint] pemjh/challenge128/challenge128.py _________________
C: 23, 0: Line too long (103/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "nPrimes" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)

_________________ [pylint] pemjh/challenge129/challenge129.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "A" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "n" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16,12: Invalid variable name "an" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
F: 25, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge130/challenge130.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "A" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
F: 28, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge131/challenge131.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "p" (invalid-name)
C: 18, 8: Invalid variable name "lowerCube" (invalid-name)
C: 19, 8: Invalid variable name "upperCube" (invalid-name)
C: 25,16: Invalid variable name "lowerCube" (invalid-name)
C: 30,16: Invalid variable name "upperCube" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge132/challenge132.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "R" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 13,33: More than one statement on a single line (multiple-statements)
C: 17, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge133/challenge133.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)

_________________ [pylint] pemjh/challenge134/challenge134.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "jumpSize" (invalid-name)
C:  3, 0: Invalid argument name "t" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "cInd" (invalid-name)
C: 21, 4: Invalid variable name "tInd" (invalid-name)
C: 29, 0: Invalid function name "f" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "s" (invalid-name)
C: 33, 4: Invalid variable name "c" (invalid-name)
C: 35, 4: Invalid variable name "t" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 51, 8: Invalid variable name "r" (invalid-name)
C: 54, 4: Invalid variable name "p1" (invalid-name)
C: 55, 4: Invalid variable name "S" (invalid-name)
C: 56, 8: Invalid variable name "p2" (invalid-name)
C: 61, 8: Invalid variable name "n" (invalid-name)
C: 63, 8: Invalid variable name "S" (invalid-name)
C: 65, 8: Invalid variable name "p1" (invalid-name)
W: 51, 8: Unused variable 'r' (unused-variable)
C: 68, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge135/challenge135.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumTarget" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "x" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "n" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge136/challenge136.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getNumTarget" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "p" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge137/challenge137.py _________________
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  8, 0: No space allowed around keyword argument assignment
def a(n, known = {0: 0, 1: 2, 2: 15}):
               ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining name 'a' from outer scope (line 8) (redefined-outer-name)
C:  2, 4: Invalid variable name "a" (invalid-name)
C:  2, 7: Invalid variable name "b" (invalid-name)
C:  4, 8: Invalid variable name "x" (invalid-name)
C:  6, 8: Invalid variable name "a" (invalid-name)
C:  6,11: Invalid variable name "b" (invalid-name)
W:  4, 8: Unused variable 'x' (unused-variable)
W:  8, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  8, 0: Invalid function name "a" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 19, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge138/challenge138.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 15, 8: Redefining built-in 'next' (redefined-builtin)
C:  4, 4: Invalid variable name "b1" (invalid-name)
C:  5, 4: Invalid variable name "b2" (invalid-name)
C: 17, 8: Invalid variable name "v" (invalid-name)
C: 21,12: Invalid variable name "v" (invalid-name)
C: 27,23: More than one statement on a single line (multiple-statements)
W:  7, 8: Unused variable 'i' (unused-variable)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)

_________________ [pylint] pemjh/challenge139/challenge139.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge142/challenge142.py _________________
C: 32, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "perfectSquare" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "a" (invalid-name)
C:  4, 0: Invalid argument name "b" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)

_________________ [pylint] pemjh/challenge144/challenge144.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "solveQuadratic" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "sqPart" (invalid-name)
C:  7, 0: Invalid argument name "x" (invalid-name)
C:  7, 0: Invalid argument name "y" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "impGrad" (invalid-name)
C: 12, 4: Invalid variable name "impAngle" (invalid-name)
C: 15, 4: Invalid variable name "inAngle" (invalid-name)
C: 18, 4: Invalid variable name "diffAngle" (invalid-name)
C: 21, 4: Invalid variable name "newAngle" (invalid-name)
C: 24, 4: Invalid variable name "newGradient" (invalid-name)
C: 29, 0: Invalid function name "nextStep" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "m" (invalid-name)
C: 34, 4: Invalid variable name "c" (invalid-name)
C: 41, 4: Invalid variable name "x1" (invalid-name)
C: 41, 8: Invalid variable name "x2" (invalid-name)
C: 45, 8: Invalid variable name "xImpact" (invalid-name)
C: 47, 8: Invalid variable name "xImpact" (invalid-name)
C: 49, 4: Invalid variable name "yImpact" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 56, 0: Missing function docstring (missing-docstring)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge145/challenge145.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "d" (invalid-name)
C:  8, 4: Invalid variable name "sevenDigits" (invalid-name)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge146/challenge146.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def is_pseudo_prime(n, known = {1: True, 2: True}):
                             ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "ns" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent

_________________ [pylint] pemjh/challenge148/challenge148.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 31, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge149/challenge149.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid argument name "l" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 29, 0: Missing function docstring (missing-docstring)
W: 35,13: Used builtin function 'map' (bad-builtin)
W: 44,13: Used builtin function 'map' (bad-builtin)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge151/challenge151.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a5" (invalid-name)
C:  1, 0: Invalid argument name "a4" (invalid-name)
C:  1, 0: Invalid argument name "a3" (invalid-name)
C:  1, 0: Invalid argument name "a2" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge162/challenge162.py _________________
C:  2, 0: Line too long (103/100) (line-too-long)
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid constant name "answer" (invalid-name)
C:  8, 0: Invalid constant name "desc" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge164/challenge164.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(size, previousThree, useZero, known = dict()):
                                                  ^ (bad-whitespace)
C: 15, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "useZero" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nLosses" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge166/challenge166.py _________________
C: 60, 0: Line too long (102/100) (line-too-long)
C: 65, 0: Line too long (114/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sq" (invalid-name)
R:  1, 0: Too many branches (14/12) (too-many-branches)
C: 70, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)

_________________ [pylint] pemjh/challenge173/challenge173.py _________________
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numOfSquares" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nSquares" (invalid-name)
C:  3, 4: Invalid variable name "holeWidth" (invalid-name)
C:  6, 8: Invalid variable name "holeArea" (invalid-name)
C: 12, 8: Invalid variable name "surroundingWidth" (invalid-name)
C: 16,12: Invalid variable name "totalArea" (invalid-name)
C: 19,12: Invalid variable name "surroundingArea" (invalid-name)
C: 24,12: Invalid variable name "surroundingWidth" (invalid-name)
C: 25,12: Invalid variable name "nSquares" (invalid-name)
C: 27, 8: Invalid variable name "holeWidth" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge174/challenge174.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def getDivisors(n, known = dict()):
                         ^ (bad-whitespace)
C: 11, 0: No space allowed around keyword argument assignment
def getNumEvenDivisors(n, known = dict()):
                                ^ (bad-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "getDivisors" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "d" (invalid-name)
W: 11, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 11, 0: Invalid function name "getNumEvenDivisors" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 4: Invalid variable name "nDiv" (invalid-name)
C: 20,12: Invalid variable name "nDiv" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nSquares" (invalid-name)
C: 31, 4: Invalid variable name "nMatches" (invalid-name)
C: 32, 8: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "nMatches" (invalid-name)
W: 33,24: Used builtin function 'filter' (bad-builtin)
W: 33,24: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 33,46: Cell variable n defined in loop (cell-var-from-loop)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge179/challenge179.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nSame" (invalid-name)
C:  8,12: Invalid variable name "a" (invalid-name)
C: 13,12: Invalid variable name "nSame" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge183/challenge183.py _________________
C:  4, 0: No space allowed around keyword argument assignment
def pf(n, known = dict()):
                ^ (bad-whitespace)
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 12, 0: No space allowed around keyword argument assignment
def factPower(b, f, known = dict()):
                          ^ (bad-whitespace)
C: 30, 0: Line too long (106/100) (line-too-long)
C: 32, 0: Line too long (107/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  4, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  4, 0: Invalid function name "pf" (invalid-name)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W: 12, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 12, 0: Invalid function name "factPower" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "f" (invalid-name)
C: 20,11: Invalid variable name "m" (invalid-name)
C: 26, 0: Invalid argument name "n" (invalid-name)
C: 26, 0: Invalid argument name "d" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "dFacts" (invalid-name)
C: 31, 4: Invalid variable name "termDen" (invalid-name)
C: 32, 4: Invalid variable name "dFacts" (invalid-name)
C: 36, 0: Invalid function name "M" (invalid-name)
C: 36, 0: Invalid argument name "N" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 0: Invalid function name "SD" (invalid-name)
C: 40, 0: Missing function docstring (missing-docstring)
C: 42, 8: Invalid variable name "N" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 53, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge187/challenge187.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nPrimes" (invalid-name)
C:  7, 4: Invalid variable name "nTwos" (invalid-name)
C: 12,12: Invalid variable name "nTwos" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge188/challenge188.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge190/challenge190.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "P" (invalid-name)
C:  1, 0: Invalid argument name "m" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge191/challenge191.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(days, previousThree, latesLeft, known = dict()):
                                                    ^ (bad-whitespace)
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
                                                              ^ (bad-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Line too long (105/100) (line-too-long)
C: 67, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "latesLeft" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  7, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "numVariations" (invalid-name)
C: 25, 0: Invalid argument name "tilePatterns" (invalid-name)
C: 25, 0: Invalid argument name "losingPatterns" (invalid-name)
R: 25, 0: Too many local variables (16/15) (too-many-locals)
C: 29, 4: Invalid variable name "nVariations" (invalid-name)
C: 35,16: Invalid variable name "c" (invalid-name)
C: 36,16: Invalid variable name "nVariations" (invalid-name)
C: 39,16: Invalid variable name "tilePattern" (invalid-name)
C: 41,16: Invalid variable name "lTilePattern" (invalid-name)
C: 45,24: Invalid variable name "nVariations" (invalid-name)
C: 50,16: Invalid variable name "nLeft" (invalid-name)
C: 52,20: Invalid variable name "nLeft" (invalid-name)
C: 55,20: Invalid variable name "lPattern" (invalid-name)
C: 62,24: Invalid variable name "nVariations" (invalid-name)
C: 66,12: Invalid variable name "nVariations" (invalid-name)
W: 35,16: Unused variable 'c' (unused-variable)
R: 25, 0: Too many branches (13/12) (too-many-branches)
C: 72, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nPatterns" (invalid-name)
C: 76, 4: Invalid variable name "nLosses" (invalid-name)
C: 80, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge197/challenge197.py _________________
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "f" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "n" (invalid-name)
C:  6, 4: Invalid variable name "u" (invalid-name)
C: 13, 8: Invalid variable name "u" (invalid-name)
W: 10, 4: Unused variable 'odd' (unused-variable)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge197\challenge197.py:10:5: F841 local variable 'odd' is assigned to but never used
D:\Development\pemjh\pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge203/challenge203.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "squareFree" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 29,12: Invalid variable name "p" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
D:\Development\pemjh\pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge204/challenge204.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getHams" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCount" (invalid-name)
C:  5, 8: Invalid variable name "p" (invalid-name)
C:  7, 8: Invalid variable name "pCurrent" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 14,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "pCurrent" (invalid-name)
C: 19, 0: Invalid function name "hamNums" (invalid-name)
C: 19, 0: Invalid argument name "maxPrime" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 23, 4: Unused variable 'found' (unused-variable)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:23:5: F841 local variable 'found' is assigned to but never used
D:\Development\pemjh\pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge205/challenge205.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "diceRolls" (invalid-name)
C:  7, 0: Invalid argument name "nDice" (invalid-name)
C:  7, 0: Invalid argument name "nSides" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nRolls" (invalid-name)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17,10: Invalid variable name "nPete" (invalid-name)
C: 18,11: Invalid variable name "nColin" (invalid-name)
C: 20, 4: Invalid variable name "peteWin" (invalid-name)
C: 21, 4: Invalid variable name "totalRolls" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 22,11: Invalid variable name "f" (invalid-name)
C: 24, 8: Invalid variable name "nWins" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge206/challenge206.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "v" (invalid-name)
C: 12, 0: Invalid function name "hasMask" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "w" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "lowestRoot" (invalid-name)
C: 34, 8: Invalid variable name "sq" (invalid-name)
C: 36, 8: Invalid variable name "hasM" (invalid-name)
C: 36,14: Invalid variable name "wrongIndex" (invalid-name)
C: 51,12: Invalid variable name "sq" (invalid-name)
C: 58,32: More than one statement on a single line (multiple-statements)
C: 62, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused floor imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge206\challenge206.py:1:1: F401 'floor' imported but unused
D:\Development\pemjh\pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge207/challenge207.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "a" (invalid-name)
C:  6, 4: Invalid variable name "b" (invalid-name)
C:  7, 4: Invalid variable name "t" (invalid-name)
C:  8, 4: Invalid variable name "nextPower" (invalid-name)
C: 10, 8: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "t" (invalid-name)
C: 16,12: Invalid variable name "nextPower" (invalid-name)
C: 20, 8: Invalid variable name "a" (invalid-name)
C: 20,11: Invalid variable name "b" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge211/challenge211.py _________________
C: 13, 0: Line too long (112/100) (line-too-long)
C: 54, 0: No space allowed around keyword argument assignment
def challenge211(calc = False):
                      ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "squareSum" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "slowButRight" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "d" (invalid-name)
C: 27,11: Invalid variable name "m" (invalid-name)
C: 30,12: Invalid variable name "a" (invalid-name)
C: 33,16: Invalid variable name "a" (invalid-name)
C: 34,16: Invalid variable name "d" (invalid-name)
C: 34,19: Invalid variable name "m" (invalid-name)
C: 44, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "x" (invalid-name)
C: 48, 8: Invalid variable name "s" (invalid-name)
C: 54, 0: Missing function docstring (missing-docstring)
C: 63, 0: Invalid constant name "answer" (invalid-name)
F: 66, 4: Unable to import 'psyco' (import-error)
W:  2, 0: Unused takewhile imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge211\challenge211.py:2:1: F401 'takewhile' imported but unused
D:\Development\pemjh\pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
D:\Development\pemjh\pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge214/challenge214.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def totients(n, primes = None):
                       ^ (bad-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def totientChainLength(n, current, limit, steps, known = dict()):
                                                       ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "p" (invalid-name)
C: 19,12: Invalid variable name "t" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "totientChainLength" (invalid-name)
C: 25, 0: Invalid argument name "n" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 51,12: Invalid variable name "v" (invalid-name)
W: 25,26: Unused argument 'current' (unused-argument)
C: 58, 0: Missing function docstring (missing-docstring)
C: 64, 8: Invalid variable name "p" (invalid-name)
C: 71, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused phi imported from utils.numbers (unused-import)
W:  1, 0: Unused primeFactors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'phi' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'primeFactors' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge215/challenge215.py _________________
C:  3, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  6, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C:  9, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 12, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "buildRowOptions" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid function name "runningCrack" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 31, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 31, 0: Invalid function name "W" (invalid-name)
C: 31, 0: Invalid argument name "startRow" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 39,16: Invalid variable name "subRow" (invalid-name)
C: 46, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "wallWidth" (invalid-name)
C: 49, 4: Invalid variable name "wallHeight" (invalid-name)
C: 51, 4: Invalid variable name "rowLinks" (invalid-name)
W: 53,11: Used builtin function 'map' (bad-builtin)
C: 61, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)

_________________ [pylint] pemjh/challenge216/challenge216.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
def challenge216(skip = True):
                      ^ (bad-whitespace)
C: 49, 0: Trailing whitespace (trailing-whitespace)
C: 51, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 54, 0: Exactly one space required after comma
    primes[0:2] = [False,False]
                        ^ (bad-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 60, 0: Trailing whitespace (trailing-whitespace)
C: 62, 0: Trailing whitespace (trailing-whitespace)
C: 63, 0: Exactly one space required after comma
    t[0:2] = [False,False]
                   ^ (bad-whitespace)
C: 64, 0: Trailing whitespace (trailing-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "l" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "v" (invalid-name)
C:  8,12: Invalid variable name "v" (invalid-name)
C: 20, 0: Invalid function name "sq" (invalid-name)
C: 20, 0: Invalid argument name "a" (invalid-name)
C: 20, 0: Invalid argument name "p" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 21, 4: Invalid variable name "q" (invalid-name)
C: 21, 7: Invalid variable name "e" (invalid-name)
C: 23, 8: Invalid variable name "e" (invalid-name)
C: 24, 8: Invalid variable name "q" (invalid-name)
C: 25, 4: Invalid variable name "n" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 28, 4: Invalid variable name "z" (invalid-name)
C: 29, 4: Invalid variable name "y" (invalid-name)
C: 29, 7: Invalid variable name "r" (invalid-name)
C: 29,10: Invalid variable name "x" (invalid-name)
C: 30, 4: Invalid variable name "b" (invalid-name)
C: 31, 4: Invalid variable name "x" (invalid-name)
C: 33, 8: Invalid variable name "bb" (invalid-name)
C: 33,12: Invalid variable name "m" (invalid-name)
C: 35,12: Invalid variable name "bb" (invalid-name)
C: 36,12: Invalid variable name "m" (invalid-name)
C: 39, 8: Invalid variable name "t" (invalid-name)
C: 41,12: Invalid variable name "t" (invalid-name)
C: 42, 8: Invalid variable name "y" (invalid-name)
C: 42,11: Invalid variable name "r" (invalid-name)
C: 42,14: Invalid variable name "x" (invalid-name)
C: 43, 8: Invalid variable name "b" (invalid-name)
W: 40,12: Unused variable 'k' (unused-variable)
C: 46, 0: Missing function docstring (missing-docstring)
C: 56, 8: Invalid variable name "x" (invalid-name)
C: 58,16: Invalid variable name "y" (invalid-name)
C: 61, 4: Invalid variable name "t" (invalid-name)
C: 65, 8: Invalid variable name "x" (invalid-name)
C: 67,12: Invalid variable name "s" (invalid-name)
C: 78, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge220/challenge220.py _________________
C:  2, 0: Exactly one space required after comma
    c = [0,1]
          ^ (bad-whitespace)
C: 13, 0: Exactly one space required after comma
    c2 = [-c2[1],c2[0]]
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "c" (invalid-name)
C:  5, 8: Invalid variable name "c" (invalid-name)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 12, 4: Invalid variable name "c2" (invalid-name)
C: 13, 4: Invalid variable name "c2" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
W: 17,20: Used builtin function 'map' (bad-builtin)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge225/challenge225.py _________________
C:  2, 0: Line too long (108/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 10,12: Invalid variable name "a" (invalid-name)
C: 10,15: Invalid variable name "b" (invalid-name)
C: 10,18: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)

_________________ [pylint] pemjh/challenge230/challenge230.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Line too long (110/100) (line-too-long)
C: 41, 0: Line too long (110/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "D" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "aSize" (invalid-name)
C:  7, 4: Invalid variable name "bSize" (invalid-name)
C:  9, 8: Invalid variable name "aSize" (invalid-name)
C:  9,15: Invalid variable name "bSize" (invalid-name)
C: 14, 4: Invalid variable name "workingN" (invalid-name)
C: 22, 8: Invalid variable name "firstSize" (invalid-name)
C: 25,12: Invalid variable name "workingN" (invalid-name)
C: 33, 8: Invalid variable name "containingStr" (invalid-name)
C: 35, 8: Invalid variable name "containingStr" (invalid-name)
W:  2, 4: Unused variable 'size' (unused-variable)
C: 39, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "a" (invalid-name)
C: 41, 4: Invalid variable name "b" (invalid-name)
C: 44,15: Invalid variable name "n" (invalid-name)
C: 49, 0: Invalid constant name "answer" (invalid-name)
W: 52, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge230\challenge230.py:2:5: F841 local variable 'size' is assigned to but never used
D:\Development\pemjh\pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:52:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge231/challenge231.py _________________
C: 43, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getFirstMultipleOnOrAfter" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "m" (invalid-name)
C: 10, 0: Invalid function name "getFirstMultipleOnOrBefore" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 17, 0: Invalid function name "numInRange" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 23, 0: Missing function docstring (missing-docstring)
C: 24, 4: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "p" (invalid-name)
C: 43,12: Invalid variable name "numRange" (invalid-name)
C: 49,12: Invalid variable name "denRange" (invalid-name)
C: 53,12: Invalid variable name "inRange" (invalid-name)
C: 59,16: Invalid variable name "inRange" (invalid-name)
C: 62,16: Invalid variable name "inRange" (invalid-name)
W: 36, 8: Unused variable 'index' (unused-variable)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:36:9: F841 local variable 'index' is assigned to but never used
D:\Development\pemjh\pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace

_________________ [pylint] pemjh/challenge234/challenge234.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Wrong continued indentation.
                          next**2 if next**2 < limit + 1 else limit + 1,
                          ^| (bad-continuation)
C: 24, 0: Wrong continued indentation.
                          current))
                          ^| (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Missing function docstring (missing-docstring)
W: 19, 8: Redefining built-in 'next' (redefined-builtin)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent

_________________ [pylint] pemjh/challenge235/challenge235.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "r" (invalid-name)
C:  4, 4: Invalid variable name "dr" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  7, 8: Invalid variable name "s" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 11,12: Invalid variable name "r" (invalid-name)
C: 12, 8: Invalid variable name "dr" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge243/challenge243.py _________________
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "d" (invalid-name)
C: 24,23: More than one statement on a single line (multiple-statements)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 37,20: Invalid variable name "m" (invalid-name)
C: 38,20: Invalid variable name "d" (invalid-name)
C: 46, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge250/challenge250.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W: 12,12: Unused variable 'j' (unused-variable)
C: 20, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge259/challenge259.py _________________
C: 22, 0: No space allowed around keyword argument assignment
def get_totals(start, end, known = {}):
                                 ^ (bad-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "g" (invalid-name)
C: 10, 0: Invalid argument name "a" (invalid-name)
C: 10, 0: Invalid argument name "b" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid argument name "a" (invalid-name)
C: 13, 0: Invalid argument name "b" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid argument name "a" (invalid-name)
C: 16, 0: Invalid argument name "b" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid argument name "a" (invalid-name)
C: 19, 0: Invalid argument name "b" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 22, 0: Dangerous default value {} as argument (dangerous-default-value)
C: 22, 0: Missing function docstring (missing-docstring)
C: 55, 0: Invalid constant name "answer" (invalid-name)
C: 57, 0: Missing function docstring (missing-docstring)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)

_________________ [pylint] pemjh/challenge265/challenge265.py _________________
C: 10, 0: Trailing whitespace (trailing-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Trailing whitespace (trailing-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  3, 4: Invalid variable name "s" (invalid-name)
C:  4, 4: Invalid variable name "d" (invalid-name)
C:  4, 7: Invalid variable name "m" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  6, 4: Invalid variable name "d" (invalid-name)
C:  6, 7: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "s" (invalid-name)
C:  8, 4: Invalid variable name "s" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Invalid argument name "d" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "b" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "getSequences" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 26, 8: Invalid variable name "b" (invalid-name)
C: 30,16: Invalid variable name "s" (invalid-name)
C: 35, 0: Invalid function name "S" (invalid-name)
C: 35, 0: Invalid argument name "n" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 49, 0: Missing function docstring (missing-docstring)
C: 52, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace

--------------- coverage: platform win32, python 2.7.10-final-0 ---------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge001\challenge001       7      3      4      3    45%   4, 9-10
pemjh\challenge002\challenge002      12     10      8      7    15%   2-3, 6-16
pemjh\challenge003\challenge003      17     13     10      5    33%   5-23, 28-29
pemjh\challenge004\challenge004      19     16     10      9    14%   5-31, 36-37
pemjh\challenge005\challenge005      24     21     18     17    10%   2-34, 39-40
pemjh\challenge006\challenge006      13     10      4      3    24%   2-18, 23-24
pemjh\challenge007\challenge007      18     13      9      8    22%   5-19, 24-25
pemjh\challenge008\challenge008      16     13     10      9    15%   2-39, 44-45
pemjh\challenge009\challenge009      14     11      8      7    18%   4-16, 21-22
pemjh\challenge010\challenge010      14      9     10      9    25%   6-13, 18-19
pemjh\challenge011\challenge011      39     36     26     25     6%   2-56, 61-62
pemjh\challenge012\challenge012      31     28     14      9    18%   2-3, 7-44
pemjh\challenge013\challenge013      11      8      4      3    27%   2-109, 114-115
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      8      5    17%   2-3, 7-32
pemjh\challenge016\challenge016      12      9      4      3    25%   2-12, 17-18
pemjh\challenge017\challenge017      33     29     16     15    10%   2-39, 42-104, 109-110
pemjh\challenge018\challenge018      26     24      4      3    10%   2-3, 6-31
pemjh\challenge019\challenge019      32     25     18     17    16%   2, 6-9, 12-15, 19-28, 33-40, 45-46
pemjh\challenge020\challenge020      16     12      6      5    23%   2-5, 9-16, 21-22
pemjh\challenge021\challenge021      21     19     14     13     9%   2-3, 7-33
pemjh\challenge022\challenge022      28     21     10      9    21%   5-14, 17-24, 28-32, 37-38
pemjh\challenge023\challenge023      24     18     16     14    20%   2-3, 7-21, 24, 27-29, 34
pemjh\challenge024\challenge024      14     12      6      5    15%   2-3, 7-18
pemjh\challenge025\challenge025      15     13     10      9    12%   2-3, 5-19
pemjh\challenge026\challenge026      21     17     10      9    16%   4-23, 28-29
pemjh\challenge027\challenge027      27     25     14     11    12%   2-3, 6-36
pemjh\challenge028\challenge028      14     11      4      3    22%   2-13, 18-19
pemjh\challenge029\challenge029      14     11      6      5    20%   2-12, 17-18
pemjh\challenge030\challenge030      19     16     10      9    14%   3-16, 21-22
pemjh\challenge031\challenge031      16     12      6      5    23%   2-14, 19, 22-23
pemjh\challenge032\challenge032      20     18     10      9    10%   2-3, 7-27
pemjh\challenge033\challenge033      33     31     18     17     6%   2-3, 7-48
pemjh\challenge034\challenge034      30     28     14     11    11%   2-3, 7-46
pemjh\challenge035\challenge035      38     36     24     23     5%   2-3, 6-59
pemjh\challenge036\challenge036      22     18     10      9    16%   2-7, 11-24, 29-30
pemjh\challenge037\challenge037      27     25     18     15    11%   2-3, 7-36
pemjh\challenge038\challenge038      20     15     10      9    20%   4, 7-21, 26-27
pemjh\challenge039\challenge039      27     23     14     13    12%   2-23, 26-34, 39-40
pemjh\challenge040\challenge040      15     12      6      5    19%   2-13, 18-19
pemjh\challenge041\challenge041      17     15      8      7    12%   2-3, 6-23
pemjh\challenge042\challenge042      30     24     14     13    16%   5-9, 12-36, 41-42
pemjh\challenge043\challenge043      14     12      6      5    15%   2-3, 6-27
pemjh\challenge044\challenge044      27     21     14     13    17%   4, 7-11, 14-29, 34-35
pemjh\challenge045\challenge045      25     19     12      7    30%   2, 5, 9-21, 24-29, 34-35
pemjh\challenge046\challenge046      23     20     12      9    17%   4-5, 8-32
pemjh\challenge047\challenge047      37     34     22     19    10%   4-5, 8-50
pemjh\challenge048\challenge048       7      4      2      1    44%   2-3, 8-10
pemjh\challenge049\challenge049      24     21     16     15    10%   4-5, 8-32
pemjh\challenge050\challenge050      24     22     12     11     8%   2-3, 6-30
pemjh\challenge051\challenge051      38     35     24     21    10%   4-5, 8-50
pemjh\challenge052\challenge052      20     16      8      7    18%   2, 5-22, 27-28
pemjh\challenge053\challenge053      16     14     10      9    12%   2-3, 6-20
pemjh\challenge054\challenge054      71     61     44     43    10%   5-12, 16-19, 22-24, 39-93, 98-111, 115-131, 136
pemjh\challenge055\challenge055      23     19     12      9    20%   2-12, 15-21, 26-27
pemjh\challenge056\challenge056      14     11      8      7    18%   2-11, 16-17
pemjh\challenge057\challenge057      15     12      8      7    17%   2-15, 20-21
pemjh\challenge058\challenge058      26     24     12      9    13%   2-3, 6-38
pemjh\challenge059\challenge059      29     22     19     18    17%   6-21, 27-45, 48-49
pemjh\challenge060\challenge060      75     73     37     36     3%   2-3, 7-119
pemjh\challenge061\challenge061      65     59     42     41     7%   4, 7-22, 28-99, 104
pemjh\challenge062\challenge062      23     19      8      5    23%   4-29, 34
pemjh\challenge063\challenge063      18     14      6      3    29%   4-22, 27-28
pemjh\challenge064\challenge064      24     23      8      8     3%   3-39
pemjh\challenge065\challenge065      20     18      8      7    11%   2-3, 6-37
pemjh\challenge066\challenge066      15     14      8      8     4%   5-23
pemjh\challenge067\challenge067      17     13      6      5    22%   5-6, 11-25
pemjh\challenge068\challenge068      48     43     32     31     8%   2-5, 8-21, 24-65, 70
pemjh\challenge069\challenge069      20     18     10      9    10%   2-3, 6-24
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
pemjh\challenge071\challenge071      25     21     12     11    14%   4-27, 32
pemjh\challenge072\challenge072      10      8      4      3    21%   2-3, 7-14
pemjh\challenge073\challenge073      31     28     16     15     9%   4-5, 8-42
pemjh\challenge074\challenge074      33     28     10      9    14%   2-3, 6-23, 26-36, 41
pemjh\challenge075\challenge075      16     15      8      8     4%   3-27
pemjh\challenge076\challenge076      20     16     10      9    17%   2-17, 30-32, 37
pemjh\challenge077\challenge077      20     19     12     10     9%   3-34
pemjh\challenge078\challenge078      20     17     12     11    13%   2-19, 24
pemjh\challenge079\challenge079       8      3      2      1    60%   9, 14-15
pemjh\challenge080\challenge080      26     21     12     11    16%   5-26, 29-34, 39
pemjh\challenge081\challenge081      32     26     13     12    16%   5-17, 20-41, 46
pemjh\challenge082\challenge082      34     27     12     11    17%   7-37, 41-48, 53
pemjh\challenge083\challenge083      45     38     20     19    12%   6-14, 17-25, 29-75, 80
pemjh\challenge084\challenge084      74     67     48     47     7%   4-6, 10-50, 54-66, 69-109, 114
pemjh\challenge085\challenge085      34     30     16     11    18%   3-10, 13-46, 51
pemjh\challenge086\challenge086      32     26     14     11    20%   2, 6-17, 20-25, 28-39, 44
pemjh\challenge087\challenge087      30     28     14     13     7%   2-3, 5-40
pemjh\challenge088\challenge088      24     19     12     11    17%   5-19, 22-31, 36
pemjh\challenge089\challenge089      51     42     26     25    13%   18-31, 35-51, 54-65, 69-79, 83-85, 90
pemjh\challenge090\challenge090      78     68     50     49     9%   5-18, 21-27, 30-33, 36-69, 74-114, 117-127, 132
pemjh\challenge091\challenge091      23     19     20     19    12%   2-30, 33-35, 40
pemjh\challenge092\challenge092      96     94     50     45     5%   2-3, 6-124
pemjh\challenge093\challenge093      67     59     50     49     8%   4-10, 14-24, 27-32, 35-58, 61-97, 102
pemjh\challenge094\challenge094      35     30     12     11    13%   2-7, 11-48, 54
pemjh\challenge095\challenge095      35     30     22     21    11%   3-10, 14-48, 51-56, 61
pemjh\challenge096\challenge096     181    155    116    115     9%   7-14, 22-34, 40-44, 47-59, 62-69, 73-94, 97-105, 108-115, 118-146, 150-155, 158-174, 178-181, 184-221, 224-228, 231-235, 238-241, 244-254, 257-277, 294
pemjh\challenge097\challenge097       6      3      2      1    50%   2, 7-8
pemjh\challenge098\challenge098      62     54     34     33     9%   5-13, 16-23, 26-30, 33-93, 98
pemjh\challenge099\challenge099      17     12      7      6    25%   5-14, 19-20
pemjh\challenge100\challenge100       9      6      4      3    31%   2-6, 11
pemjh\challenge101\challenge101      26     23     18     17     9%   2-38, 43
pemjh\challenge102\challenge102      34     27     14     13    17%   9-31, 35-41, 45-53, 59
pemjh\challenge103\challenge103      40     35     30     29     9%   3-12, 16-34, 37-56, 61
pemjh\challenge104\challenge104      34     33     15     15     2%   3-50
pemjh\challenge105\challenge105      40     32     22     21    15%   5-19, 22-28, 32-47, 51-58, 65
pemjh\challenge106\challenge106      37     30     16     15    15%   2-14, 17-26, 29-46, 49-60, 63, 68
pemjh\challenge107\challenge107      38     31     12     11    16%   6-34, 37-45, 48-65, 70
pemjh\challenge108\challenge108      35     34     16     16     2%   3-59
pemjh\challenge109\challenge109      37     32     18     17    11%   2-19, 23-29, 32-45, 50
pemjh\challenge110\challenge110      35     34     16     16     2%   3-59
pemjh\challenge111\challenge111      38     37     31     31     1%   3-54
pemjh\challenge112\challenge112      32     28     20     17    13%   2-27, 30-43, 48
pemjh\challenge113\challenge113      16     14      6      5    14%   2-3, 6-61
pemjh\challenge114\challenge114      24     19     12     11    17%   2-24, 27-28, 31-32, 37
pemjh\challenge115\challenge115      30     25     14     13    14%   2-25, 28-29, 32-38, 43
pemjh\challenge116\challenge116      24     19     10      9    18%   2-22, 25-28, 31-32, 37
pemjh\challenge117\challenge117      21     16     10      9    19%   2-20, 23-24, 27-28, 33
pemjh\challenge118\challenge118      36     35     14     14     2%   2-52
pemjh\challenge119\challenge119      24     19     10      9    18%   2-7, 12-23, 26-28, 33
pemjh\challenge120\challenge120      10      6      4      3    36%   2-6, 9-10, 15
pemjh\challenge121\challenge121      26     25     10     10     3%   3-39
pemjh\challenge122\challenge122      15     12     12     11    15%   2-23, 28
pemjh\challenge123\challenge123      16     15      6      6     5%   3-20
pemjh\challenge124\challenge124      21     20     14     14     3%   3-41
pemjh\challenge125\challenge125      21     18     12     11    12%   2-24, 29
pemjh\challenge126\challenge126      31     27     24     23     9%   2, 6-36, 41
pemjh\challenge127\challenge127      23     22     15     15     3%   3-35
pemjh\challenge128\challenge128      23     22     10     10     3%   3-33
pemjh\challenge129\challenge129      22     18     10      9    16%   2-8, 11-20, 25-27
pemjh\challenge130\challenge130      21     20      8      8     3%   3-30
pemjh\challenge131\challenge131      22     21     10     10     3%   3-41
pemjh\challenge132\challenge132      16     15      8      8     4%   3-24
pemjh\challenge133\challenge133      10      9      2      2     8%   3-16
pemjh\challenge134\challenge134      42     41     20     20     2%   3-72
pemjh\challenge135\challenge135      15     11     10      9    20%   2-16, 19, 25
pemjh\challenge136\challenge136      19     18     10     10     3%   3-26
pemjh\challenge137\challenge137      16     11      6      5    27%   2-6, 10-17, 20, 25
pemjh\challenge138\challenge138      23     22     14     14     3%   3-34
pemjh\challenge139\challenge139      11     10      6      6     6%   3-19
pemjh\challenge142\challenge142      26     21     18     17    14%   2, 5, 8-34, 39
pemjh\challenge144\challenge144      34     26      6      5    23%   4-5, 9-27, 31-51, 54, 57-67, 72
pemjh\challenge145\challenge145      11      8      4      3    27%   2-10, 15
pemjh\challenge146\challenge146      18     13     14     13    19%   2-6, 9, 17-26, 31
pemjh\challenge148\challenge148      22     17      6      5    21%   2-8, 11-29, 32-34, 39
pemjh\challenge149\challenge149      32     26     12     11    16%   2, 5, 9-27, 30-46, 51
pemjh\challenge151\challenge151      21     17     14     13    14%   2-20, 23, 28
pemjh\challenge162\challenge162       7      3      4      3    45%   2-4, 11
pemjh\challenge164\challenge164      20     16     10      9    17%   3-23, 27-31, 36
pemjh\challenge166\challenge166      40     37     33     32     5%   3-68, 73
pemjh\challenge173\challenge173      21     17      6      5    19%   2-27, 30, 35
pemjh\challenge174\challenge174      27     26     14     14     2%   3-40
pemjh\challenge179\challenge179      18     14      8      7    19%   3-17, 20-21, 26
pemjh\challenge183\challenge183      39     38     12     12     2%   2-56
pemjh\challenge187\challenge187      16     15      8      8     4%   3-22
pemjh\challenge188\challenge188      15     11      6      5    24%   2-10, 13, 18
pemjh\challenge190\challenge190       7      3      6      5    38%   2, 6, 11
pemjh\challenge191\challenge191      48     43     34     33     7%   2-23, 27-70, 73-78, 83
pemjh\challenge197\challenge197      19     15      8      7    19%   2, 5-22, 27
pemjh\challenge203\challenge203      27     26     16     16     2%   3-44
pemjh\challenge204\challenge204      21     20      8      8     3%   3-32
pemjh\challenge205\challenge205      25     20     10      9    17%   2-4, 8-14, 17-27, 32
pemjh\challenge206\challenge206      45     37     16     13    18%   6-10, 13-22, 26-60, 65
pemjh\challenge207\challenge207      20     17      6      5    15%   3-20, 25
pemjh\challenge211\challenge211      46     45     24     24     1%   2-68
pemjh\challenge214\challenge214      45     44     26     26     1%   3-76
pemjh\challenge215\challenge215      45     39     32     31     9%   2-23, 26-29, 32-44, 48-59, 64
pemjh\challenge216\challenge216      67     61     48     47     6%   4-18, 21-44, 47-76, 81
pemjh\challenge220\challenge220      17     13      6      5    22%   2-14, 17, 22
pemjh\challenge225\challenge225      14     11      8      7    18%   4-14, 19
pemjh\challenge230\challenge230      34     30     12     11    11%   2-37, 40-47, 52-53
pemjh\challenge231\challenge231      41     40     14     14     2%   3-72
pemjh\challenge234\challenge234      25     24     10     10     3%   3-44
pemjh\challenge235\challenge235      15     12      8      7    17%   2-14, 19
pemjh\challenge243\challenge243      33     32     20     20     2%   3-49
pemjh\challenge250\challenge250      16     12      8      7    21%   2-18, 21-22, 27
pemjh\challenge259\challenge259      42     32     18     17    18%   4-8, 11, 14, 17, 20, 23-53, 58-63, 66
pemjh\challenge265\challenge265      35     27     10      9    20%   2-9, 13-15, 18, 21-33, 37-47, 50, 55
pemjh\main                           51     33     20     15    32%   7-8, 13-28, 39-57, 63, 66-68
-----------------------------------------------------------------------------
TOTAL                              4961   4273   2571   2370    12%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\python27_64\Lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "E:\software_tools\python\python27_64\Lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\Development\pemjh\.tox\py34_64\Scripts\py.test.EXE\__main__.py", line 9, in <module>
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py34_64\lib\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
pytest_cov.plugin.CoverageError: Required test coverage of 100% not reached. Total coverage: 11.80%
ERROR: InvocationError: 'D:\\Development\\pemjh\\.tox\\py34_64\\Scripts\\py.test.EXE --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100'
pypy inst-nodeps: D:\Development\pemjh\.tox\dist\pemjh-0.0.1.zip
pypy installed: apipkg==1.4,astroid==1.3.8,cffi==1.3.0,colorama==0.3.3,coverage==3.7.1,execnet==1.4.1,flake8==2.4.1,greenlet==0.4.7,logilab-common==1.0.2,mccabe==0.3.1,pemjh==0.0.1,pep8==1.5.7,py==1.4.30,pyflakes==0.8.1,pylint==1.4.4,pytest==2.7.2,pytest-cache==1.0,pytest-cov==2.1.0,pytest-flake8==0.1,pytest-pylint==0.3.0,readline==6.2.4.1,six==1.9.0,wheel==0.24.0
pypy runtests: PYTHONHASHSEED='850'
pypy runtests: commands[0] | py.test --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100
============================= test session starts =============================
platform win32 -- Python 2.7.10[pypy-2.6.1-final] -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh, inifile: 
plugins: cache, cov, flake8, pylint
collected 358 items / 65 errors

setup.py FF
pemjh\main.py FF
pemjh\challenge001\challenge001.py FF
pemjh\challenge002\challenge002.py FF
pemjh\challenge003\challenge003.py FF
pemjh\challenge004\challenge004.py FF
pemjh\challenge005\challenge005.py FF
pemjh\challenge006\challenge006.py FF
pemjh\challenge007\challenge007.py FF
pemjh\challenge008\challenge008.py FF
pemjh\challenge009\challenge009.py FF
pemjh\challenge010\challenge010.py FF
pemjh\challenge011\challenge011.py FF
pemjh\challenge012\challenge012.py FF
pemjh\challenge013\challenge013.py FF
pemjh\challenge014\challenge014.py FF
pemjh\challenge015\challenge015.py FF
pemjh\challenge016\challenge016.py FF
pemjh\challenge017\challenge017.py FF
pemjh\challenge018\challenge018.py FF
pemjh\challenge019\challenge019.py FF
pemjh\challenge020\challenge020.py FF
pemjh\challenge021\challenge021.py FF
pemjh\challenge022\challenge022.py FF
pemjh\challenge023\challenge023.py FF
pemjh\challenge024\challenge024.py FF
pemjh\challenge025\challenge025.py FF
pemjh\challenge026\challenge026.py FF
pemjh\challenge027\challenge027.py FF
pemjh\challenge028\challenge028.py FF
pemjh\challenge029\challenge029.py FF
pemjh\challenge030\challenge030.py FF
pemjh\challenge031\challenge031.py FF
pemjh\challenge032\challenge032.py FF
pemjh\challenge033\challenge033.py FF
pemjh\challenge034\challenge034.py FF
pemjh\challenge035\challenge035.py FF
pemjh\challenge036\challenge036.py FF
pemjh\challenge037\challenge037.py FF
pemjh\challenge038\challenge038.py FF
pemjh\challenge039\challenge039.py FF
pemjh\challenge040\challenge040.py FF
pemjh\challenge041\challenge041.py FF
pemjh\challenge042\challenge042.py FF
pemjh\challenge043\challenge043.py FF
pemjh\challenge044\challenge044.py FF
pemjh\challenge045\challenge045.py FF
pemjh\challenge046\challenge046.py FF
pemjh\challenge047\challenge047.py FF
pemjh\challenge048\challenge048.py FF
pemjh\challenge049\challenge049.py FF
pemjh\challenge050\challenge050.py FF
pemjh\challenge051\challenge051.py FF
pemjh\challenge052\challenge052.py FF
pemjh\challenge053\challenge053.py FF
pemjh\challenge054\challenge054.py FF
pemjh\challenge055\challenge055.py FF
pemjh\challenge056\challenge056.py FF
pemjh\challenge057\challenge057.py FF
pemjh\challenge058\challenge058.py FF
pemjh\challenge059\challenge059.py FF
pemjh\challenge060\challenge060.py FF
pemjh\challenge061\challenge061.py FF
pemjh\challenge062\challenge062.py FF
pemjh\challenge063\challenge063.py FF
pemjh\challenge064\challenge064.py FF
pemjh\challenge065\challenge065.py FF
pemjh\challenge066\challenge066.py FF
pemjh\challenge067\challenge067.py FF
pemjh\challenge068\challenge068.py FF
pemjh\challenge069\challenge069.py FF
pemjh\challenge070\challenge070.py FF
pemjh\challenge071\challenge071.py FF
pemjh\challenge072\challenge072.py FF
pemjh\challenge073\challenge073.py FF
pemjh\challenge074\challenge074.py FF
pemjh\challenge075\challenge075.py FF
pemjh\challenge076\challenge076.py FF
pemjh\challenge077\challenge077.py FF
pemjh\challenge078\challenge078.py FF
pemjh\challenge079\challenge079.py FF
pemjh\challenge080\challenge080.py FF
pemjh\challenge081\challenge081.py FF
pemjh\challenge082\challenge082.py FF
pemjh\challenge083\challenge083.py FF
pemjh\challenge084\challenge084.py FF
pemjh\challenge085\challenge085.py FF
pemjh\challenge086\challenge086.py FF
pemjh\challenge087\challenge087.py FF
pemjh\challenge088\challenge088.py FF
pemjh\challenge089\challenge089.py FF
pemjh\challenge090\challenge090.py FF
pemjh\challenge091\challenge091.py FF
pemjh\challenge092\challenge092.py FF
pemjh\challenge093\challenge093.py FF
pemjh\challenge094\challenge094.py FF
pemjh\challenge095\challenge095.py FF
pemjh\challenge096\challenge096.py FF
pemjh\challenge097\challenge097.py FF
pemjh\challenge098\challenge098.py FF
pemjh\challenge099\challenge099.py FF
pemjh\challenge100\challenge100.py F.
pemjh\challenge101\challenge101.py FF
pemjh\challenge102\challenge102.py FF
pemjh\challenge103\challenge103.py FF
pemjh\challenge104\challenge104.py FF
pemjh\challenge105\challenge105.py FF
pemjh\challenge106\challenge106.py FF
pemjh\challenge107\challenge107.py FF
pemjh\challenge108\challenge108.py FF
pemjh\challenge109\challenge109.py FF
pemjh\challenge110\challenge110.py FF
pemjh\challenge111\challenge111.py FF
pemjh\challenge112\challenge112.py FF
pemjh\challenge113\challenge113.py FF
pemjh\challenge114\challenge114.py FF
pemjh\challenge115\challenge115.py FF
pemjh\challenge116\challenge116.py FF
pemjh\challenge117\challenge117.py FF
pemjh\challenge118\challenge118.py FF
pemjh\challenge119\challenge119.py FF
pemjh\challenge120\challenge120.py FF
pemjh\challenge121\challenge121.py FF
pemjh\challenge122\challenge122.py FF
pemjh\challenge123\challenge123.py FF
pemjh\challenge124\challenge124.py FF
pemjh\challenge125\challenge125.py F.
pemjh\challenge126\challenge126.py FF
pemjh\challenge127\challenge127.py FF
pemjh\challenge128\challenge128.py FF
pemjh\challenge129\challenge129.py FF
pemjh\challenge130\challenge130.py FF
pemjh\challenge131\challenge131.py FF
pemjh\challenge132\challenge132.py FF
pemjh\challenge133\challenge133.py FF
pemjh\challenge134\challenge134.py FF
pemjh\challenge135\challenge135.py FF
pemjh\challenge136\challenge136.py FF
pemjh\challenge137\challenge137.py FF
pemjh\challenge138\challenge138.py FF
pemjh\challenge139\challenge139.py FF
pemjh\challenge142\challenge142.py FF
pemjh\challenge144\challenge144.py FF
pemjh\challenge145\challenge145.py F.
pemjh\challenge146\challenge146.py FF
pemjh\challenge148\challenge148.py FF
pemjh\challenge149\challenge149.py FF
pemjh\challenge151\challenge151.py FF
pemjh\challenge162\challenge162.py FF
pemjh\challenge164\challenge164.py FF
pemjh\challenge166\challenge166.py FF
pemjh\challenge173\challenge173.py FF
pemjh\challenge174\challenge174.py FF
pemjh\challenge179\challenge179.py FF
pemjh\challenge183\challenge183.py FF
pemjh\challenge187\challenge187.py FF
pemjh\challenge188\challenge188.py FF
pemjh\challenge190\challenge190.py FF
pemjh\challenge191\challenge191.py FF
pemjh\challenge197\challenge197.py FF
pemjh\challenge203\challenge203.py FF
pemjh\challenge204\challenge204.py FF
pemjh\challenge205\challenge205.py FF
pemjh\challenge206\challenge206.py FF
pemjh\challenge207\challenge207.py F.
pemjh\challenge211\challenge211.py FF
pemjh\challenge214\challenge214.py FF
pemjh\challenge215\challenge215.py FF
pemjh\challenge216\challenge216.py FF
pemjh\challenge220\challenge220.py FF
pemjh\challenge225\challenge225.py FF
pemjh\challenge230\challenge230.py FF
pemjh\challenge231\challenge231.py FF
pemjh\challenge234\challenge234.py FF
pemjh\challenge235\challenge235.py FF
pemjh\challenge243\challenge243.py FF
pemjh\challenge250\challenge250.py FF
pemjh\challenge259\challenge259.py FF
pemjh\challenge265\challenge265.py FF

=================================== ERRORS ====================================
__________________________ ERROR collecting setup.py __________________________

self = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
func = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
self       = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>, attrname = '_collected'
function = <function <lambda> at 0x03d42390>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = None
function   = <function <lambda> at 0x03d42390>
self       = <DoctestModule 'setup.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'setup.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\setup.py'), modname = 'setup'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'setup'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh')
self       = local('D:\\Development\\pemjh\\setup.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """ Setup file for install and test. Taken from:
    https://pythonhosted.org/an_example_pypi_project/setuptools.html
    for pytest:
    https://pytest.org/latest/goodpractises.html
    for tox:
    https://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands"""
    
    import os
    import sys
    from setuptools import setup
    from setuptools.command.test import test as TestCommand
    
    def read(fname):
        return open(os.path.join(os.path.dirname(__file__), fname)).read()
    
    class Tox(TestCommand):
        user_options = [('tox-args=', 'a', "Arguments to pass to tox")]
        def initialize_options(self):
            TestCommand.initialize_options(self)
            self.tox_args = None
        def finalize_options(self):
            TestCommand.finalize_options(self)
            self.test_args = []
            self.test_suite = True
        def run_tests(self):
            #import here, cause outside the eggs aren't loaded
            import tox
            import shlex
            args = self.tox_args
            if args:
                args = shlex.split(self.tox_args)
            errno = tox.cmdline(args=args)
            sys.exit(errno)
    
    setup(
        name = "pemjh",
        version = "0.0.1",
        author = "Matthew Hussey",
        author_email = "matthew.hussey@googlemail.com",
        description = ("Project euler (https://projecteuler.net/) challenge "
                       "code in Python."),
        license = "None, private use by myself only",
        keywords = "code challenge euler",
        url = "none.non",
        packages = ["pemjh"],
        long_description = read("README"),
        classifiers=[
            "Development Status :: 1 - Planning"],
        tests_require=['tox'],
>       cmdclass = {"test": Tox},
    )

TestCommand = <class setuptools.command.test.test at 0x03334460>
Tox        = <class setup.Tox at 0x03334430>
__builtins__ = <builtins>
__doc__    = ' Setup file for install and test. Taken from:\nhttps://pythonhosted.org/an_example_pypi_project/setuptools.html\nfor ...html\nfor tox:\nhttps://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands'
__file__   = 'D:\\Development\\pemjh\\setup.py'
__name__   = 'setup'
__package__ = None
os         = <module 'os' from 'd:\\development\\pemjh\\.tox\\pypy\\lib-python\\2.7\\os.pyc'>
read       = <function read at 0x035123d0>
setup      = <function setup at 0x0313b7d0>
sys        = <module 'sys' (built-in)>

setup.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

attrs = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x03334430>}, ...}
klass = <class setuptools.dist.Distribution at 0x03763970>
dist = <setuptools.dist.Distribution instance at 0x0381cad8>
msg = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

    def setup(**attrs):
        """The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
    
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
    
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
    
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.
        """
    
        global _setup_stop_after, _setup_distribution
    
        # Determine the distribution class -- either caller-supplied or
        # our Distribution (see below).
        klass = attrs.get('distclass')
        if klass:
            del attrs['distclass']
        else:
            klass = Distribution
    
        if 'script_name' not in attrs:
            attrs['script_name'] = os.path.basename(sys.argv[0])
        if 'script_args' not in attrs:
            attrs['script_args'] = sys.argv[1:]
    
        # Create the Distribution instance, using the remaining arguments
        # (ie. everything except distclass) to initialize it
        try:
            _setup_distribution = dist = klass(attrs)
        except DistutilsSetupError, msg:
            if 'name' in attrs:
                raise SystemExit, "error in %s setup command: %s" % \
                      (attrs['name'], msg)
            else:
                raise SystemExit, "error in setup command: %s" % msg
    
        if _setup_stop_after == "init":
            return dist
    
        # Find and parse the config file(s): they will override options from
        # the setup script, but be overridden by the command line.
        dist.parse_config_files()
    
        if DEBUG:
            print "options (after parsing config files):"
            dist.dump_option_dicts()
    
        if _setup_stop_after == "config":
            return dist
    
        # Parse the command line and override config files; any
        # command-line errors are the end user's fault, so turn them into
        # SystemExit to suppress tracebacks.
        try:
            ok = dist.parse_command_line()
        except DistutilsArgError, msg:
>           raise SystemExit, gen_usage(dist.script_name) + "\nerror: %s" % msg
E           SystemExit: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
E              or: py.test.EXE --help [cmd1 cmd2 ...]
E              or: py.test.EXE --help-commands
E              or: py.test.EXE cmd --help
E           
E           error: option --pylint not recognized

attrs      = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x03334430>}, ...}
dist       = <setuptools.dist.Distribution instance at 0x0381cad8>
klass      = <class setuptools.dist.Distribution at 0x03763970>
msg        = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

E:\software_tools\python\pypy-2.6.1-win32\lib-python\2.7\distutils\core.py:139: SystemExit
_____________ ERROR collecting pemjh/challenge002/challenge002.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>
attrname = '_collected', function = <function <lambda> at 0x0388cc10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x040edd94>)
function   = <function <lambda> at 0x0388cc10>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fibo
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py'
__name__   = 'challenge002'
__package__ = None

pemjh\challenge002\challenge002.py:5: ImportError
_____________ ERROR collecting pemjh/challenge012/challenge012.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>
attrname = '_collected', function = <function <lambda> at 0x0388cc90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03980c90>)
function   = <function <lambda> at 0x0388cc90>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py'
__name__   = 'challenge012'
__package__ = None
sqrt       = <built-in function sqrt>

pemjh\challenge012\challenge012.py:6: ImportError
_____________ ERROR collecting pemjh/challenge015/challenge015.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>
attrname = '_collected', function = <function <lambda> at 0x03338dd0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04457eac>)
function   = <function <lambda> at 0x03338dd0>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py'
__name__   = 'challenge015'
__package__ = None

pemjh\challenge015\challenge015.py:5: ImportError
_____________ ERROR collecting pemjh/challenge018/challenge018.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>
attrname = '_collected', function = <function <lambda> at 0x039f5e90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x031a5efc>)
function   = <function <lambda> at 0x039f5e90>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py'
__name__   = 'challenge018'
__package__ = None

pemjh\challenge018\challenge018.py:4: ImportError
_____________ ERROR collecting pemjh/challenge021/challenge021.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>
attrname = '_collected', function = <function <lambda> at 0x0413bd50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03bc172c>)
function   = <function <lambda> at 0x0413bd50>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import divisors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py'
__name__   = 'challenge021'
__package__ = None

pemjh\challenge021\challenge021.py:5: ImportError
_____________ ERROR collecting pemjh/challenge024/challenge024.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>
attrname = '_collected', function = <function <lambda> at 0x03e37650>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03c8ab78>)
function   = <function <lambda> at 0x03e37650>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py'
__name__   = 'challenge024'
__package__ = None

pemjh\challenge024\challenge024.py:5: ImportError
_____________ ERROR collecting pemjh/challenge025/challenge025.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>
attrname = '_collected', function = <function <lambda> at 0x041fbd50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x041b9d6c>)
function   = <function <lambda> at 0x041fbd50>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fibo
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py'
__name__   = 'challenge025'
__package__ = None

pemjh\challenge025\challenge025.py:4: ImportError
_____________ ERROR collecting pemjh/challenge027/challenge027.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>
attrname = '_collected', function = <function <lambda> at 0x03338cd0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03c4ade4>)
function   = <function <lambda> at 0x03338cd0>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py'
__name__   = 'challenge027'
__package__ = None

pemjh\challenge027\challenge027.py:5: ImportError
_____________ ERROR collecting pemjh/challenge032/challenge032.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>
attrname = '_collected', function = <function <lambda> at 0x03932290>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x042ce204>)
function   = <function <lambda> at 0x03932290>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py'
__name__   = 'challenge032'
__package__ = None

pemjh\challenge032\challenge032.py:5: ImportError
_____________ ERROR collecting pemjh/challenge033/challenge033.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>
attrname = '_collected', function = <function <lambda> at 0x046ffc50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02ef6740>)
function   = <function <lambda> at 0x046ffc50>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import lowestCommonTerms
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py'
__name__   = 'challenge033'
__package__ = None

pemjh\challenge033\challenge033.py:5: ImportError
_____________ ERROR collecting pemjh/challenge034/challenge034.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>
attrname = '_collected', function = <function <lambda> at 0x039f5d50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03158b8c>)
function   = <function <lambda> at 0x039f5d50>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py'
__name__   = 'challenge034'
__package__ = None

pemjh\challenge034\challenge034.py:5: ImportError
_____________ ERROR collecting pemjh/challenge035/challenge035.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>
attrname = '_collected', function = <function <lambda> at 0x03e37e90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0442afec>)
function   = <function <lambda> at 0x03e37e90>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py'
__name__   = 'challenge035'
__package__ = None

pemjh\challenge035\challenge035.py:5: ImportError
_____________ ERROR collecting pemjh/challenge037/challenge037.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>
attrname = '_collected', function = <function <lambda> at 0x03512990>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0386336c>)
function   = <function <lambda> at 0x03512990>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py'
__name__   = 'challenge037'
__package__ = None

pemjh\challenge037\challenge037.py:5: ImportError
_____________ ERROR collecting pemjh/challenge041/challenge041.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>
attrname = '_collected', function = <function <lambda> at 0x033a4f90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0442a600>)
function   = <function <lambda> at 0x033a4f90>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py'
__name__   = 'challenge041'
__package__ = None

pemjh\challenge041\challenge041.py:5: ImportError
_____________ ERROR collecting pemjh/challenge043/challenge043.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>
attrname = '_collected', function = <function <lambda> at 0x04a97650>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x031d8268>)
function   = <function <lambda> at 0x04a97650>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.strings import permutate
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py'
__name__   = 'challenge043'
__package__ = None

pemjh\challenge043\challenge043.py:4: ImportError
_____________ ERROR collecting pemjh/challenge046/challenge046.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>
attrname = '_collected', function = <function <lambda> at 0x03e37090>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04344d08>)
function   = <function <lambda> at 0x03e37090>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import sqrt
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py'
__name__   = 'challenge046'
__package__ = None
sqrt       = <built-in function sqrt>

pemjh\challenge046\challenge046.py:6: ImportError
_____________ ERROR collecting pemjh/challenge047/challenge047.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>
attrname = '_collected', function = <function <lambda> at 0x0413b790>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03cb7a24>)
function   = <function <lambda> at 0x0413b790>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py'
__name__   = 'challenge047'
__package__ = None
count      = <type 'itertools.count'>

pemjh\challenge047\challenge047.py:6: ImportError
_____________ ERROR collecting pemjh/challenge049/challenge049.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>
attrname = '_collected', function = <function <lambda> at 0x03932550>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0236b088>)
function   = <function <lambda> at 0x03932550>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import string
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py'
__name__   = 'challenge049'
__package__ = None
string     = <module 'string' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\string.pyc'>

pemjh\challenge049\challenge049.py:6: ImportError
_____________ ERROR collecting pemjh/challenge050/challenge050.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>
attrname = '_collected', function = <function <lambda> at 0x046ff710>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03ca3984>)
function   = <function <lambda> at 0x046ff710>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py'
__name__   = 'challenge050'
__package__ = None

pemjh\challenge050\challenge050.py:4: ImportError
_____________ ERROR collecting pemjh/challenge051/challenge051.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>
attrname = '_collected', function = <function <lambda> at 0x039f5790>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x032d472c>)
function   = <function <lambda> at 0x039f5790>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import cycle
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py'
__name__   = 'challenge051'
__package__ = None
cycle      = <type 'itertools.cycle'>

pemjh\challenge051\challenge051.py:6: ImportError
_____________ ERROR collecting pemjh/challenge053/challenge053.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>
attrname = '_collected', function = <function <lambda> at 0x033a4410>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x042e1eac>)
function   = <function <lambda> at 0x033a4410>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py'
__name__   = 'challenge053'
__package__ = None

pemjh\challenge053\challenge053.py:4: ImportError
_____________ ERROR collecting pemjh/challenge058/challenge058.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>
attrname = '_collected', function = <function <lambda> at 0x046ff910>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03a9e36c>)
function   = <function <lambda> at 0x046ff910>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py'
__name__   = 'challenge058'
__package__ = None

pemjh\challenge058\challenge058.py:4: ImportError
_____________ ERROR collecting pemjh/challenge060/challenge060.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>
attrname = '_collected', function = <function <lambda> at 0x03e7f310>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04537844>)
function   = <function <lambda> at 0x03e7f310>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, PrimeChecker
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py'
__name__   = 'challenge060'
__package__ = None

pemjh\challenge060\challenge060.py:5: ImportError
_____________ ERROR collecting pemjh/challenge064/challenge064.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>
attrname = '_collected', function = <function <lambda> at 0x033a4b50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03810cb8>)
function   = <function <lambda> at 0x033a4b50>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import continueGenerator
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py'
__name__   = 'challenge064'
__package__ = None

pemjh\challenge064\challenge064.py:1: ImportError
_____________ ERROR collecting pemjh/challenge065/challenge065.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>
attrname = '_collected', function = <function <lambda> at 0x039f5150>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03538d58>)
function   = <function <lambda> at 0x039f5150>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py'
__name__   = 'challenge065'
__package__ = None

pemjh\challenge065\challenge065.py:4: ImportError
_____________ ERROR collecting pemjh/challenge066/challenge066.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>
attrname = '_collected', function = <function <lambda> at 0x046ff990>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x037b33a8>)
function   = <function <lambda> at 0x046ff990>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import rootConvergentGenerator
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py'
__name__   = 'challenge066'
__package__ = None

pemjh\challenge066\challenge066.py:1: ImportError
_____________ ERROR collecting pemjh/challenge067/challenge067.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>
attrname = '_collected', function = <function <lambda> at 0x03e377d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03c066f0>)
function   = <function <lambda> at 0x03e377d0>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import with_statement
    from os.path import dirname, abspath
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py'
__name__   = 'challenge067'
__package__ = None
abspath    = <function abspath at 0x0207bd10>
dirname    = <function dirname at 0x0207bb50>
with_statement = _Feature((2, 5, 0, 'alpha', 1), (2, 6, 0, 'alpha', 0), 32768)

pemjh\challenge067\challenge067.py:9: ImportError
_____________ ERROR collecting pemjh/challenge069/challenge069.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>
attrname = '_collected', function = <function <lambda> at 0x02810e10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03a8d358>)
function   = <function <lambda> at 0x02810e10>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py'
__name__   = 'challenge069'
__package__ = None

pemjh\challenge069\challenge069.py:4: ImportError
_____________ ERROR collecting pemjh/challenge070/challenge070.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>
attrname = '_collected', function = <function <lambda> at 0x0388cf10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x033c327c>)
function   = <function <lambda> at 0x0388cf10>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py'
__name__   = 'challenge070'
__package__ = None

pemjh\challenge070\challenge070.py:4: ImportError
_____________ ERROR collecting pemjh/challenge072/challenge072.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>
attrname = '_collected', function = <function <lambda> at 0x03e7f790>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03b0accc>)
function   = <function <lambda> at 0x03e7f790>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import phi
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py'
__name__   = 'challenge072'
__package__ = None

pemjh\challenge072\challenge072.py:5: ImportError
_____________ ERROR collecting pemjh/challenge073/challenge073.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>
attrname = '_collected', function = <function <lambda> at 0x039f59d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02ee8b64>)
function   = <function <lambda> at 0x039f59d0>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import ceil, floor
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py'
__name__   = 'challenge073'
__package__ = None
ceil       = <built-in function ceil>
floor      = <built-in function floor>

pemjh\challenge073\challenge073.py:6: ImportError
_____________ ERROR collecting pemjh/challenge075/challenge075.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>
attrname = '_collected', function = <function <lambda> at 0x047e7e50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03158f88>)
function   = <function <lambda> at 0x047e7e50>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py'
__name__   = 'challenge075'
__package__ = None

pemjh\challenge075\challenge075.py:1: ImportError
_____________ ERROR collecting pemjh/challenge077/challenge077.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>
attrname = '_collected', function = <function <lambda> at 0x03e7f850>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02f676c8>)
function   = <function <lambda> at 0x03e7f850>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py'
__name__   = 'challenge077'
__package__ = None

pemjh\challenge077\challenge077.py:1: ImportError
_____________ ERROR collecting pemjh/challenge087/challenge087.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>
attrname = '_collected', function = <function <lambda> at 0x047c0310>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x041db3d0>)
function   = <function <lambda> at 0x047c0310>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py'
__name__   = 'challenge087'
__package__ = None

pemjh\challenge087\challenge087.py:4: ImportError
_____________ ERROR collecting pemjh/challenge092/challenge092.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>
attrname = '_collected', function = <function <lambda> at 0x04b3b250>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02f87b50>)
function   = <function <lambda> at 0x04b3b250>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py'
__name__   = 'challenge092'
__package__ = None

pemjh\challenge092\challenge092.py:4: ImportError
_____________ ERROR collecting pemjh/challenge104/challenge104.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>
attrname = '_collected', function = <function <lambda> at 0x04b3b990>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03ba08a8>)
function   = <function <lambda> at 0x04b3b990>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py'
__name__   = 'challenge104'
__package__ = None

pemjh\challenge104\challenge104.py:1: ImportError
_____________ ERROR collecting pemjh/challenge108/challenge108.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>
attrname = '_collected', function = <function <lambda> at 0x041fb710>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03d4cfec>)
function   = <function <lambda> at 0x041fb710>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py'
__name__   = 'challenge108'
__package__ = None

pemjh\challenge108\challenge108.py:1: ImportError
_____________ ERROR collecting pemjh/challenge110/challenge110.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>
attrname = '_collected', function = <function <lambda> at 0x038cebd0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03b62934>)
function   = <function <lambda> at 0x038cebd0>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py'
__name__   = 'challenge110'
__package__ = None

pemjh\challenge110\challenge110.py:1: ImportError
_____________ ERROR collecting pemjh/challenge111/challenge111.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>
attrname = '_collected', function = <function <lambda> at 0x0413bdd0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x027424e8>)
function   = <function <lambda> at 0x0413bdd0>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, roughPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py'
__name__   = 'challenge111'
__package__ = None

pemjh\challenge111\challenge111.py:1: ImportError
_____________ ERROR collecting pemjh/challenge113/challenge113.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>
attrname = '_collected', function = <function <lambda> at 0x047c0810>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04464a4c>)
function   = <function <lambda> at 0x047c0810>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import polytopicNumbers
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py'
__name__   = 'challenge113'
__package__ = None

pemjh\challenge113\challenge113.py:4: ImportError
_____________ ERROR collecting pemjh/challenge118/challenge118.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>
attrname = '_collected', function = <function <lambda> at 0x046add10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02f87c2c>)
function   = <function <lambda> at 0x046add10>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py'
__name__   = 'challenge118'
__package__ = None

pemjh\challenge118\challenge118.py:1: ImportError
_____________ ERROR collecting pemjh/challenge121/challenge121.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>
attrname = '_collected', function = <function <lambda> at 0x039f5490>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03854bc8>)
function   = <function <lambda> at 0x039f5490>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py'
__name__   = 'challenge121'
__package__ = None

pemjh\challenge121\challenge121.py:1: ImportError
_____________ ERROR collecting pemjh/challenge123/challenge123.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>
attrname = '_collected', function = <function <lambda> at 0x038ce790>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x043d981c>)
function   = <function <lambda> at 0x038ce790>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py'
__name__   = 'challenge123'
__package__ = None

pemjh\challenge123\challenge123.py:1: ImportError
_____________ ERROR collecting pemjh/challenge124/challenge124.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>
attrname = '_collected', function = <function <lambda> at 0x03507e90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x033f3a74>)
function   = <function <lambda> at 0x03507e90>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py'
__name__   = 'challenge124'
__package__ = None

pemjh\challenge124\challenge124.py:1: ImportError
_____________ ERROR collecting pemjh/challenge127/challenge127.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>
attrname = '_collected', function = <function <lambda> at 0x047c0650>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03b966dc>)
function   = <function <lambda> at 0x047c0650>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import gcd, sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py'
__name__   = 'challenge127'
__package__ = None

pemjh\challenge127\challenge127.py:1: ImportError
_____________ ERROR collecting pemjh/challenge128/challenge128.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>
attrname = '_collected', function = <function <lambda> at 0x04f1ab90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x033813e4>)
function   = <function <lambda> at 0x04f1ab90>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py'
__name__   = 'challenge128'
__package__ = None

pemjh\challenge128\challenge128.py:1: ImportError
_____________ ERROR collecting pemjh/challenge130/challenge130.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>
attrname = '_collected', function = <function <lambda> at 0x046ffb10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04521a10>)
function   = <function <lambda> at 0x046ffb10>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py'
__name__   = 'challenge130'
__package__ = None

pemjh\challenge130\challenge130.py:1: ImportError
_____________ ERROR collecting pemjh/challenge131/challenge131.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>
attrname = '_collected', function = <function <lambda> at 0x038cea10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x042a9c18>)
function   = <function <lambda> at 0x038cea10>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py'
__name__   = 'challenge131'
__package__ = None

pemjh\challenge131\challenge131.py:1: ImportError
_____________ ERROR collecting pemjh/challenge132/challenge132.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>
attrname = '_collected', function = <function <lambda> at 0x04ee8b50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0393afb0>)
function   = <function <lambda> at 0x04ee8b50>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py'
__name__   = 'challenge132'
__package__ = None

pemjh\challenge132\challenge132.py:1: ImportError
_____________ ERROR collecting pemjh/challenge133/challenge133.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>
attrname = '_collected', function = <function <lambda> at 0x03f3c850>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03c4f574>)
function   = <function <lambda> at 0x03f3c850>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py'
__name__   = 'challenge133'
__package__ = None

pemjh\challenge133\challenge133.py:1: ImportError
_____________ ERROR collecting pemjh/challenge134/challenge134.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>
attrname = '_collected', function = <function <lambda> at 0x03e37d50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x043b272c>)
function   = <function <lambda> at 0x03e37d50>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py'
__name__   = 'challenge134'
__package__ = None

pemjh\challenge134\challenge134.py:1: ImportError
_____________ ERROR collecting pemjh/challenge136/challenge136.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>
attrname = '_collected', function = <function <lambda> at 0x047c07d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03831628>)
function   = <function <lambda> at 0x047c07d0>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py'
__name__   = 'challenge136'
__package__ = None

pemjh\challenge136\challenge136.py:1: ImportError
_____________ ERROR collecting pemjh/challenge138/challenge138.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>
attrname = '_collected', function = <function <lambda> at 0x046ad450>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x039eebf0>)
function   = <function <lambda> at 0x046ad450>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py'
__name__   = 'challenge138'
__package__ = None

pemjh\challenge138\challenge138.py:1: ImportError
_____________ ERROR collecting pemjh/challenge139/challenge139.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>
attrname = '_collected', function = <function <lambda> at 0x0440fb50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x033c3ca4>)
function   = <function <lambda> at 0x0440fb50>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py'
__name__   = 'challenge139'
__package__ = None

pemjh\challenge139\challenge139.py:1: ImportError
_____________ ERROR collecting pemjh/challenge174/challenge174.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>
attrname = '_collected', function = <function <lambda> at 0x0388cb90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x037c47b8>)
function   = <function <lambda> at 0x0388cb90>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py'
__name__   = 'challenge174'
__package__ = None

pemjh\challenge174\challenge174.py:1: ImportError
_____________ ERROR collecting pemjh/challenge183/challenge183.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>
attrname = '_collected', function = <function <lambda> at 0x048d7c10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03377560>)
function   = <function <lambda> at 0x048d7c10>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import primeFactors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py'
__name__   = 'challenge183'
__package__ = None

pemjh\challenge183\challenge183.py:1: ImportError
_____________ ERROR collecting pemjh/challenge187/challenge187.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>
attrname = '_collected', function = <function <lambda> at 0x04f1a290>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x033eb7e0>)
function   = <function <lambda> at 0x04f1a290>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py'
__name__   = 'challenge187'
__package__ = None

pemjh\challenge187\challenge187.py:1: ImportError
_____________ ERROR collecting pemjh/challenge203/challenge203.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>
attrname = '_collected', function = <function <lambda> at 0x038ce850>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0340618c>)
function   = <function <lambda> at 0x038ce850>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py'
__name__   = 'challenge203'
__package__ = None

pemjh\challenge203\challenge203.py:1: ImportError
_____________ ERROR collecting pemjh/challenge204/challenge204.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>
attrname = '_collected', function = <function <lambda> at 0x039326d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03a50d1c>)
function   = <function <lambda> at 0x039326d0>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py'
__name__   = 'challenge204'
__package__ = None

pemjh\challenge204\challenge204.py:1: ImportError
_____________ ERROR collecting pemjh/challenge211/challenge211.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>
attrname = '_collected', function = <function <lambda> at 0x047e7d10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03a9eccc>)
function   = <function <lambda> at 0x047e7d10>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors, sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py'
__name__   = 'challenge211'
__package__ = None

pemjh\challenge211\challenge211.py:1: ImportError
_____________ ERROR collecting pemjh/challenge214/challenge214.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>
attrname = '_collected', function = <function <lambda> at 0x033a4090>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03a7ace0>)
function   = <function <lambda> at 0x033a4090>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes, primeFactors, phi
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py'
__name__   = 'challenge214'
__package__ = None

pemjh\challenge214\challenge214.py:1: ImportError
_____________ ERROR collecting pemjh/challenge231/challenge231.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>
attrname = '_collected', function = <function <lambda> at 0x048d7ed0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x038b0358>)
function   = <function <lambda> at 0x048d7ed0>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py'
__name__   = 'challenge231'
__package__ = None

pemjh\challenge231\challenge231.py:1: ImportError
_____________ ERROR collecting pemjh/challenge234/challenge234.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>
attrname = '_collected', function = <function <lambda> at 0x03f3cf50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x029c0038>)
function   = <function <lambda> at 0x03f3cf50>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py'
__name__   = 'challenge234'
__package__ = None

pemjh\challenge234\challenge234.py:1: ImportError
_____________ ERROR collecting pemjh/challenge243/challenge243.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>
attrname = '_collected', function = <function <lambda> at 0x046d27d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02f76790>)
function   = <function <lambda> at 0x046d27d0>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py'
__name__   = 'challenge243'
__package__ = None

pemjh\challenge243\challenge243.py:1: ImportError
================================== FAILURES ===================================
______________________________ [pylint] setup.py ______________________________
C: 36, 0: No space allowed around keyword argument assignment
    name = "pemjh",
         ^ (bad-whitespace)
C: 37, 0: No space allowed around keyword argument assignment
    version = "0.0.1",
            ^ (bad-whitespace)
C: 38, 0: No space allowed around keyword argument assignment
    author = "Matthew Hussey",
           ^ (bad-whitespace)
C: 39, 0: No space allowed around keyword argument assignment
    author_email = "matthew.hussey@googlemail.com",
                 ^ (bad-whitespace)
C: 40, 0: No space allowed around keyword argument assignment
    description = ("Project euler (https://projecteuler.net/) challenge "
                ^ (bad-whitespace)
C: 42, 0: No space allowed around keyword argument assignment
    license = "None, private use by myself only",
            ^ (bad-whitespace)
C: 43, 0: No space allowed around keyword argument assignment
    keywords = "code challenge euler",
             ^ (bad-whitespace)
C: 44, 0: No space allowed around keyword argument assignment
    url = "none.non",
        ^ (bad-whitespace)
C: 45, 0: No space allowed around keyword argument assignment
    packages = ["pemjh"],
             ^ (bad-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
    long_description = read("README"),
                     ^ (bad-whitespace)
C: 50, 0: No space allowed around keyword argument assignment
    cmdclass = {"test": Tox},
             ^ (bad-whitespace)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing class docstring (missing-docstring)
F: 27, 8: Unable to import 'tox' (import-error)
W: 20, 8: Attribute 'tox_args' defined outside __init__ (attribute-defined-outside-init)
W: 23, 8: Attribute 'test_args' defined outside __init__ (attribute-defined-outside-init)
W: 24, 8: Attribute 'test_suite' defined outside __init__ (attribute-defined-outside-init)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\setup.py:6:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\setup.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:18:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:21:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:25:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:26:9: E265 block comment should start with '# '
D:\Development\pemjh\setup.py:36:9: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:36:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:12: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:14: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:13: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:19: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:18: E251 unexpected spaces around keyword / parameter equals

___________________________ [pylint] pemjh/main.py ____________________________
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 58, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  9, 0: No exception type(s) specified (bare-except)
F:  6, 4: Unable to import 'psyco' (import-error)
C: 12, 0: Invalid function name "testFunction" (invalid-name)
C: 12, 0: Invalid argument name "id" (invalid-name)
C: 12, 0: Invalid argument name "knownAnswer" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
W: 12,17: Redefining built-in 'id' (redefined-builtin)
W: 12,21: Redefining name 'func' from outer scope (line 43) (redefined-outer-name)
W: 12,27: Redefining name 'knownAnswer' from outer scope (line 46) (redefined-outer-name)
C: 30, 0: Invalid constant name "wholeTime" (invalid-name)
C: 32, 0: Invalid constant name "failures" (invalid-name)
C: 34, 0: Invalid constant name "nChallenges" (invalid-name)
C: 60, 0: Invalid constant name "wholeTime" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\main.py:13:15: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\main.py:32:18: W291 trailing whitespace
D:\Development\pemjh\pemjh\main.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\main.py:58:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge001/challenge001.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid constant name "upper" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  4,15: Used builtin function 'filter' (bad-builtin)
W:  4,15: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C:  6, 0: Invalid constant name "answer" (invalid-name)
W:  9, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge001\challenge001.py:9:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge002/challenge002.py _________________
C: 10, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "numRange" (invalid-name)
C: 10, 4: Invalid variable name "evenNums" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge003/challenge003.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 19,26: More than one statement on a single line (multiple-statements)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import math (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge003\challenge003.py:1:1: F401 'math' imported but unused
D:\Development\pemjh\pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge003\challenge003.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge004/challenge004.py _________________
C:  8, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 18, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 26, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 18,61: More than one statement on a single line (multiple-statements)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W: 36, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge004\challenge004.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge005/challenge005.py _________________
C: 12, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  3, 4: Redefining built-in 'max' (redefined-builtin)
C:  6, 8: Invalid variable name "n" (invalid-name)
C: 14,16: Invalid variable name "n" (invalid-name)
C: 28,23: More than one statement on a single line (multiple-statements)
C: 31, 8: Invalid variable name "n" (invalid-name)
C: 31,11: Invalid variable name "p" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge005\challenge005.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge006/challenge006.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'max' (redefined-builtin)
W: 10, 4: Redefining built-in 'sum' (redefined-builtin)
C:  4, 4: Invalid variable name "sumOfSquares" (invalid-name)
C:  7, 8: Invalid variable name "sumOfSquares" (invalid-name)
C: 13, 4: Invalid variable name "squareOfSums" (invalid-name)
C: 20, 0: Invalid constant name "answer" (invalid-name)
W: 23, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:23:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge007/challenge007.py _________________
C: 14, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'max' (redefined-builtin)
C: 13, 8: Invalid variable name "primeRange" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
W: 24, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge007\challenge007.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge008/challenge008.py _________________
C: 29, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'input' (redefined-builtin)
C: 26, 8: Invalid variable name "testPart" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
W: 44, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge008\challenge008.py:44:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge009/challenge009.py _________________
C:  8, 0: Exactly one space required after comma
    for a in range(1,(max / 3)):
                    ^ (bad-whitespace)
C: 11, 0: Exactly one space required after comma
        for b in range((a + 1),(a + 1 + (remainder / 2))):
                              ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  4, 4: Redefining built-in 'max' (redefined-builtin)
W:  5, 4: Redefining name 'answer' from outer scope (line 18) (redefined-outer-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C: 11,12: Invalid variable name "b" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge010/challenge010.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  6, 4: Redefining built-in 'max' (redefined-builtin)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ifilter imported from itertools (unused-import)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge010\challenge010.py:1:1: F401 'ifilter' imported but unused
D:\Development\pemjh\pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge010\challenge010.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge011/challenge011.py _________________
C:  2, 0: Line too long (1212/100) (line-too-long)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCols" (invalid-name)
C: 10, 8: Invalid variable name "currentRow" (invalid-name)
C: 12,12: Invalid variable name "nextChunk" (invalid-name)
C: 31,36: More than one statement on a single line (multiple-statements)
C: 38,40: More than one statement on a single line (multiple-statements)
C: 45,40: More than one statement on a single line (multiple-statements)
C: 52,36: More than one statement on a single line (multiple-statements)
W: 11,12: Unused variable 'index' (unused-variable)
R:  1, 0: Too many branches (16/12) (too-many-branches)
C: 58, 0: Invalid constant name "answer" (invalid-name)
W: 61, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:61:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge012/challenge012.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 15, 0: Invalid function name "triangleDivisors" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 16, 4: Invalid variable name "n" (invalid-name)
C: 17, 4: Invalid variable name "nOdd" (invalid-name)
C: 18, 4: Invalid variable name "nEven" (invalid-name)
C: 19, 4: Invalid variable name "knownDivisors" (invalid-name)
C: 24,12: Invalid variable name "nOdd" (invalid-name)
C: 27,12: Invalid variable name "nEven" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36,22: More than one statement on a single line (multiple-statements)
W: 38,12: Using possibly undefined loop variable 'n' (undefined-loop-variable)
W: 38,17: Using possibly undefined loop variable 'n' (undefined-loop-variable)
C: 40, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge013/challenge013.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:111, 0: Invalid constant name "answer" (invalid-name)
W:114, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:114:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge014/challenge014.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getChainSize" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "knownChains" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "knownChains" (invalid-name)
C: 31, 8: Invalid variable name "newChain" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge015/challenge015.py _________________
C:  7, 0: No space allowed around keyword argument assignment
def multiplierGen(n = 0):
                    ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "multiplierGen" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid function name "getRoutes" (invalid-name)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge016/challenge016.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge016\challenge016.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge017/challenge017.py _________________
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 37, 0: Trailing whitespace (trailing-whitespace)
C:103, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumberLength" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "hundredRep" (invalid-name)
C:  1, 0: Invalid argument name "andRep" (invalid-name)
C:  1, 0: Invalid argument name "thousandRep" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "tempN" (invalid-name)
C:  7, 8: Invalid variable name "numberRepresentation" (invalid-name)
C: 13,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 16,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 18,12: Invalid variable name "tempN" (invalid-name)
C: 22,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 29,16: Invalid variable name "tempN" (invalid-name)
C: 31,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 35,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 41, 0: Missing function docstring (missing-docstring)
C: 70, 4: Invalid variable name "knownInts" (invalid-name)
C:100, 4: Invalid variable name "endLine" (invalid-name)
W: 70, 4: Unused variable 'knownInts' (unused-variable)
W:100, 4: Unused variable 'endLine' (unused-variable)
C:106, 0: Invalid constant name "answer" (invalid-name)
W:109, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:5: F841 local variable 'knownInts' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:100:5: F841 local variable 'endLine' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:109:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge018/challenge018.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge018\challenge018.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge019/challenge019.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isLeapYear" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "getYearDays" (invalid-name)
C:  5, 0: Invalid argument name "y" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "getFirstJan" (invalid-name)
C: 11, 0: Invalid argument name "y" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "totalDays" (invalid-name)
C: 14, 8: Invalid variable name "totalDays" (invalid-name)
C: 17, 0: Invalid function name "monthStartDays" (invalid-name)
C: 17, 0: Invalid argument name "y" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "monthLengths" (invalid-name)
C: 25, 8: Invalid variable name "m" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "totalDays" (invalid-name)
C: 34, 8: Invalid variable name "y" (invalid-name)
C: 36,12: Invalid variable name "d" (invalid-name)
C: 38,16: Invalid variable name "totalDays" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
W: 45, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge020/challenge020.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge020\challenge020.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge021/challenge021.py _________________
C: 18, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
W: 11, 4: Redefining built-in 'dict' (redefined-builtin)
C: 12, 8: Invalid variable name "a" (invalid-name)
C: 14, 8: Invalid variable name "b" (invalid-name)
C: 15,12: Invalid variable name "d" (invalid-name)
C: 16,12: Invalid variable name "b" (invalid-name)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'

_________________ [pylint] pemjh/challenge022/challenge022.py _________________
C: 25, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getNames" (invalid-name)
C:  4, 0: Invalid argument name "fp" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7,21: Invalid variable name "f" (invalid-name)
C: 16, 0: Invalid function name "scoredNames" (invalid-name)
C: 16, 0: Invalid argument name "f" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 21,12: Invalid variable name "c" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 29, 8: Invalid variable name "s" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W: 37, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:37:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge023/challenge023.py _________________
C: 10, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "sumOfDivisors" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "p" (invalid-name)
C: 13,12: Invalid variable name "p" (invalid-name)
C: 23, 0: Invalid function name "isSum" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 0: Missing function docstring (missing-docstring)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge024/challenge024.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge024\challenge024.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge025/challenge025.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8,11: Invalid variable name "c" (invalid-name)
C:  9, 8: Invalid variable name "l" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge026/challenge026.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "biggestD" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C: 14,12: Invalid variable name "newSize" (invalid-name)
C: 18,16: Invalid variable name "biggestD" (invalid-name)
C: 20,12: Invalid variable name "newSize" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import string (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge026\challenge026.py:1:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge027/challenge027.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "aMax" (invalid-name)
C: 13, 4: Invalid variable name "bMax" (invalid-name)
C: 16, 4: Invalid variable name "bS" (invalid-name)
C: 17, 8: Invalid variable name "b" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "n" (invalid-name)
C: 21,16: Invalid variable name "f" (invalid-name)
C: 22,35: More than one statement on a single line (multiple-statements)
C: 23,16: Invalid variable name "n" (invalid-name)
C: 27,16: Invalid variable name "aMax" (invalid-name)
C: 28,16: Invalid variable name "bMax" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge027\challenge027.py:6:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge027\challenge027.py:35:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge028/challenge028.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge028\challenge028.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge029/challenge029.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "aLower" (invalid-name)
C:  3, 4: Invalid variable name "aUpper" (invalid-name)
C:  4, 4: Invalid variable name "bLower" (invalid-name)
C:  5, 4: Invalid variable name "bUpper" (invalid-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  9,12: Invalid variable name "b" (invalid-name)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge029\challenge029.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge030/challenge030.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "perDigit" (invalid-name)
C:  7, 4: Invalid variable name "grandTotal" (invalid-name)
C: 11,12: Invalid variable name "c" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "grandTotal" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge030\challenge030.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge031/challenge031.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPatternCount" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid constant name "answer" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
W: 22, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge031\challenge031.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge032/challenge032.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge032\challenge032.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge033/challenge033.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "totalNum" (invalid-name)
C:  9, 4: Invalid variable name "totalDen" (invalid-name)
C: 20,16: Invalid variable name "n1" (invalid-name)
C: 21,16: Invalid variable name "n2" (invalid-name)
C: 22,16: Invalid variable name "d3" (invalid-name)
C: 23,16: Invalid variable name "d4" (invalid-name)
C: 29,24: Invalid variable name "totalNum" (invalid-name)
C: 30,24: Invalid variable name "totalDen" (invalid-name)
C: 37,24: Invalid variable name "totalNum" (invalid-name)
C: 38,24: Invalid variable name "totalDen" (invalid-name)
C: 40, 4: Invalid variable name "totalNum" (invalid-name)
C: 40,14: Invalid variable name "totalDen" (invalid-name)
C: 44, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:47:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge034/challenge034.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "getLimit" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "factSum" (invalid-name)
C:  9, 4: Invalid variable name "factNine" (invalid-name)
C: 13, 8: Invalid variable name "factSum" (invalid-name)
C: 15,29: More than one statement on a single line (multiple-statements)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 8: Invalid variable name "iStr" (invalid-name)
C: 35, 8: Invalid variable name "iTotal" (invalid-name)
C: 36,12: Invalid variable name "c" (invalid-name)
C: 37,12: Invalid variable name "iTotal" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge035/challenge035.py _________________
C: 32, 0: Wrong continued indentation.
              if b == True and
              ^   | (bad-continuation)
C: 33, 0: Wrong continued indentation.
              ((p < 10) or not any(c in str(p) for c in disallowedChars))])
              ^   | (bad-continuation)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "nStr" (invalid-name)
C: 15, 8: Invalid variable name "nextString" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "disallowedChars" (invalid-name)
C: 35, 4: Invalid variable name "circularCount" (invalid-name)
C: 39, 8: Invalid variable name "circularList" (invalid-name)
C: 42, 8: Invalid variable name "allFound" (invalid-name)
C: 48,16: Invalid variable name "allFound" (invalid-name)
C: 51,12: Invalid variable name "circularCount" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sievedPrimes imported from utils.numbers (unused-import)
W:  5, 0: Unused fact imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'fact' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'sievedPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
D:\Development\pemjh\pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge035\challenge035.py:58:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge036/challenge036.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getBinaryString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "binStr" (invalid-name)
C:  5, 8: Invalid variable name "binStr" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 18, 8: Invalid variable name "decStr" (invalid-name)
C: 21,12: Invalid variable name "binStr" (invalid-name)
W: 11, 4: Unused variable 'limit' (unused-variable)
W: 14, 4: Unused variable 'binary' (unused-variable)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W: 29, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge036\challenge036.py:11:5: F841 local variable 'limit' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:14:5: F841 local variable 'binary' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge037/challenge037.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "isTruncPrime" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 12,23: More than one statement on a single line (multiple-statements)
C: 13,45: More than one statement on a single line (multiple-statements)
C: 18,51: More than one statement on a single line (multiple-statements)
C: 23, 0: Missing function docstring (missing-docstring)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge038/challenge038.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "isPandigital" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "m" (invalid-name)
C: 12,11: Invalid variable name "l" (invalid-name)
C: 12,14: Invalid variable name "u" (invalid-name)
C: 13,12: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge038\challenge038.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge039/challenge039.py _________________
W: 18, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
W: 19, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numPerimeters" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "a" (invalid-name)
C: 16, 8: Invalid variable name "bLimit" (invalid-name)
C: 17,12: Invalid variable name "b" (invalid-name)
C: 18,11: Invalid variable name "c" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "highestVal" (invalid-name)
C: 30, 8: Invalid variable name "iCount" (invalid-name)
C: 33,12: Invalid variable name "highestVal" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge039\challenge039.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge040/challenge040.py _________________
C: 11, 0: No space allowed before bracket
        total *= int (str(currentValue)[index - currentN - 1])
                     ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "currentN" (invalid-name)
C:  5, 4: Invalid variable name "currentValue" (invalid-name)
C:  9,12: Invalid variable name "currentValue" (invalid-name)
C: 10,12: Invalid variable name "currentN" (invalid-name)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
D:\Development\pemjh\pemjh\challenge040\challenge040.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge041/challenge041.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
F:  6, 0: Unable to import 'utils.strings' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 15,36: More than one statement on a single line (multiple-statements)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge041\challenge041.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge042/challenge042.py _________________
C: 35, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "scoreWord" (invalid-name)
C:  4, 0: Invalid argument name "w" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "x" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12,62: Invalid variable name "f" (invalid-name)
C: 23, 8: Invalid variable name "nTriangleWords" (invalid-name)
C: 30,16: Invalid variable name "nTriangleWords" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge042\challenge042.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge043/challenge043.py _________________
C:  8, 0: Trailing whitespace (trailing-whitespace)
W: 19, 0: Bad indentation. Found 12 spaces, expected 8 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.strings' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge044/challenge044.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "isPent" (invalid-name)
C:  6, 0: Invalid argument name "p" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "n" (invalid-name)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "pk" (invalid-name)
C: 19, 8: Invalid variable name "performedOneStep" (invalid-name)
C: 20,12: Invalid variable name "pj" (invalid-name)
C: 21,12: Invalid variable name "diffPkPj" (invalid-name)
C: 22,45: More than one statement on a single line (multiple-statements)
C: 25,12: Invalid variable name "performedOneStep" (invalid-name)
C: 27,33: More than one statement on a single line (multiple-statements)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge044\challenge044.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge045/challenge045.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
W:  4, 0: Redefining built-in 'hex' (redefined-builtin)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "pentAndHex" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "p" (invalid-name)
C: 10, 4: Invalid variable name "h" (invalid-name)
C: 12, 8: Invalid variable name "pVal" (invalid-name)
C: 13, 8: Invalid variable name "hVal" (invalid-name)
C: 19,12: Invalid variable name "p" (invalid-name)
C: 21,12: Invalid variable name "h" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 26, 8: Redefining built-in 'next' (redefined-builtin)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge046/challenge046.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "hasCriteria" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "dSq" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "n" (invalid-name)
C: 25, 8: Invalid variable name "n" (invalid-name)
C: 26,36: More than one statement on a single line (multiple-statements)
C: 26,36: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge046\challenge046.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge047/challenge047.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "numPrimeFactors" (invalid-name)
C:  8, 0: Invalid argument name "nPrimes" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "n" (invalid-name)
C: 11, 8: Invalid variable name "pf" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Invalid function name "hasNumPrimes" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 20,30: More than one statement on a single line (multiple-statements)
C: 24, 0: Missing function docstring (missing-docstring)
W: 30, 4: Redefining name 'count' from outer scope (line 1) (redefined-outer-name)
C: 31, 8: Invalid variable name "p" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused count imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
D:\Development\pemjh\pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge048/challenge048.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid constant name "answer" (invalid-name)
W:  8, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge048\challenge048.py:8:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge049/challenge049.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 18, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 21,12: Invalid variable name "p1" (invalid-name)
C: 22,16: Invalid variable name "p2" (invalid-name)
C: 24,16: Invalid variable name "p3" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge049\challenge049.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge050/challenge050.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
W: 13, 4: Redefining name 'answer' from outer scope (line 26) (redefined-outer-name)
C:  9, 4: Invalid variable name "knownPrimes" (invalid-name)
C: 11, 4: Invalid variable name "nPrimes" (invalid-name)
C: 18,31: More than one statement on a single line (multiple-statements)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge050\challenge050.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge050\challenge050.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge051/challenge051.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "substitutePrimes" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid function name "has3SameDigits" (invalid-name)
C: 24, 0: Invalid argument name "n" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "w" (invalid-name)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
C: 39,12: Invalid variable name "w" (invalid-name)
C: 41,16: Invalid variable name "nPrimes" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge052/challenge052.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getSortedString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "x" (invalid-name)
C:  9, 8: Invalid variable name "x" (invalid-name)
C: 10, 8: Invalid variable name "xStr" (invalid-name)
C: 15,12: Invalid variable name "ix" (invalid-name)
C: 16,12: Invalid variable name "ixStr" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge053/challenge053.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge053\challenge053.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge054/challenge054.py _________________
C:122, 0: Trailing whitespace (trailing-whitespace)
C:131, 0: Trailing whitespace (trailing-whitespace)
C:133, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getDuplicateCounts" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "valCounts" (invalid-name)
C: 14, 0: Invalid function name "isStraight" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid function name "isFlush" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid function name "scoreHand" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 52, 8: Invalid variable name "c1" (invalid-name)
C: 52,12: Invalid variable name "c2" (invalid-name)
C: 53, 8: Invalid variable name "v1" (invalid-name)
C: 53,12: Invalid variable name "v2" (invalid-name)
R: 26, 0: Too many return statements (11/6) (too-many-return-statements)
R: 26, 0: Too many branches (15/12) (too-many-branches)
C: 96, 0: Invalid function name "compareHands" (invalid-name)
C: 96, 0: Invalid argument name "handOne" (invalid-name)
C: 96, 0: Invalid argument name "handTwo" (invalid-name)
C: 96, 0: Missing function docstring (missing-docstring)
C:100, 4: Invalid variable name "handOneScore" (invalid-name)
C:100,18: Invalid variable name "handTwoScore" (invalid-name)
C:106,12: Invalid variable name "c1" (invalid-name)
C:106,16: Invalid variable name "c2" (invalid-name)
C:114, 0: Missing function docstring (missing-docstring)
C:115, 4: Invalid variable name "faceConvert" (invalid-name)
C:118, 4: Invalid variable name "nHandOneWins" (invalid-name)
C:119,62: Invalid variable name "f" (invalid-name)
C:120,12: Invalid variable name "l" (invalid-name)
C:129,16: Invalid variable name "nHandOneWins" (invalid-name)
C:133, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace

_________________ [pylint] pemjh/challenge055/challenge055.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "becomesPalindrome" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "workingN" (invalid-name)
C:  6, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
D:\Development\pemjh\pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge055\challenge055.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge056/challenge056.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "a" (invalid-name)
C:  4,12: Invalid variable name "b" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
W: 16, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge056\challenge056.py:16:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge057/challenge057.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTopHeavy" (invalid-name)
C:  5, 8: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  8,15: Invalid variable name "d" (invalid-name)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 10,11: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nTopHeavy" (invalid-name)
W:  7,12: Unused variable 'i' (unused-variable)
C: 17, 0: Invalid constant name "answer" (invalid-name)
W: 20, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge057\challenge057.py:20:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge058/challenge058.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nPrimes" (invalid-name)
C: 13, 4: Invalid variable name "primeChecker" (invalid-name)
C: 22,16: Invalid variable name "nPrimes" (invalid-name)
W:  9, 4: Unused variable 'total' (unused-variable)
W: 18,12: Unused variable 'j' (unused-variable)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
D:\Development\pemjh\pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge059/challenge059.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 27,64: Invalid variable name "f" (invalid-name)
C: 29,12: Invalid variable name "l" (invalid-name)
W: 48, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge060/challenge060.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 64, 0: Line too long (118/100) (line-too-long)
C: 69, 0: Trailing whitespace (trailing-whitespace)
C: 85, 0: Line too long (141/100) (line-too-long)
C: 94, 0: Trailing whitespace (trailing-whitespace)
C: 95, 0: Trailing whitespace (trailing-whitespace)
C: 97, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid constant name "primeSet" (invalid-name)
C:  8, 0: Invalid constant name "maxPrime" (invalid-name)
C: 10, 0: Invalid function name "getNumLength" (invalid-name)
C: 10, 0: Invalid argument name "n" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 14, 8: Invalid variable name "l" (invalid-name)
C: 17, 0: Invalid argument name "m" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "isConcatPrime" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "newFirst" (invalid-name)
C: 25, 4: Invalid variable name "newLast" (invalid-name)
C: 29, 0: Invalid function name "getPrimePairs" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "nPrimes" (invalid-name)
C: 33, 8: Invalid variable name "m" (invalid-name)
C: 34, 8: Invalid variable name "p" (invalid-name)
C: 38,12: Invalid variable name "n" (invalid-name)
C: 39,12: Invalid variable name "q" (invalid-name)
C: 47, 0: Invalid function name "nextDigits" (invalid-name)
C: 47, 0: Invalid argument name "nToFind" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "currentSum" (invalid-name)
C: 49, 4: Invalid variable name "currentSolution" (invalid-name)
C: 50, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 61,16: Invalid variable name "foundSolution" (invalid-name)
C: 64,16: Invalid variable name "foundSolution" (invalid-name)
C: 67,16: Invalid variable name "currentSolution" (invalid-name)
C: 68,16: Invalid variable name "currentSolutionSum" (invalid-name)
C: 71, 0: Invalid function name "nextDigitsDict" (invalid-name)
C: 71, 0: Invalid argument name "nToFind" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 72, 4: Invalid variable name "currentSum" (invalid-name)
C: 73, 4: Invalid variable name "currentSolution" (invalid-name)
C: 74, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 77, 8: Invalid variable name "p" (invalid-name)
C: 83,12: Invalid variable name "foundSolution" (invalid-name)
C: 86,12: Invalid variable name "newPotential" (invalid-name)
C: 87,12: Invalid variable name "foundSolution" (invalid-name)
C: 92,12: Invalid variable name "currentSolution" (invalid-name)
C: 93,12: Invalid variable name "currentSolutionSum" (invalid-name)
C: 98, 0: Missing function docstring (missing-docstring)
W:109, 4: Redefining name 'answer' from outer scope (line 116) (redefined-outer-name)
C:116, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace

_________________ [pylint] pemjh/challenge061/challenge061.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "hasDuplicates" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "eachInList" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 17,12: Invalid variable name "newNums" (invalid-name)
C: 18,12: Invalid variable name "newLists" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
W: 43, 4: Redefining built-in 'hex' (redefined-builtin)
W: 51, 4: Redefining built-in 'oct' (redefined-builtin)
W: 55, 4: Redefining built-in 'all' (redefined-builtin)
R: 24, 0: Too many local variables (27/15) (too-many-locals)
C: 28, 4: Invalid variable name "allLists" (invalid-name)
C: 35, 4: Invalid variable name "sq" (invalid-name)
C: 56, 4: Invalid variable name "d" (invalid-name)
C: 57, 8: Invalid variable name "n" (invalid-name)
C: 64, 8: Invalid variable name "n" (invalid-name)
C: 70,16: Invalid variable name "l" (invalid-name)
C: 76, 8: Invalid variable name "n1" (invalid-name)
C: 79,12: Invalid variable name "n2" (invalid-name)
C: 82,16: Invalid variable name "n3" (invalid-name)
C: 85,20: Invalid variable name "n4" (invalid-name)
C: 88,24: Invalid variable name "n5" (invalid-name)
C: 91,28: Invalid variable name "n6" (invalid-name)
C: 94,32: Invalid variable name "n7" (invalid-name)
R: 24, 0: Too many branches (17/12) (too-many-branches)
C:101, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'

_________________ [pylint] pemjh/challenge062/challenge062.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "n" (invalid-name)
C:  8, 8: Invalid variable name "potentialAnswer" (invalid-name)
C: 19,20: Invalid variable name "nCubes" (invalid-name)
C: 21,12: Invalid variable name "nCubes" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge063/challenge063.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14,26: More than one statement on a single line (multiple-statements)
C: 20,29: More than one statement on a single line (multiple-statements)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge064/challenge064.py _________________
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getPeriodLength" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "pathGen" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 4: Invalid variable name "nOdd" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 32,12: Invalid variable name "nOdd" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge065/challenge065.py _________________
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "nextDen" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused divisors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge065\challenge065.py:4:1: F401 'divisors' imported but unused
D:\Development\pemjh\pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge066/challenge066.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "diophantineX" (invalid-name)
C:  8, 0: Invalid argument name "d" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "x" (invalid-name)
C: 10,11: Invalid variable name "y" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)

_________________ [pylint] pemjh/challenge067/challenge067.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  9, 0: Unable to import 'utils.numbers' (import-error)
C: 11, 0: Missing function docstring (missing-docstring)
W: 14,65: Redefining built-in 'file' (redefined-builtin)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge067\challenge067.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge068/challenge068.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPairs" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "getSpokes" (invalid-name)
C:  7, 0: Invalid argument name "startIndex" (invalid-name)
C:  7, 0: Invalid argument name "nSpokes" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 18,16: Invalid variable name "nextSpokes" (invalid-name)
C: 19,16: Invalid variable name "y" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 54,20: Unused variable 'move' (unused-variable)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)

_________________ [pylint] pemjh/challenge069/challenge069.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "sp" (invalid-name)
C: 11, 4: Invalid variable name "nPhi" (invalid-name)
C: 12,11: Invalid variable name "n" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge070/challenge070.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "isPermutation" (invalid-name)
C:  8, 0: Invalid argument name "a" (invalid-name)
C:  8, 0: Invalid argument name "b" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 17,11: Invalid variable name "p" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused import string (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge071/challenge071.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "targetNum" (invalid-name)
C:  5, 4: Invalid variable name "targetDen" (invalid-name)
C:  8, 4: Invalid variable name "bestNum" (invalid-name)
C:  9, 4: Invalid variable name "bestDen" (invalid-name)
C: 13, 8: Invalid variable name "highNum" (invalid-name)
C: 14, 8: Invalid variable name "lowNum" (invalid-name)
C: 18,55: More than one statement on a single line (multiple-statements)
C: 20,12: Invalid variable name "leftSide" (invalid-name)
C: 21,12: Invalid variable name "rightSide" (invalid-name)
C: 23,16: Invalid variable name "bestNum" (invalid-name)
C: 23,25: Invalid variable name "bestDen" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge072/challenge072.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge073/challenge073.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "shareDivisors" (invalid-name)
C:  8, 0: Invalid argument name "n1" (invalid-name)
C:  8, 0: Invalid argument name "n2" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "d" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "upperNum" (invalid-name)
C: 19, 4: Invalid variable name "upperDen" (invalid-name)
C: 20, 4: Invalid variable name "lowerNum" (invalid-name)
C: 21, 4: Invalid variable name "lowerDen" (invalid-name)
C: 25, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 26, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 28, 8: Invalid variable name "upperLimit" (invalid-name)
C: 29, 8: Invalid variable name "upperLimit" (invalid-name)
C: 31, 8: Invalid variable name "rangeLimits" (invalid-name)
W: 31, 8: Unused variable 'rangeLimits' (unused-variable)
C: 39, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:31:9: F841 local variable 'rangeLimits' is assigned to but never used

_________________ [pylint] pemjh/challenge074/challenge074.py _________________
C:  2, 0: Line too long (109/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "factSum" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "chainSize" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "w" (invalid-name)
C:  8, 4: Invalid variable name "firstW" (invalid-name)
C:  9, 4: Invalid variable name "routeLen" (invalid-name)
C: 17,12: Invalid variable name "routeLen" (invalid-name)
C: 19,12: Invalid variable name "w" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 27, 4: Unused variable 'target' (unused-variable)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
D:\Development\pemjh\pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:27:5: F841 local variable 'target' is assigned to but never used

_________________ [pylint] pemjh/challenge075/challenge075.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "l" (invalid-name)
C:  8,15: Invalid variable name "a" (invalid-name)
C:  8,18: Invalid variable name "b" (invalid-name)
C:  8,21: Invalid variable name "c" (invalid-name)
C: 21, 4: Invalid variable name "l" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge076/challenge076.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numBreakDowns" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  9, 8: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nBreakDowns" (invalid-name)
C: 12,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 14,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge077/challenge077.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "pc" (invalid-name)
C: 17,12: Invalid variable name "a" (invalid-name)
C: 18,12: Invalid variable name "b" (invalid-name)
C: 21,16: Invalid variable name "abSums" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)

_________________ [pylint] pemjh/challenge078/challenge078.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
W:  6, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W:  7, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W: 15, 0: Found indentation with tabs instead of spaces (mixed-indentation)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "n" (invalid-name)
C:  3, 4: Invalid variable name "p" (invalid-name)
C:  6, 7: Invalid variable name "s" (invalid-name)
C: 10,16: Invalid variable name "s" (invalid-name)
C: 13,16: Invalid variable name "s" (invalid-name)
C: 17, 8: Invalid variable name "m" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge079/challenge079.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
W:  2, 0: Unused import string (unused-import)
W: 14, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge079\challenge079.py:2:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge079\challenge079.py:14:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge080/challenge080.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "buildRoot" (invalid-name)
C:  3, 0: Invalid argument name "sq" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W: 14, 4: Redefining name 'answer' from outer scope (line 36) (redefined-outer-name)
W: 18, 8: Redefining built-in 'next' (redefined-builtin)
C:  5, 4: Invalid function name "getNextNum" (invalid-name)
C:  5, 4: Missing function docstring (missing-docstring)
W:  5,19: Unused argument 'target' (unused-argument)
C: 13, 4: Invalid variable name "prevNum" (invalid-name)
C: 24, 8: Invalid variable name "prevNum" (invalid-name)
W: 16, 8: Unused variable 'i' (unused-variable)
C: 28, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge081/challenge081.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "addRows" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "r1" (invalid-name)
C:  7, 8: Invalid variable name "r2" (invalid-name)
C: 10,12: Invalid variable name "i1" (invalid-name)
C: 11,12: Invalid variable name "i2" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 21,63: Invalid variable name "f" (invalid-name)
C: 22, 8: Invalid variable name "tr" (invalid-name)
C: 26,12: Invalid variable name "n" (invalid-name)
C: 26,15: Invalid variable name "l" (invalid-name)
W: 28,26: Using possibly undefined loop variable 'i' (undefined-loop-variable)
C: 39, 4: Invalid variable name "tr" (invalid-name)
C: 43, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge082/challenge082.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "combineColumns" (invalid-name)
C:  5, 0: Invalid argument name "c1" (invalid-name)
C:  5, 0: Invalid argument name "c2" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "downRow" (invalid-name)
C: 11, 8: Invalid variable name "v1" (invalid-name)
C: 11,12: Invalid variable name "v2" (invalid-name)
C: 23, 4: Invalid variable name "newRow" (invalid-name)
C: 26, 8: Invalid variable name "v1" (invalid-name)
C: 26,12: Invalid variable name "v2" (invalid-name)
C: 39, 0: Missing function docstring (missing-docstring)
C: 42,23: Invalid variable name "f" (invalid-name)
W: 44,16: Used builtin function 'map' (bad-builtin)
W: 48,26: Lambda may not be necessary (unnecessary-lambda)
C: 50, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused izip imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge082\challenge082.py:3:1: F401 'izip' imported but unused
D:\Development\pemjh\pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge083/challenge083.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getGrid" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6,63: Invalid variable name "f" (invalid-name)
C:  9,12: Invalid variable name "nextLine" (invalid-name)
C: 16, 0: Invalid function name "compareToProcess" (invalid-name)
C: 16, 0: Invalid argument name "m" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 27, 0: Missing function docstring (missing-docstring)
W: 35,11: Used builtin function 'map' (bad-builtin)
W: 35,11: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 35,27: Used builtin function 'map' (bad-builtin)
W: 35,27: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C: 38, 4: Invalid variable name "toProcess" (invalid-name)
C: 45, 8: Invalid variable name "x" (invalid-name)
C: 45,11: Invalid variable name "y" (invalid-name)
C: 55,12: Invalid variable name "nx" (invalid-name)
C: 55,16: Invalid variable name "ny" (invalid-name)
C: 56,12: Invalid variable name "newSquare" (invalid-name)
C: 59,12: Invalid variable name "newLength" (invalid-name)
W: 40, 4: Unused variable 'processed' (unused-variable)
C: 77, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge083\challenge083.py:40:5: F841 local variable 'processed' is assigned to but never used
D:\Development\pemjh\pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'

_________________ [pylint] pemjh/challenge084/challenge084.py _________________
C:  8, 0: No space allowed around keyword argument assignment
def chanceCardMove(current, prev = [0]):
                                 ^ (bad-whitespace)
C: 52, 0: No space allowed around keyword argument assignment
def communityChestCardMove(current, prev = [0]):
                                         ^ (bad-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C: 77, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:100, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "rollDice" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  8, 0: Dangerous default value [] as argument (dangerous-default-value)
C:  8, 0: Invalid function name "chanceCardMove" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
R:  8, 0: Too many return statements (13/6) (too-many-return-statements)
R:  8, 0: Too many branches (14/12) (too-many-branches)
W: 52, 0: Dangerous default value [] as argument (dangerous-default-value)
C: 52, 0: Invalid function name "communityChestCardMove" (invalid-name)
C: 52, 0: Missing function docstring (missing-docstring)
C: 68, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "doubleCount" (invalid-name)
C: 85,12: Invalid variable name "doubleCount" (invalid-name)
C: 87,12: Invalid variable name "doubleCount" (invalid-name)
C: 94,12: Invalid variable name "doubleCount" (invalid-name)
C:111, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace

_________________ [pylint] pemjh/challenge085/challenge085.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numRects" (invalid-name)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Invalid argument name "w" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "rh" (invalid-name)
C:  5,12: Invalid variable name "rw" (invalid-name)
C:  6,12: Invalid variable name "numAcross" (invalid-name)
C:  7,12: Invalid variable name "numDown" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 32,16: Invalid variable name "areaRectangles" (invalid-name)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge086/challenge086.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def isInt(a, msq, sqLib, found = list()):
                               ^ (bad-whitespace)
C:  2, 0: Unnecessary parens after 'return' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value list() (__builtin__.list) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "isInt" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "sqLib" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  1,25: Unused argument 'found' (unused-argument)
C:  4, 0: Invalid function name "getNumPairs" (invalid-name)
C:  4, 0: Invalid argument name "pairSum" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nPairs" (invalid-name)
C:  8, 4: Invalid variable name "a" (invalid-name)
C:  9, 4: Invalid variable name "b" (invalid-name)
C: 11, 8: Invalid variable name "a" (invalid-name)
C: 12, 8: Invalid variable name "b" (invalid-name)
C: 16,12: Invalid variable name "nPairs" (invalid-name)
C: 19, 0: Invalid function name "getStepSize" (invalid-name)
C: 19, 0: Invalid argument name "m" (invalid-name)
C: 19, 0: Invalid argument name "sqLib" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "nStep" (invalid-name)
W: 25, 4: Unreachable code (unreachable)
C: 27, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "sqLimit" (invalid-name)
C: 33, 4: Invalid variable name "m" (invalid-name)
C: 36, 8: Invalid variable name "m" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge087/challenge087.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sqLimit" (invalid-name)
C: 13, 4: Invalid variable name "sqPrimes" (invalid-name)
C: 16, 4: Invalid variable name "cuLimit" (invalid-name)
C: 17, 4: Invalid variable name "cuPrimes" (invalid-name)
C: 20, 4: Invalid variable name "foLimit" (invalid-name)
C: 21, 4: Invalid variable name "foPrimes" (invalid-name)
C: 23, 4: Invalid variable name "nAnswers" (invalid-name)
C: 24, 8: Invalid variable name "s" (invalid-name)
C: 25,12: Invalid variable name "c" (invalid-name)
C: 26,12: Invalid variable name "sc" (invalid-name)
C: 29,16: Invalid variable name "f" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge087\challenge087.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge088/challenge088.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def findPossibleProducts(limit, known = dict()):
                                      ^ (bad-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "findPossibleProducts" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12,20: Invalid variable name "s" (invalid-name)
C: 12,23: Invalid variable name "d" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 25, 8: Invalid variable name "pr" (invalid-name)
C: 25,12: Invalid variable name "s" (invalid-name)
C: 25,15: Invalid variable name "d" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ceil imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge088\challenge088.py:1:1: F401 'ceil' imported but unused
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace

_________________ [pylint] pemjh/challenge089/challenge089.py _________________
C: 56, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C: 17, 0: Invalid function name "convertChar" (invalid-name)
C: 17, 0: Invalid argument name "c" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
R: 17, 0: Too many return statements (7/6) (too-many-return-statements)
C: 33, 0: Invalid function name "decypherNumeral" (invalid-name)
C: 33, 0: Invalid argument name "s" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "currentTotal" (invalid-name)
C: 38, 8: Invalid variable name "v" (invalid-name)
C: 41,12: Invalid variable name "currentTotal" (invalid-name)
C: 43,12: Invalid variable name "currentTotal" (invalid-name)
C: 46,12: Invalid variable name "currentTotal" (invalid-name)
C: 53, 0: Invalid function name "getNumeral" (invalid-name)
C: 53, 0: Invalid argument name "n" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 61,13: Invalid variable name "c" (invalid-name)
C: 62, 8: Invalid variable name "nDiv" (invalid-name)
C: 67, 0: Invalid function name "getRomanNumeralSaving" (invalid-name)
C: 67, 0: Invalid argument name "s" (invalid-name)
C: 67, 0: Missing function docstring (missing-docstring)
C: 69, 4: Invalid variable name "preLength" (invalid-name)
C: 75, 4: Invalid variable name "newNumeral" (invalid-name)
C: 76, 4: Invalid variable name "newLength" (invalid-name)
C: 81, 0: Missing function docstring (missing-docstring)
C: 83,62: Invalid variable name "f" (invalid-name)
C: 87, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
D:\Development\pemjh\pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge090/challenge090.py _________________
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 78, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "get6Combs" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "c6" (invalid-name)
C: 10, 8: Invalid variable name "i6" (invalid-name)
C: 15, 8: Invalid variable name "i6" (invalid-name)
C: 20, 0: Invalid function name "fillRemaining" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid function name "validAddition" (invalid-name)
C: 29, 0: Invalid argument name "newFace" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 35, 0: Invalid function name "amendCubesForSquare" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "newCube1" (invalid-name)
C: 56, 8: Invalid variable name "newCube0" (invalid-name)
C: 62, 4: Invalid variable name "newCube0" (invalid-name)
C: 63, 4: Invalid variable name "newCube1" (invalid-name)
C: 71, 0: Invalid function name "buildCubes" (invalid-name)
C: 71, 0: Invalid argument name "squaresLeft" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nextSquare" (invalid-name)
C: 77, 4: Invalid variable name "suitableCubes" (invalid-name)
C:109,16: Invalid variable name "c0" (invalid-name)
C:110,20: Invalid variable name "c1" (invalid-name)
R: 71, 0: Too many branches (13/12) (too-many-branches)
C:116, 0: Missing function docstring (missing-docstring)
C:117, 4: Invalid variable name "squareNumbers" (invalid-name)
C:119, 4: Invalid variable name "possibleNumbers" (invalid-name)
C:125, 8: Invalid variable name "c" (invalid-name)
W:119, 4: Unused variable 'possibleNumbers' (unused-variable)
W:125, 8: Unused variable 'c' (unused-variable)
C:129, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:119:5: F841 local variable 'possibleNumbers' is assigned to but never used

_________________ [pylint] pemjh/challenge091/challenge091.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "bruteForce" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTriangles" (invalid-name)
C:  5, 8: Invalid variable name "x1" (invalid-name)
C:  6,12: Invalid variable name "y1" (invalid-name)
C:  9,16: Invalid variable name "nTriangles" (invalid-name)
C: 12,16: Invalid variable name "nTriangles" (invalid-name)
C: 15,20: Invalid variable name "x2" (invalid-name)
C: 16,24: Invalid variable name "y2" (invalid-name)
C: 29,32: Invalid variable name "nTriangles" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "gridSize" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge092/challenge092.py _________________
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 87, 0: Trailing whitespace (trailing-whitespace)
C:112, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Invalid function name "getDigits" (invalid-name)
C:  6, 0: Invalid argument name "n" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "workingN" (invalid-name)
C: 11, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 20, 8: Invalid variable name "workingN" (invalid-name)
C: 29,20: Invalid variable name "d" (invalid-name)
C: 31,16: Invalid variable name "workingN" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "n" (invalid-name)
C: 41, 8: Invalid variable name "workingN" (invalid-name)
C: 45,12: Invalid variable name "workingN" (invalid-name)
C: 46,19: Invalid variable name "c" (invalid-name)
C: 52,12: Invalid variable name "workingN" (invalid-name)
W: 42, 8: Unused variable 'route' (unused-variable)
C: 58, 0: Invalid function name "buildNumber" (invalid-name)
C: 58, 0: Missing function docstring (missing-docstring)
C: 61, 0: Missing function docstring (missing-docstring)
C: 73, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "prevI" (invalid-name)
C: 75, 4: Invalid variable name "nI" (invalid-name)
C: 80,12: Invalid variable name "nI" (invalid-name)
C: 83,12: Invalid variable name "prevI" (invalid-name)
C: 84,12: Invalid variable name "nI" (invalid-name)
C: 90, 0: Invalid function name "squareVal" (invalid-name)
C: 90, 0: Missing function docstring (missing-docstring)
C: 91, 4: Invalid variable name "n" (invalid-name)
C: 96, 8: Invalid variable name "n" (invalid-name)
C:100, 0: Missing function docstring (missing-docstring)
C:101, 4: Invalid variable name "n" (invalid-name)
C:108,12: Invalid variable name "n" (invalid-name)
C:110, 0: Missing function docstring (missing-docstring)
C:111, 4: Invalid variable name "nDigits" (invalid-name)
C:120, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:42:9: F841 local variable 'route' is assigned to but never used
D:\Development\pemjh\pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:123:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge093/challenge093.py _________________
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 96, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nLeft" (invalid-name)
C: 12, 0: Invalid argument name "a" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "op" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid argument name "l" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "v" (invalid-name)
C: 34, 0: Invalid function name "equatedNumbers" (invalid-name)
C: 34, 0: Invalid argument name "a" (invalid-name)
C: 34, 0: Invalid argument name "b" (invalid-name)
C: 34, 0: Invalid argument name "c" (invalid-name)
C: 34, 0: Invalid argument name "d" (invalid-name)
C: 34, 0: Missing function docstring (missing-docstring)
W: 40, 8: No exception type(s) specified (bare-except)
C: 39,13: More than one statement on a single line (multiple-statements)
C: 40,16: More than one statement on a single line (multiple-statements)
W: 44, 8: No exception type(s) specified (bare-except)
C: 43,13: More than one statement on a single line (multiple-statements)
C: 44,16: More than one statement on a single line (multiple-statements)
W: 48, 8: No exception type(s) specified (bare-except)
C: 47,13: More than one statement on a single line (multiple-statements)
C: 48,16: More than one statement on a single line (multiple-statements)
W: 52, 8: No exception type(s) specified (bare-except)
C: 51,13: More than one statement on a single line (multiple-statements)
C: 52,16: More than one statement on a single line (multiple-statements)
W: 56, 8: No exception type(s) specified (bare-except)
C: 55,13: More than one statement on a single line (multiple-statements)
C: 56,16: More than one statement on a single line (multiple-statements)
C: 60, 0: Missing function docstring (missing-docstring)
C: 68, 8: Invalid variable name "a" (invalid-name)
C: 69,12: Invalid variable name "b" (invalid-name)
C: 70,16: Invalid variable name "c" (invalid-name)
C: 71,20: Invalid variable name "d" (invalid-name)
C: 77,28: Invalid variable name "n" (invalid-name)
W: 90,19: Using possibly undefined loop variable 'd' (undefined-loop-variable)
W: 92,15: Using possibly undefined loop variable 'c' (undefined-loop-variable)
W: 94,11: Using possibly undefined loop variable 'b' (undefined-loop-variable)
C: 99, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge094/challenge094.py _________________
C: 11, 0: Exactly one space required after comma
    prev_2 = (4,  0)
               ^ (bad-whitespace)
C: 12, 0: Exactly one space required after comma
    prev_1 = (15,  1)
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "n" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
W: 38,12: Redefining built-in 'long' (redefined-builtin)
C: 31, 8: Invalid variable name "c" (invalid-name)
C: 33, 8: Invalid variable name "rt" (invalid-name)
C: 50, 0: Invalid constant name "desc" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge095/challenge095.py _________________
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 47, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid function name "chainLengths" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "x" (invalid-name)
C: 38,12: Invalid variable name "lChain" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge096/challenge096.py _________________
C:104, 0: Trailing whitespace (trailing-whitespace)
C:120, 0: Line too long (150/100) (line-too-long)
C:228, 0: Trailing whitespace (trailing-whitespace)
C:240, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  6, 0: Invalid function name "sortSquareLengths" (invalid-name)
C:  6, 0: Invalid argument name "a" (invalid-name)
C:  6, 0: Invalid argument name "b" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "la" (invalid-name)
C:  8, 4: Invalid variable name "lb" (invalid-name)
C: 16, 0: Missing class docstring (missing-docstring)
C: 16, 0: Old-style class defined. (old-style-class)
C: 20, 4: Invalid argument name "s" (invalid-name)
W: 23,50: Unused variable 'i' (unused-variable)
C: 36, 4: Invalid method name "__loadData" (invalid-name)
C: 36, 4: Invalid argument name "s" (invalid-name)
C: 36, 4: Missing method docstring (missing-docstring)
C: 40,12: Invalid variable name "r" (invalid-name)
C: 42,16: Invalid variable name "c" (invalid-name)
C: 46, 4: Invalid method name "__getBox" (invalid-name)
C: 46, 4: Invalid argument name "r" (invalid-name)
C: 46, 4: Invalid argument name "c" (invalid-name)
C: 46, 4: Missing method docstring (missing-docstring)
C: 47, 8: Invalid function name "getStartIndex" (invalid-name)
C: 47, 8: Missing function docstring (missing-docstring)
C: 55, 8: Invalid variable name "rowStart" (invalid-name)
C: 57,12: Invalid variable name "columnStart" (invalid-name)
C: 61, 4: Invalid method name "__removeValueFromList" (invalid-name)
C: 61, 4: Invalid argument name "l" (invalid-name)
C: 61, 4: Missing method docstring (missing-docstring)
C: 62, 8: Invalid variable name "nRemoved" (invalid-name)
C: 64,12: Invalid variable name "sq" (invalid-name)
C: 66,16: Invalid variable name "nRemoved" (invalid-name)
R: 61, 4: Method could be a function (no-self-use)
C: 71, 4: Invalid method name "__setValue" (invalid-name)
C: 71, 4: Invalid argument name "r" (invalid-name)
C: 71, 4: Invalid argument name "c" (invalid-name)
C: 71, 4: Missing method docstring (missing-docstring)
C: 85, 8: Invalid variable name "sq" (invalid-name)
C: 96, 4: Invalid method name "__getAllBlocks" (invalid-name)
C: 96, 4: Missing method docstring (missing-docstring)
C:100,12: Invalid variable name "r" (invalid-name)
C:101,16: Invalid variable name "c" (invalid-name)
C:107, 4: Invalid method name "__processCompletedSquares" (invalid-name)
C:107, 4: Missing method docstring (missing-docstring)
C:110,12: Invalid variable name "r" (invalid-name)
C:111,16: Invalid variable name "sq" (invalid-name)
C:117, 4: Invalid method name "__processGroups" (invalid-name)
C:117, 4: Missing method docstring (missing-docstring)
C:124,16: Invalid variable name "sq" (invalid-name)
C:131,24: Invalid variable name "lSq" (invalid-name)
C:137,28: Invalid variable name "nRemoved" (invalid-name)
C:148, 4: Invalid method name "__getLocation" (invalid-name)
C:148, 4: Invalid argument name "sq" (invalid-name)
C:148, 4: Missing method docstring (missing-docstring)
C:150,12: Invalid variable name "r" (invalid-name)
C:151,16: Invalid variable name "c" (invalid-name)
C:157, 4: Invalid method name "__processOnlyInOneSquare" (invalid-name)
C:157, 4: Missing method docstring (missing-docstring)
C:176, 4: Missing method docstring (missing-docstring)
C:178,12: Invalid variable name "sRow" (invalid-name)
C:178,18: Invalid variable name "tRow" (invalid-name)
W:178,30: Access to a protected member __rows of a client class (protected-access)
C:179,16: Invalid variable name "sSquare" (invalid-name)
C:179,25: Invalid variable name "tSquare" (invalid-name)
C:183, 4: Missing method docstring (missing-docstring)
C:184, 8: Invalid variable name "progressMade" (invalid-name)
C:187,12: Invalid variable name "progressMade" (invalid-name)
C:189,12: Invalid variable name "progressMade" (invalid-name)
C:191,12: Invalid variable name "progressMade" (invalid-name)
C:195,12: Invalid variable name "unsolvedSquares" (invalid-name)
C:196,16: Invalid variable name "r" (invalid-name)
C:197,20: Invalid variable name "c" (invalid-name)
C:205,16: Invalid variable name "sq" (invalid-name)
W:211,20: Access to a protected member __setValue of a client class (protected-access)
W:214,24: Access to a protected member __solve of a client class (protected-access)
C:223, 4: Missing method docstring (missing-docstring)
C:224,12: Invalid variable name "r" (invalid-name)
C:225,16: Invalid variable name "sq" (invalid-name)
C:230, 4: Missing method docstring (missing-docstring)
C:231,12: Invalid variable name "r" (invalid-name)
C:232,16: Invalid variable name "sq" (invalid-name)
W:244, 8: Redefining built-in 'repr' (redefined-builtin)
C:245,12: Invalid variable name "r" (invalid-name)
C:247,16: Invalid variable name "sq" (invalid-name)
C:249,16: Invalid variable name "f1" (invalid-name)
C:250,16: Invalid variable name "f2" (invalid-name)
C:256, 0: Missing function docstring (missing-docstring)
W:267,12: Redefining built-in 'input' (redefined-builtin)
C:257,63: Invalid variable name "f" (invalid-name)
C:260, 8: Invalid variable name "nBroken" (invalid-name)
C:273,16: Invalid variable name "nBroken" (invalid-name)
W:260, 8: Unused variable 'nBroken' (unused-variable)
W:263,12: Unused variable 'i' (unused-variable)
W:267,46: Unused variable 'j' (unused-variable)
C:279, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge096\challenge096.py:3:1: F401 'sys' imported but unused
D:\Development\pemjh\pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge097/challenge097.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid constant name "answer" (invalid-name)
W:  7, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge097\challenge097.py:7:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge098/challenge098.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getMap" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'map' (redefined-builtin)
C:  6, 8: Invalid variable name "w" (invalid-name)
C:  6,11: Invalid variable name "s" (invalid-name)
C: 15, 0: Invalid function name "uniqueRight" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
W: 15,16: Redefining built-in 'map' (redefined-builtin)
C: 25, 0: Invalid function name "mapWord" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 25,18: Redefining built-in 'map' (redefined-builtin)
C: 27, 8: Invalid variable name "c" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
W: 81,16: Redefining built-in 'map' (redefined-builtin)
R: 32, 0: Too many local variables (19/15) (too-many-locals)
C: 35, 4: Invalid variable name "groupedWords" (invalid-name)
C: 37,62: Invalid variable name "f" (invalid-name)
C: 40,16: Invalid variable name "orderedWord" (invalid-name)
C: 46, 4: Invalid variable name "groupedWords" (invalid-name)
C: 70, 8: Invalid variable name "nWords" (invalid-name)
C: 75,12: Invalid variable name "lWord" (invalid-name)
C: 78,16: Invalid variable name "potentialSquare" (invalid-name)
C: 87,24: Invalid variable name "word2Square" (invalid-name)
C: 95, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)

_________________ [pylint] pemjh/challenge099/challenge099.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5,65: Invalid variable name "f" (invalid-name)
C:  6, 8: Invalid variable name "highestIndex" (invalid-name)
C:  7, 8: Invalid variable name "highestNumber" (invalid-name)
C:  8, 8: Invalid variable name "highestLine" (invalid-name)
C:  9,12: Invalid variable name "nL" (invalid-name)
C:  9,16: Invalid variable name "l" (invalid-name)
C: 10,12: Invalid variable name "n" (invalid-name)
C: 11,12: Invalid variable name "rootedPower" (invalid-name)
C: 13,16: Invalid variable name "highestNumber" (invalid-name)
C: 13,31: Invalid variable name "highestIndex" (invalid-name)
C: 13,45: Invalid variable name "highestLine" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
W: 19, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge099\challenge099.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge100/challenge100.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "b" (invalid-name)
C:  3, 4: Invalid variable name "n" (invalid-name)
C:  5, 8: Invalid variable name "b" (invalid-name)
C:  5,11: Invalid variable name "n" (invalid-name)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge101/challenge101.py _________________
C:  5, 0: Line too long (123/100) (line-too-long)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "highestPower" (invalid-name)
C: 14, 8: Invalid variable name "workedSequence" (invalid-name)
C: 16,12: Invalid variable name "x" (invalid-name)
C: 17,12: Invalid variable name "y" (invalid-name)
C: 28,16: Invalid variable name "y" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
D:\Development\pemjh\pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge102/challenge102.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "enclosesOrigin" (invalid-name)
C:  4, 0: Invalid argument name "x1" (invalid-name)
C:  4, 0: Invalid argument name "y1" (invalid-name)
C:  4, 0: Invalid argument name "x2" (invalid-name)
C:  4, 0: Invalid argument name "y2" (invalid-name)
C:  4, 0: Invalid argument name "x3" (invalid-name)
C:  4, 0: Invalid argument name "y3" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
R:  4, 0: Too many arguments (6/5) (too-many-arguments)
C: 17,12: Invalid variable name "i1" (invalid-name)
C: 18,12: Invalid variable name "i2" (invalid-name)
C: 21,12: Invalid variable name "i1" (invalid-name)
C: 22,12: Invalid variable name "i2" (invalid-name)
C: 25,12: Invalid variable name "i1" (invalid-name)
C: 26,12: Invalid variable name "i2" (invalid-name)
C: 33, 0: Invalid function name "getYIntercept" (invalid-name)
C: 33, 0: Invalid argument name "x1" (invalid-name)
C: 33, 0: Invalid argument name "y1" (invalid-name)
C: 33, 0: Invalid argument name "x2" (invalid-name)
C: 33, 0: Invalid argument name "y2" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "m" (invalid-name)
C: 38, 4: Invalid variable name "c" (invalid-name)
C: 43, 0: Missing function docstring (missing-docstring)
C: 46, 4: Invalid variable name "nEnclosing" (invalid-name)
C: 47,23: Invalid variable name "f" (invalid-name)
C: 48,12: Invalid variable name "l" (invalid-name)
C: 49,12: Invalid variable name "ax" (invalid-name)
C: 49,16: Invalid variable name "ay" (invalid-name)
C: 49,20: Invalid variable name "bx" (invalid-name)
C: 49,24: Invalid variable name "by" (invalid-name)
C: 49,28: Invalid variable name "cx" (invalid-name)
C: 49,32: Invalid variable name "cy" (invalid-name)
C: 51,16: Invalid variable name "nEnclosing" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge103/challenge103.py _________________
C: 41, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "subSets" (invalid-name)
C:  1, 0: Invalid argument name "l" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "setA" (invalid-name)
C:  5, 8: Invalid variable name "setB" (invalid-name)
C: 14, 0: Invalid argument name "l" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "B" (invalid-name)
C: 16,11: Invalid variable name "CPart" (invalid-name)
C: 19,16: Invalid variable name "C" (invalid-name)
C: 19,19: Invalid variable name "notUsed" (invalid-name)
C: 23,24: Invalid variable name "wB" (invalid-name)
C: 23,28: Invalid variable name "wC" (invalid-name)
C: 25,24: Invalid variable name "wB" (invalid-name)
C: 25,28: Invalid variable name "wC" (invalid-name)
W: 19,19: Unused variable 'notUsed' (unused-variable)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "midPoint" (invalid-name)
C: 48, 4: Invalid variable name "sumAns" (invalid-name)
C: 49, 8: Invalid variable name "b" (invalid-name)
C: 50, 8: Invalid variable name "newSet" (invalid-name)
C: 54,16: Invalid variable name "sumAns" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge104/challenge104.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "myEnumerate" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Invalid function name "fiboTrunc" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "aStart" (invalid-name)
C: 10,12: Invalid variable name "bStart" (invalid-name)
C: 11, 4: Invalid variable name "aEnd" (invalid-name)
C: 11,10: Invalid variable name "bEnd" (invalid-name)
C: 13, 4: Invalid variable name "endTrunc" (invalid-name)
C: 14, 4: Invalid variable name "startTrunc" (invalid-name)
C: 18, 8: Invalid variable name "aStart" (invalid-name)
C: 18,16: Invalid variable name "bStart" (invalid-name)
C: 19, 8: Invalid variable name "aEnd" (invalid-name)
C: 19,14: Invalid variable name "bEnd" (invalid-name)
C: 22, 8: Invalid variable name "aEnd" (invalid-name)
C: 23, 8: Invalid variable name "bEnd" (invalid-name)
C: 26,12: Invalid variable name "aStart" (invalid-name)
C: 27,12: Invalid variable name "bStart" (invalid-name)
C: 29, 8: Invalid variable name "aStartRet" (invalid-name)
C: 31,12: Invalid variable name "aStartRet" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "lowerLimit" (invalid-name)
C: 38,11: Invalid variable name "f" (invalid-name)
C: 39, 8: Invalid variable name "s" (invalid-name)
C: 40, 8: Invalid variable name "e" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused fibo imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge104\challenge104.py:1:1: F401 'fibo' imported but unused
D:\Development\pemjh\pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge105/challenge105.py _________________
C: 61, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "sizedSubsets" (invalid-name)
C:  4, 0: Invalid argument name "l" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "sizeL" (invalid-name)
C: 21, 0: Invalid function name "checkForDuplicateSetSums" (invalid-name)
C: 21, 0: Invalid argument name "l" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 22, 8: Invalid variable name "setSize" (invalid-name)
C: 23, 8: Invalid variable name "sumSub" (invalid-name)
C: 30, 0: Invalid argument name "l" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "nItems" (invalid-name)
C: 49, 0: Missing function docstring (missing-docstring)
C: 51,61: Invalid variable name "f" (invalid-name)
C: 60, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge106/challenge106.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "incrementTrilist" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "rightIndex" (invalid-name)
C: 16, 0: Invalid function name "allSubsets" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17, 4: Invalid variable name "triList" (invalid-name)
C: 28, 0: Invalid argument name "l" (invalid-name)
C: 28, 0: Missing function docstring (missing-docstring)
C: 48, 0: Invalid function name "getRequiredCompares" (invalid-name)
C: 48, 0: Missing function docstring (missing-docstring)
C: 49, 4: Invalid variable name "allS" (invalid-name)
C: 52, 4: Invalid variable name "workingS" (invalid-name)
C: 55, 4: Invalid variable name "workingS" (invalid-name)
C: 58, 4: Invalid variable name "workingS" (invalid-name)
C: 62, 0: Missing function docstring (missing-docstring)
C: 65, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge107/challenge107.py _________________
C: 22, 0: Line too long (102/100) (line-too-long)
C: 25, 0: Line too long (139/100) (line-too-long)
C: 25, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "skimNetwork" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "connectedRows" (invalid-name)
C:  7, 4: Invalid variable name "availableConnections" (invalid-name)
C: 22, 8: Invalid variable name "availableConnections" (invalid-name)
C: 30, 4: Invalid variable name "newGrid" (invalid-name)
W: 30,35: Unused variable 'row' (unused-variable)
C: 36, 0: Invalid function name "scoreGrid" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "r" (invalid-name)
C: 41,12: Invalid variable name "v" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 50,64: Invalid variable name "f" (invalid-name)
C: 56, 4: Invalid variable name "originalScore" (invalid-name)
C: 59, 4: Invalid variable name "newGrid" (invalid-name)
C: 62, 4: Invalid variable name "newScore" (invalid-name)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)

_________________ [pylint] pemjh/challenge108/challenge108.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge109/challenge109.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def getNonDoubleOuts(n, darts, nums, known = dict()):
                                           ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "getNonDoubleOuts" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nCount" (invalid-name)
C:  7, 8: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "nCount" (invalid-name)
C: 21, 0: Invalid function name "getDoubleOuts" (invalid-name)
C: 21, 0: Invalid argument name "n" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "nCount" (invalid-name)
C: 24,14: Invalid variable name "d" (invalid-name)
C: 26,12: Invalid variable name "nCount" (invalid-name)
C: 28,12: Invalid variable name "nCount" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "nCount" (invalid-name)
C: 43, 8: Invalid variable name "nCount" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge110/challenge110.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge111/challenge111.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def isPrime(p, pc = PrimeChecker()):
                  ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "isPrime" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "pc" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid function name "buildNums" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17,16: Invalid variable name "b" (invalid-name)
C: 24,16: Invalid variable name "b" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "M" (invalid-name)
C: 31, 4: Invalid variable name "N" (invalid-name)
C: 32, 4: Invalid variable name "S" (invalid-name)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36, 8: Invalid variable name "s" (invalid-name)
C: 38,12: Invalid variable name "m" (invalid-name)
C: 40,20: Invalid variable name "b" (invalid-name)
C: 44,28: Invalid variable name "n" (invalid-name)
C: 45,28: Invalid variable name "s" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused roughPrimes imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge111\challenge111.py:1:1: F401 'roughPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge112/challenge112.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isBouncy" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  6,11: Invalid variable name "nextM" (invalid-name)
C:  9,12: Invalid variable name "nextMovement" (invalid-name)
C: 11,12: Invalid variable name "nextMovement" (invalid-name)
C: 13,12: Invalid variable name "nextMovement" (invalid-name)
C: 15, 8: Invalid variable name "m" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "currentBouncy" (invalid-name)
C: 32, 4: Invalid variable name "currentNumber" (invalid-name)
C: 36,12: Invalid variable name "currentBouncy" (invalid-name)
C: 39,54: More than one statement on a single line (multiple-statements)
C: 41, 8: Invalid variable name "currentNumber" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge113/challenge113.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 21, 8: Invalid variable name "d" (invalid-name)
C: 22, 8: Invalid variable name "p" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge114/challenge114.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 14,16: Invalid variable name "nVariations" (invalid-name)
C: 17, 8: Invalid variable name "nVariations" (invalid-name)
C: 20, 8: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 4: Invalid variable name "n" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge115/challenge115.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, minimum, tileSizes, known = dict()):
                                                    ^ (bad-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 15,12: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 21, 8: Invalid variable name "nVariations" (invalid-name)
C: 27, 0: Invalid function name "f" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "b" (invalid-name)
C: 38, 8: Invalid variable name "b" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge116/challenge116.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                        ^ (bad-whitespace)
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                                      ^ (bad-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSize" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  9,12: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 15, 8: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "n2" (invalid-name)
C: 26, 4: Invalid variable name "n3" (invalid-name)
C: 27, 4: Invalid variable name "n4" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge117/challenge117.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 10,16: Invalid variable name "nVariations" (invalid-name)
C: 13, 8: Invalid variable name "nVariations" (invalid-name)
C: 16, 8: Invalid variable name "nVariations" (invalid-name)
C: 22, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "n" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge118/challenge118.py _________________
C: 10, 0: No space allowed around keyword argument assignment
def build_sets(existing, left, lExist = 0):
                                      ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 0: Invalid argument name "lExist" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "lLeft" (invalid-name)
C: 16, 8: Invalid variable name "lNew" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
W: 37,12: Used builtin function 'map' (bad-builtin)
C: 45, 0: Missing function docstring (missing-docstring)
C: 49, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge119/challenge119.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "sumDigits" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "w" (invalid-name)
C:  5, 8: Invalid variable name "w" (invalid-name)
C:  5,11: Invalid variable name "m" (invalid-name)
C:  9, 0: Invalid function name "an" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 16,12: Invalid variable name "p" (invalid-name)
C: 18,12: Invalid variable name "s" (invalid-name)
W: 16,12: Unused variable 'p' (unused-variable)
C: 25, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge120/challenge120.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "highestMod" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge121/challenge121.py _________________
C: 21, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "winChance" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "lossesAllowed" (invalid-name)
C: 22, 8: Invalid variable name "lossesAllowed" (invalid-name)
C: 27, 8: Invalid variable name "wc" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge122/challenge122.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12,16: Invalid variable name "f" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge123/challenge123.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getRemainder" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 11, 8: Invalid variable name "r" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 17, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge124/challenge124.py _________________
C:  5, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] > b[1]))):
        ^   | (bad-continuation)
C: 12, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] < b[1]))):
        ^   | (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 8: Invalid variable name "p" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge125/challenge125.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "rtLimit" (invalid-name)
C:  8, 8: Invalid variable name "rtLimit" (invalid-name)
C:  9, 4: Invalid variable name "rtLimit" (invalid-name)
C: 13, 8: Invalid variable name "sq" (invalid-name)
C: 15,12: Invalid variable name "sq" (invalid-name)
C: 26, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge126/challenge126.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 16, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 20, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 24, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 29, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "surroundingCubes" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Invalid argument name "z" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "maximumResult" (invalid-name)
C: 10, 4: Invalid variable name "maximumDepth" (invalid-name)
C: 12, 8: Invalid variable name "maximumDepth" (invalid-name)
C: 15, 8: Invalid variable name "maximumA" (invalid-name)
C: 17,12: Invalid variable name "maximumA" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "maximumB" (invalid-name)
C: 21,16: Invalid variable name "maximumB" (invalid-name)
C: 22,16: Invalid variable name "b" (invalid-name)
C: 23,16: Invalid variable name "maximumC" (invalid-name)
C: 25,20: Invalid variable name "maximumC" (invalid-name)
C: 26,20: Invalid variable name "c" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)

_________________ [pylint] pemjh/challenge127/challenge127.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 20,12: Redefining built-in 'next' (redefined-builtin)
C: 19, 8: Invalid variable name "c" (invalid-name)
C: 21,12: Invalid variable name "a" (invalid-name)
C: 24,12: Invalid variable name "b" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','

_________________ [pylint] pemjh/challenge128/challenge128.py _________________
C: 23, 0: Line too long (103/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "nPrimes" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)

_________________ [pylint] pemjh/challenge129/challenge129.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "A" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "n" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16,12: Invalid variable name "an" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
F: 25, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge130/challenge130.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "A" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
F: 28, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge131/challenge131.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "p" (invalid-name)
C: 18, 8: Invalid variable name "lowerCube" (invalid-name)
C: 19, 8: Invalid variable name "upperCube" (invalid-name)
C: 25,16: Invalid variable name "lowerCube" (invalid-name)
C: 30,16: Invalid variable name "upperCube" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge132/challenge132.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "R" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 13,33: More than one statement on a single line (multiple-statements)
C: 17, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge133/challenge133.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)

_________________ [pylint] pemjh/challenge134/challenge134.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "jumpSize" (invalid-name)
C:  3, 0: Invalid argument name "t" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "cInd" (invalid-name)
C: 21, 4: Invalid variable name "tInd" (invalid-name)
C: 29, 0: Invalid function name "f" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "s" (invalid-name)
C: 33, 4: Invalid variable name "c" (invalid-name)
C: 35, 4: Invalid variable name "t" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 51, 8: Invalid variable name "r" (invalid-name)
C: 54, 4: Invalid variable name "p1" (invalid-name)
C: 55, 4: Invalid variable name "S" (invalid-name)
C: 56, 8: Invalid variable name "p2" (invalid-name)
C: 61, 8: Invalid variable name "n" (invalid-name)
C: 63, 8: Invalid variable name "S" (invalid-name)
C: 65, 8: Invalid variable name "p1" (invalid-name)
W: 51, 8: Unused variable 'r' (unused-variable)
C: 68, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge135/challenge135.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumTarget" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "x" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "n" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge136/challenge136.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getNumTarget" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "p" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge137/challenge137.py _________________
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  8, 0: No space allowed around keyword argument assignment
def a(n, known = {0: 0, 1: 2, 2: 15}):
               ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining name 'a' from outer scope (line 8) (redefined-outer-name)
C:  2, 4: Invalid variable name "a" (invalid-name)
C:  2, 7: Invalid variable name "b" (invalid-name)
C:  4, 8: Invalid variable name "x" (invalid-name)
C:  6, 8: Invalid variable name "a" (invalid-name)
C:  6,11: Invalid variable name "b" (invalid-name)
W:  4, 8: Unused variable 'x' (unused-variable)
W:  8, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  8, 0: Invalid function name "a" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 19, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge138/challenge138.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 15, 8: Redefining built-in 'next' (redefined-builtin)
C:  4, 4: Invalid variable name "b1" (invalid-name)
C:  5, 4: Invalid variable name "b2" (invalid-name)
C: 17, 8: Invalid variable name "v" (invalid-name)
C: 21,12: Invalid variable name "v" (invalid-name)
C: 27,23: More than one statement on a single line (multiple-statements)
W:  7, 8: Unused variable 'i' (unused-variable)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)

_________________ [pylint] pemjh/challenge139/challenge139.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge142/challenge142.py _________________
C: 32, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "perfectSquare" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "a" (invalid-name)
C:  4, 0: Invalid argument name "b" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)

_________________ [pylint] pemjh/challenge144/challenge144.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "solveQuadratic" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "sqPart" (invalid-name)
C:  7, 0: Invalid argument name "x" (invalid-name)
C:  7, 0: Invalid argument name "y" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "impGrad" (invalid-name)
C: 12, 4: Invalid variable name "impAngle" (invalid-name)
C: 15, 4: Invalid variable name "inAngle" (invalid-name)
C: 18, 4: Invalid variable name "diffAngle" (invalid-name)
C: 21, 4: Invalid variable name "newAngle" (invalid-name)
C: 24, 4: Invalid variable name "newGradient" (invalid-name)
C: 29, 0: Invalid function name "nextStep" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "m" (invalid-name)
C: 34, 4: Invalid variable name "c" (invalid-name)
C: 41, 4: Invalid variable name "x1" (invalid-name)
C: 41, 8: Invalid variable name "x2" (invalid-name)
C: 45, 8: Invalid variable name "xImpact" (invalid-name)
C: 47, 8: Invalid variable name "xImpact" (invalid-name)
C: 49, 4: Invalid variable name "yImpact" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 56, 0: Missing function docstring (missing-docstring)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge145/challenge145.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "d" (invalid-name)
C:  8, 4: Invalid variable name "sevenDigits" (invalid-name)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge146/challenge146.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def is_pseudo_prime(n, known = {1: True, 2: True}):
                             ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "ns" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent

_________________ [pylint] pemjh/challenge148/challenge148.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 31, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge149/challenge149.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid argument name "l" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 29, 0: Missing function docstring (missing-docstring)
W: 35,13: Used builtin function 'map' (bad-builtin)
W: 44,13: Used builtin function 'map' (bad-builtin)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge151/challenge151.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a5" (invalid-name)
C:  1, 0: Invalid argument name "a4" (invalid-name)
C:  1, 0: Invalid argument name "a3" (invalid-name)
C:  1, 0: Invalid argument name "a2" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge162/challenge162.py _________________
C:  2, 0: Line too long (103/100) (line-too-long)
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid constant name "answer" (invalid-name)
C:  8, 0: Invalid constant name "desc" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge164/challenge164.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(size, previousThree, useZero, known = dict()):
                                                  ^ (bad-whitespace)
C: 15, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "useZero" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nLosses" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge166/challenge166.py _________________
C: 60, 0: Line too long (102/100) (line-too-long)
C: 65, 0: Line too long (114/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sq" (invalid-name)
R:  1, 0: Too many branches (14/12) (too-many-branches)
C: 70, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)

_________________ [pylint] pemjh/challenge173/challenge173.py _________________
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numOfSquares" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nSquares" (invalid-name)
C:  3, 4: Invalid variable name "holeWidth" (invalid-name)
C:  6, 8: Invalid variable name "holeArea" (invalid-name)
C: 12, 8: Invalid variable name "surroundingWidth" (invalid-name)
C: 16,12: Invalid variable name "totalArea" (invalid-name)
C: 19,12: Invalid variable name "surroundingArea" (invalid-name)
C: 24,12: Invalid variable name "surroundingWidth" (invalid-name)
C: 25,12: Invalid variable name "nSquares" (invalid-name)
C: 27, 8: Invalid variable name "holeWidth" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge174/challenge174.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def getDivisors(n, known = dict()):
                         ^ (bad-whitespace)
C: 11, 0: No space allowed around keyword argument assignment
def getNumEvenDivisors(n, known = dict()):
                                ^ (bad-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "getDivisors" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "d" (invalid-name)
W: 11, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 11, 0: Invalid function name "getNumEvenDivisors" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 4: Invalid variable name "nDiv" (invalid-name)
C: 20,12: Invalid variable name "nDiv" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nSquares" (invalid-name)
C: 31, 4: Invalid variable name "nMatches" (invalid-name)
C: 32, 8: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "nMatches" (invalid-name)
W: 33,24: Used builtin function 'filter' (bad-builtin)
W: 33,24: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 33,46: Cell variable n defined in loop (cell-var-from-loop)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge179/challenge179.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nSame" (invalid-name)
C:  8,12: Invalid variable name "a" (invalid-name)
C: 13,12: Invalid variable name "nSame" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge183/challenge183.py _________________
C:  4, 0: No space allowed around keyword argument assignment
def pf(n, known = dict()):
                ^ (bad-whitespace)
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 12, 0: No space allowed around keyword argument assignment
def factPower(b, f, known = dict()):
                          ^ (bad-whitespace)
C: 30, 0: Line too long (106/100) (line-too-long)
C: 32, 0: Line too long (107/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  4, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  4, 0: Invalid function name "pf" (invalid-name)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W: 12, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 12, 0: Invalid function name "factPower" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "f" (invalid-name)
C: 20,11: Invalid variable name "m" (invalid-name)
C: 26, 0: Invalid argument name "n" (invalid-name)
C: 26, 0: Invalid argument name "d" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "dFacts" (invalid-name)
C: 31, 4: Invalid variable name "termDen" (invalid-name)
C: 32, 4: Invalid variable name "dFacts" (invalid-name)
C: 36, 0: Invalid function name "M" (invalid-name)
C: 36, 0: Invalid argument name "N" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 0: Invalid function name "SD" (invalid-name)
C: 40, 0: Missing function docstring (missing-docstring)
C: 42, 8: Invalid variable name "N" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 53, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge187/challenge187.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nPrimes" (invalid-name)
C:  7, 4: Invalid variable name "nTwos" (invalid-name)
C: 12,12: Invalid variable name "nTwos" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge188/challenge188.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge190/challenge190.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "P" (invalid-name)
C:  1, 0: Invalid argument name "m" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge191/challenge191.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(days, previousThree, latesLeft, known = dict()):
                                                    ^ (bad-whitespace)
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
                                                              ^ (bad-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Line too long (105/100) (line-too-long)
C: 67, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "latesLeft" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  7, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "numVariations" (invalid-name)
C: 25, 0: Invalid argument name "tilePatterns" (invalid-name)
C: 25, 0: Invalid argument name "losingPatterns" (invalid-name)
R: 25, 0: Too many local variables (16/15) (too-many-locals)
C: 29, 4: Invalid variable name "nVariations" (invalid-name)
C: 35,16: Invalid variable name "c" (invalid-name)
C: 36,16: Invalid variable name "nVariations" (invalid-name)
C: 39,16: Invalid variable name "tilePattern" (invalid-name)
C: 41,16: Invalid variable name "lTilePattern" (invalid-name)
C: 45,24: Invalid variable name "nVariations" (invalid-name)
C: 50,16: Invalid variable name "nLeft" (invalid-name)
C: 52,20: Invalid variable name "nLeft" (invalid-name)
C: 55,20: Invalid variable name "lPattern" (invalid-name)
C: 62,24: Invalid variable name "nVariations" (invalid-name)
C: 66,12: Invalid variable name "nVariations" (invalid-name)
W: 35,16: Unused variable 'c' (unused-variable)
R: 25, 0: Too many branches (13/12) (too-many-branches)
C: 72, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nPatterns" (invalid-name)
C: 76, 4: Invalid variable name "nLosses" (invalid-name)
C: 80, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge197/challenge197.py _________________
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "f" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "n" (invalid-name)
C:  6, 4: Invalid variable name "u" (invalid-name)
C: 13, 8: Invalid variable name "u" (invalid-name)
W: 10, 4: Unused variable 'odd' (unused-variable)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge197\challenge197.py:10:5: F841 local variable 'odd' is assigned to but never used
D:\Development\pemjh\pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge203/challenge203.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "squareFree" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 29,12: Invalid variable name "p" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
D:\Development\pemjh\pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge204/challenge204.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getHams" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCount" (invalid-name)
C:  5, 8: Invalid variable name "p" (invalid-name)
C:  7, 8: Invalid variable name "pCurrent" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 14,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "pCurrent" (invalid-name)
C: 19, 0: Invalid function name "hamNums" (invalid-name)
C: 19, 0: Invalid argument name "maxPrime" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 23, 4: Unused variable 'found' (unused-variable)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:23:5: F841 local variable 'found' is assigned to but never used
D:\Development\pemjh\pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge205/challenge205.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "diceRolls" (invalid-name)
C:  7, 0: Invalid argument name "nDice" (invalid-name)
C:  7, 0: Invalid argument name "nSides" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nRolls" (invalid-name)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17,10: Invalid variable name "nPete" (invalid-name)
C: 18,11: Invalid variable name "nColin" (invalid-name)
C: 20, 4: Invalid variable name "peteWin" (invalid-name)
C: 21, 4: Invalid variable name "totalRolls" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 22,11: Invalid variable name "f" (invalid-name)
C: 24, 8: Invalid variable name "nWins" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge206/challenge206.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "v" (invalid-name)
C: 12, 0: Invalid function name "hasMask" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "w" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "lowestRoot" (invalid-name)
C: 34, 8: Invalid variable name "sq" (invalid-name)
C: 36, 8: Invalid variable name "hasM" (invalid-name)
C: 36,14: Invalid variable name "wrongIndex" (invalid-name)
C: 51,12: Invalid variable name "sq" (invalid-name)
C: 58,32: More than one statement on a single line (multiple-statements)
C: 62, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused floor imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge206\challenge206.py:1:1: F401 'floor' imported but unused
D:\Development\pemjh\pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge207/challenge207.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "a" (invalid-name)
C:  6, 4: Invalid variable name "b" (invalid-name)
C:  7, 4: Invalid variable name "t" (invalid-name)
C:  8, 4: Invalid variable name "nextPower" (invalid-name)
C: 10, 8: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "t" (invalid-name)
C: 16,12: Invalid variable name "nextPower" (invalid-name)
C: 20, 8: Invalid variable name "a" (invalid-name)
C: 20,11: Invalid variable name "b" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge211/challenge211.py _________________
C: 13, 0: Line too long (112/100) (line-too-long)
C: 54, 0: No space allowed around keyword argument assignment
def challenge211(calc = False):
                      ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "squareSum" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "slowButRight" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "d" (invalid-name)
C: 27,11: Invalid variable name "m" (invalid-name)
C: 30,12: Invalid variable name "a" (invalid-name)
C: 33,16: Invalid variable name "a" (invalid-name)
C: 34,16: Invalid variable name "d" (invalid-name)
C: 34,19: Invalid variable name "m" (invalid-name)
C: 44, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "x" (invalid-name)
C: 48, 8: Invalid variable name "s" (invalid-name)
C: 54, 0: Missing function docstring (missing-docstring)
C: 63, 0: Invalid constant name "answer" (invalid-name)
F: 66, 4: Unable to import 'psyco' (import-error)
W:  2, 0: Unused takewhile imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge211\challenge211.py:2:1: F401 'takewhile' imported but unused
D:\Development\pemjh\pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
D:\Development\pemjh\pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge214/challenge214.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def totients(n, primes = None):
                       ^ (bad-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def totientChainLength(n, current, limit, steps, known = dict()):
                                                       ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "p" (invalid-name)
C: 19,12: Invalid variable name "t" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "totientChainLength" (invalid-name)
C: 25, 0: Invalid argument name "n" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 51,12: Invalid variable name "v" (invalid-name)
W: 25,26: Unused argument 'current' (unused-argument)
C: 58, 0: Missing function docstring (missing-docstring)
C: 64, 8: Invalid variable name "p" (invalid-name)
C: 71, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused primeFactors imported from utils.numbers (unused-import)
W:  1, 0: Unused phi imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'phi' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'primeFactors' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge215/challenge215.py _________________
C:  3, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  6, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C:  9, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 12, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "buildRowOptions" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid function name "runningCrack" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 31, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 31, 0: Invalid function name "W" (invalid-name)
C: 31, 0: Invalid argument name "startRow" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 39,16: Invalid variable name "subRow" (invalid-name)
C: 46, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "wallWidth" (invalid-name)
C: 49, 4: Invalid variable name "wallHeight" (invalid-name)
C: 51, 4: Invalid variable name "rowLinks" (invalid-name)
W: 53,11: Used builtin function 'map' (bad-builtin)
C: 61, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)

_________________ [pylint] pemjh/challenge216/challenge216.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
def challenge216(skip = True):
                      ^ (bad-whitespace)
C: 49, 0: Trailing whitespace (trailing-whitespace)
C: 51, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 54, 0: Exactly one space required after comma
    primes[0:2] = [False,False]
                        ^ (bad-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 60, 0: Trailing whitespace (trailing-whitespace)
C: 62, 0: Trailing whitespace (trailing-whitespace)
C: 63, 0: Exactly one space required after comma
    t[0:2] = [False,False]
                   ^ (bad-whitespace)
C: 64, 0: Trailing whitespace (trailing-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "l" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "v" (invalid-name)
C:  8,12: Invalid variable name "v" (invalid-name)
C: 20, 0: Invalid function name "sq" (invalid-name)
C: 20, 0: Invalid argument name "a" (invalid-name)
C: 20, 0: Invalid argument name "p" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 21, 4: Invalid variable name "q" (invalid-name)
C: 21, 7: Invalid variable name "e" (invalid-name)
C: 23, 8: Invalid variable name "e" (invalid-name)
C: 24, 8: Invalid variable name "q" (invalid-name)
C: 25, 4: Invalid variable name "n" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 28, 4: Invalid variable name "z" (invalid-name)
C: 29, 4: Invalid variable name "y" (invalid-name)
C: 29, 7: Invalid variable name "r" (invalid-name)
C: 29,10: Invalid variable name "x" (invalid-name)
C: 30, 4: Invalid variable name "b" (invalid-name)
C: 31, 4: Invalid variable name "x" (invalid-name)
C: 33, 8: Invalid variable name "bb" (invalid-name)
C: 33,12: Invalid variable name "m" (invalid-name)
C: 35,12: Invalid variable name "bb" (invalid-name)
C: 36,12: Invalid variable name "m" (invalid-name)
C: 39, 8: Invalid variable name "t" (invalid-name)
C: 41,12: Invalid variable name "t" (invalid-name)
C: 42, 8: Invalid variable name "y" (invalid-name)
C: 42,11: Invalid variable name "r" (invalid-name)
C: 42,14: Invalid variable name "x" (invalid-name)
C: 43, 8: Invalid variable name "b" (invalid-name)
W: 40,12: Unused variable 'k' (unused-variable)
C: 46, 0: Missing function docstring (missing-docstring)
C: 56, 8: Invalid variable name "x" (invalid-name)
C: 58,16: Invalid variable name "y" (invalid-name)
C: 61, 4: Invalid variable name "t" (invalid-name)
C: 65, 8: Invalid variable name "x" (invalid-name)
C: 67,12: Invalid variable name "s" (invalid-name)
C: 78, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge220/challenge220.py _________________
C:  2, 0: Exactly one space required after comma
    c = [0,1]
          ^ (bad-whitespace)
C: 13, 0: Exactly one space required after comma
    c2 = [-c2[1],c2[0]]
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "c" (invalid-name)
C:  5, 8: Invalid variable name "c" (invalid-name)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 12, 4: Invalid variable name "c2" (invalid-name)
C: 13, 4: Invalid variable name "c2" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
W: 17,20: Used builtin function 'map' (bad-builtin)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge225/challenge225.py _________________
C:  2, 0: Line too long (108/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 10,12: Invalid variable name "a" (invalid-name)
C: 10,15: Invalid variable name "b" (invalid-name)
C: 10,18: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)

_________________ [pylint] pemjh/challenge230/challenge230.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Line too long (110/100) (line-too-long)
C: 41, 0: Line too long (110/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "D" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "aSize" (invalid-name)
C:  7, 4: Invalid variable name "bSize" (invalid-name)
C:  9, 8: Invalid variable name "aSize" (invalid-name)
C:  9,15: Invalid variable name "bSize" (invalid-name)
C: 14, 4: Invalid variable name "workingN" (invalid-name)
C: 22, 8: Invalid variable name "firstSize" (invalid-name)
C: 25,12: Invalid variable name "workingN" (invalid-name)
C: 33, 8: Invalid variable name "containingStr" (invalid-name)
C: 35, 8: Invalid variable name "containingStr" (invalid-name)
W:  2, 4: Unused variable 'size' (unused-variable)
C: 39, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "a" (invalid-name)
C: 41, 4: Invalid variable name "b" (invalid-name)
C: 44,15: Invalid variable name "n" (invalid-name)
C: 49, 0: Invalid constant name "answer" (invalid-name)
W: 52, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge230\challenge230.py:2:5: F841 local variable 'size' is assigned to but never used
D:\Development\pemjh\pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:52:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge231/challenge231.py _________________
C: 43, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getFirstMultipleOnOrAfter" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "m" (invalid-name)
C: 10, 0: Invalid function name "getFirstMultipleOnOrBefore" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 17, 0: Invalid function name "numInRange" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 23, 0: Missing function docstring (missing-docstring)
C: 24, 4: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "p" (invalid-name)
C: 43,12: Invalid variable name "numRange" (invalid-name)
C: 49,12: Invalid variable name "denRange" (invalid-name)
C: 53,12: Invalid variable name "inRange" (invalid-name)
C: 59,16: Invalid variable name "inRange" (invalid-name)
C: 62,16: Invalid variable name "inRange" (invalid-name)
W: 36, 8: Unused variable 'index' (unused-variable)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:36:9: F841 local variable 'index' is assigned to but never used
D:\Development\pemjh\pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace

_________________ [pylint] pemjh/challenge234/challenge234.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Wrong continued indentation.
                          next**2 if next**2 < limit + 1 else limit + 1,
                          ^| (bad-continuation)
C: 24, 0: Wrong continued indentation.
                          current))
                          ^| (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Missing function docstring (missing-docstring)
W: 19, 8: Redefining built-in 'next' (redefined-builtin)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent

_________________ [pylint] pemjh/challenge235/challenge235.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "r" (invalid-name)
C:  4, 4: Invalid variable name "dr" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  7, 8: Invalid variable name "s" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 11,12: Invalid variable name "r" (invalid-name)
C: 12, 8: Invalid variable name "dr" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge243/challenge243.py _________________
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "d" (invalid-name)
C: 24,23: More than one statement on a single line (multiple-statements)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 37,20: Invalid variable name "m" (invalid-name)
C: 38,20: Invalid variable name "d" (invalid-name)
C: 46, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge250/challenge250.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W: 12,12: Unused variable 'j' (unused-variable)
C: 20, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge259/challenge259.py _________________
C: 22, 0: No space allowed around keyword argument assignment
def get_totals(start, end, known = {}):
                                 ^ (bad-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "g" (invalid-name)
C: 10, 0: Invalid argument name "a" (invalid-name)
C: 10, 0: Invalid argument name "b" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid argument name "a" (invalid-name)
C: 13, 0: Invalid argument name "b" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid argument name "a" (invalid-name)
C: 16, 0: Invalid argument name "b" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid argument name "a" (invalid-name)
C: 19, 0: Invalid argument name "b" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 22, 0: Dangerous default value {} as argument (dangerous-default-value)
C: 22, 0: Missing function docstring (missing-docstring)
C: 55, 0: Invalid constant name "answer" (invalid-name)
C: 57, 0: Missing function docstring (missing-docstring)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)

_________________ [pylint] pemjh/challenge265/challenge265.py _________________
C: 10, 0: Trailing whitespace (trailing-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Trailing whitespace (trailing-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  3, 4: Invalid variable name "s" (invalid-name)
C:  4, 4: Invalid variable name "d" (invalid-name)
C:  4, 7: Invalid variable name "m" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  6, 4: Invalid variable name "d" (invalid-name)
C:  6, 7: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "s" (invalid-name)
C:  8, 4: Invalid variable name "s" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Invalid argument name "d" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "b" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "getSequences" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 26, 8: Invalid variable name "b" (invalid-name)
C: 30,16: Invalid variable name "s" (invalid-name)
C: 35, 0: Invalid function name "S" (invalid-name)
C: 35, 0: Invalid argument name "n" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 49, 0: Missing function docstring (missing-docstring)
C: 52, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace

-------------- coverage: platform win32, python 2.7.10-final-42 ---------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge001\challenge001       7      3      4      3    45%   4, 9-10
pemjh\challenge002\challenge002      12     10      8      7    15%   2-3, 6-16
pemjh\challenge003\challenge003      17     13     10      5    33%   5-23, 28-29
pemjh\challenge004\challenge004      19     16     10      9    14%   5-31, 36-37
pemjh\challenge005\challenge005      24     21     18     17    10%   2-34, 39-40
pemjh\challenge006\challenge006      13     10      4      3    24%   2-18, 23-24
pemjh\challenge007\challenge007      18     13      9      8    22%   5-19, 24-25
pemjh\challenge008\challenge008      16     13     10      9    15%   2-39, 44-45
pemjh\challenge009\challenge009      14     11      8      7    18%   4-16, 21-22
pemjh\challenge010\challenge010      14      9     10      9    25%   6-13, 18-19
pemjh\challenge011\challenge011      39     36     26     25     6%   2-56, 61-62
pemjh\challenge012\challenge012      31     28     14      9    18%   2-3, 7-44
pemjh\challenge013\challenge013      11      8      4      3    27%   2-109, 114-115
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      8      5    17%   2-3, 7-32
pemjh\challenge016\challenge016      12      9      4      3    25%   2-12, 17-18
pemjh\challenge017\challenge017      33     29     16     15    10%   2-39, 42-104, 109-110
pemjh\challenge018\challenge018      26     24      4      3    10%   2-3, 6-31
pemjh\challenge019\challenge019      32     25     18     17    16%   2, 6-9, 12-15, 19-28, 33-40, 45-46
pemjh\challenge020\challenge020      16     12      6      5    23%   2-5, 9-16, 21-22
pemjh\challenge021\challenge021      21     19     14     13     9%   2-3, 7-33
pemjh\challenge022\challenge022      28     21     10      9    21%   5-14, 17-24, 28-32, 37-38
pemjh\challenge023\challenge023      24     18     16     14    20%   2-3, 7-21, 24, 27-29, 34
pemjh\challenge024\challenge024      14     12      6      5    15%   2-3, 7-18
pemjh\challenge025\challenge025      15     13     10      9    12%   2-3, 5-19
pemjh\challenge026\challenge026      21     17     10      9    16%   4-23, 28-29
pemjh\challenge027\challenge027      27     25     14     11    12%   2-3, 6-36
pemjh\challenge028\challenge028      14     11      4      3    22%   2-13, 18-19
pemjh\challenge029\challenge029      14     11      6      5    20%   2-12, 17-18
pemjh\challenge030\challenge030      19     16     10      9    14%   3-16, 21-22
pemjh\challenge031\challenge031      16     12      6      5    23%   2-14, 19, 22-23
pemjh\challenge032\challenge032      20     18     10      9    10%   2-3, 7-27
pemjh\challenge033\challenge033      33     31     18     17     6%   2-3, 7-48
pemjh\challenge034\challenge034      30     28     14     11    11%   2-3, 7-46
pemjh\challenge035\challenge035      38     36     24     23     5%   2-3, 6-59
pemjh\challenge036\challenge036      22     18     10      9    16%   2-7, 11-24, 29-30
pemjh\challenge037\challenge037      27     25     18     15    11%   2-3, 7-36
pemjh\challenge038\challenge038      20     15     10      9    20%   4, 7-21, 26-27
pemjh\challenge039\challenge039      27     23     14     13    12%   2-23, 26-34, 39-40
pemjh\challenge040\challenge040      15     12      6      5    19%   2-13, 18-19
pemjh\challenge041\challenge041      17     15      8      7    12%   2-3, 6-23
pemjh\challenge042\challenge042      30     24     14     13    16%   5-9, 12-36, 41-42
pemjh\challenge043\challenge043      14     12      6      5    15%   2-3, 6-27
pemjh\challenge044\challenge044      27     21     14     13    17%   4, 7-11, 14-29, 34-35
pemjh\challenge045\challenge045      25     19     12      7    30%   2, 5, 9-21, 24-29, 34-35
pemjh\challenge046\challenge046      23     20     12      9    17%   4-5, 8-32
pemjh\challenge047\challenge047      37     34     22     19    10%   4-5, 8-50
pemjh\challenge048\challenge048       7      4      2      1    44%   2-3, 8-10
pemjh\challenge049\challenge049      24     21     16     15    10%   4-5, 8-32
pemjh\challenge050\challenge050      24     22     12     11     8%   2-3, 6-30
pemjh\challenge051\challenge051      38     35     24     21    10%   4-5, 8-50
pemjh\challenge052\challenge052      20     16      8      7    18%   2, 5-22, 27-28
pemjh\challenge053\challenge053      16     14     10      9    12%   2-3, 6-20
pemjh\challenge054\challenge054      71     61     44     43    10%   5-12, 16-19, 22-24, 39-93, 98-111, 115-131, 136
pemjh\challenge055\challenge055      23     19     12      9    20%   2-12, 15-21, 26-27
pemjh\challenge056\challenge056      14     11      8      7    18%   2-11, 16-17
pemjh\challenge057\challenge057      15     12      8      7    17%   2-15, 20-21
pemjh\challenge058\challenge058      26     24     12      9    13%   2-3, 6-38
pemjh\challenge059\challenge059      29     22     19     18    17%   6-21, 27-45, 48-49
pemjh\challenge060\challenge060      75     73     37     36     3%   2-3, 7-119
pemjh\challenge061\challenge061      65     59     42     41     7%   4, 7-22, 28-99, 104
pemjh\challenge062\challenge062      23     19      8      5    23%   4-29, 34
pemjh\challenge063\challenge063      18     14      6      3    29%   4-22, 27-28
pemjh\challenge064\challenge064      24     23      8      8     3%   3-39
pemjh\challenge065\challenge065      20     18      8      7    11%   2-3, 6-37
pemjh\challenge066\challenge066      15     14      8      8     4%   5-23
pemjh\challenge067\challenge067      17     13      6      5    22%   5-6, 11-25
pemjh\challenge068\challenge068      48     43     32     31     8%   2-5, 8-21, 24-65, 70
pemjh\challenge069\challenge069      20     18     10      9    10%   2-3, 6-24
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
pemjh\challenge071\challenge071      25     21     12     11    14%   4-27, 32
pemjh\challenge072\challenge072      10      8      4      3    21%   2-3, 7-14
pemjh\challenge073\challenge073      31     28     16     15     9%   4-5, 8-42
pemjh\challenge074\challenge074      33     28     10      9    14%   2-3, 6-23, 26-36, 41
pemjh\challenge075\challenge075      16     15      8      8     4%   3-27
pemjh\challenge076\challenge076      20     16     10      9    17%   2-17, 30-32, 37
pemjh\challenge077\challenge077      20     19     12     10     9%   3-34
pemjh\challenge078\challenge078      20     17     12     11    13%   2-19, 24
pemjh\challenge079\challenge079       8      3      2      1    60%   9, 14-15
pemjh\challenge080\challenge080      26     21     12     11    16%   5-26, 29-34, 39
pemjh\challenge081\challenge081      32     26     13     12    16%   5-17, 20-41, 46
pemjh\challenge082\challenge082      34     27     12     11    17%   7-37, 41-48, 53
pemjh\challenge083\challenge083      45     38     20     19    12%   6-14, 17-25, 29-75, 80
pemjh\challenge084\challenge084      74     67     48     47     7%   4-6, 10-50, 54-66, 69-109, 114
pemjh\challenge085\challenge085      34     30     16     11    18%   3-10, 13-46, 51
pemjh\challenge086\challenge086      31     25     14     11    20%   2, 6-17, 20-23, 28-39, 44
pemjh\challenge087\challenge087      30     28     14     13     7%   2-3, 5-40
pemjh\challenge088\challenge088      24     19     12     11    17%   5-19, 22-31, 36
pemjh\challenge089\challenge089      51     42     26     25    13%   18-31, 35-51, 54-65, 69-79, 83-85, 90
pemjh\challenge090\challenge090      78     68     50     49     9%   5-18, 21-27, 30-33, 36-69, 74-114, 117-127, 132
pemjh\challenge091\challenge091      23     19     20     19    12%   2-30, 33-35, 40
pemjh\challenge092\challenge092      96     94     50     45     5%   2-3, 6-124
pemjh\challenge093\challenge093      67     59     50     49     8%   4-10, 14-24, 27-32, 35-58, 61-97, 102
pemjh\challenge094\challenge094      35     30     12     11    13%   2-7, 11-48, 54
pemjh\challenge095\challenge095      35     30     22     21    11%   3-10, 14-48, 51-56, 61
pemjh\challenge096\challenge096     181    155    116    115     9%   7-14, 22-34, 40-44, 47-59, 62-69, 73-94, 97-105, 108-115, 118-146, 150-155, 158-174, 178-181, 184-221, 224-228, 231-235, 238-241, 244-254, 257-277, 294
pemjh\challenge097\challenge097       6      3      2      1    50%   2, 7-8
pemjh\challenge098\challenge098      62     54     34     33     9%   5-13, 16-23, 26-30, 33-93, 98
pemjh\challenge099\challenge099      17     12      7      6    25%   5-14, 19-20
pemjh\challenge100\challenge100       9      6      4      3    31%   2-6, 11
pemjh\challenge101\challenge101      26     23     18     17     9%   2-38, 43
pemjh\challenge102\challenge102      34     27     14     13    17%   9-31, 35-41, 45-53, 59
pemjh\challenge103\challenge103      40     35     30     29     9%   3-12, 16-34, 37-56, 61
pemjh\challenge104\challenge104      34     33     15     15     2%   3-50
pemjh\challenge105\challenge105      40     32     22     21    15%   5-19, 22-28, 32-47, 51-58, 65
pemjh\challenge106\challenge106      37     30     16     15    15%   2-14, 17-26, 29-46, 49-60, 63, 68
pemjh\challenge107\challenge107      38     31     12     11    16%   6-34, 37-45, 48-65, 70
pemjh\challenge108\challenge108      35     34     16     16     2%   3-59
pemjh\challenge109\challenge109      37     32     18     17    11%   2-19, 23-29, 32-45, 50
pemjh\challenge110\challenge110      35     34     16     16     2%   3-59
pemjh\challenge111\challenge111      38     37     31     31     1%   3-54
pemjh\challenge112\challenge112      32     28     20     17    13%   2-27, 30-43, 48
pemjh\challenge113\challenge113      16     14      6      5    14%   2-3, 6-61
pemjh\challenge114\challenge114      24     19     12     11    17%   2-24, 27-28, 31-32, 37
pemjh\challenge115\challenge115      30     25     14     13    14%   2-25, 28-29, 32-38, 43
pemjh\challenge116\challenge116      24     19     10      9    18%   2-22, 25-28, 31-32, 37
pemjh\challenge117\challenge117      21     16     10      9    19%   2-20, 23-24, 27-28, 33
pemjh\challenge118\challenge118      36     35     14     14     2%   2-52
pemjh\challenge119\challenge119      24     19     10      9    18%   2-7, 12-23, 26-28, 33
pemjh\challenge120\challenge120      10      6      4      3    36%   2-6, 9-10, 15
pemjh\challenge121\challenge121      26     25     10     10     3%   3-39
pemjh\challenge122\challenge122      15     12     12     11    15%   2-23, 28
pemjh\challenge123\challenge123      16     15      6      6     5%   3-20
pemjh\challenge124\challenge124      21     20     14     14     3%   3-41
pemjh\challenge125\challenge125      21     18     12     11    12%   2-24, 29
pemjh\challenge126\challenge126      31     27     24     23     9%   2, 6-36, 41
pemjh\challenge127\challenge127      23     22     15     15     3%   3-35
pemjh\challenge128\challenge128      23     22     10     10     3%   3-33
pemjh\challenge129\challenge129      22     18     10      9    16%   2-8, 11-20, 25-27
pemjh\challenge130\challenge130      21     20      8      8     3%   3-30
pemjh\challenge131\challenge131      22     21     10     10     3%   3-41
pemjh\challenge132\challenge132      16     15      8      8     4%   3-24
pemjh\challenge133\challenge133      10      9      2      2     8%   3-16
pemjh\challenge134\challenge134      42     41     20     20     2%   3-72
pemjh\challenge135\challenge135      15     11     10      9    20%   2-16, 19, 25
pemjh\challenge136\challenge136      19     18     10     10     3%   3-26
pemjh\challenge137\challenge137      16     11      6      5    27%   2-6, 10-17, 20, 25
pemjh\challenge138\challenge138      23     22     14     14     3%   3-34
pemjh\challenge139\challenge139      11     10      6      6     6%   3-19
pemjh\challenge142\challenge142      26     21     18     17    14%   2, 5, 8-34, 39
pemjh\challenge144\challenge144      34     26      6      5    23%   4-5, 9-27, 31-51, 54, 57-67, 72
pemjh\challenge145\challenge145      11      8      4      3    27%   2-10, 15
pemjh\challenge146\challenge146      18     13     14     13    19%   2-6, 9, 17-26, 31
pemjh\challenge148\challenge148      22     17      6      5    21%   2-8, 11-29, 32-34, 39
pemjh\challenge149\challenge149      32     26     12     11    16%   2, 5, 9-27, 30-46, 51
pemjh\challenge151\challenge151      21     17     14     13    14%   2-20, 23, 28
pemjh\challenge162\challenge162       7      3      4      3    45%   2-4, 11
pemjh\challenge164\challenge164      20     16     10      9    17%   3-23, 27-31, 36
pemjh\challenge166\challenge166      40     37     33     32     5%   3-68, 73
pemjh\challenge173\challenge173      21     17      6      5    19%   2-27, 30, 35
pemjh\challenge174\challenge174      27     26     14     14     2%   3-40
pemjh\challenge179\challenge179      18     14      8      7    19%   3-17, 20-21, 26
pemjh\challenge183\challenge183      39     38     12     12     2%   2-56
pemjh\challenge187\challenge187      16     15      8      8     4%   3-22
pemjh\challenge188\challenge188      15     11      6      5    24%   2-10, 13, 18
pemjh\challenge190\challenge190       7      3      6      5    38%   2, 6, 11
pemjh\challenge191\challenge191      48     43     34     33     7%   2-23, 27-70, 73-78, 83
pemjh\challenge197\challenge197      19     15      8      7    19%   2, 5-22, 27
pemjh\challenge203\challenge203      27     26     16     16     2%   3-44
pemjh\challenge204\challenge204      21     20      8      8     3%   3-32
pemjh\challenge205\challenge205      25     20     10      9    17%   2-4, 8-14, 17-27, 32
pemjh\challenge206\challenge206      45     37     16     13    18%   6-10, 13-22, 26-60, 65
pemjh\challenge207\challenge207      20     17      6      5    15%   3-20, 25
pemjh\challenge211\challenge211      46     45     24     24     1%   2-68
pemjh\challenge214\challenge214      45     44     26     26     1%   3-76
pemjh\challenge215\challenge215      45     39     32     31     9%   2-23, 26-29, 32-44, 48-59, 64
pemjh\challenge216\challenge216      67     61     48     47     6%   4-18, 21-44, 47-76, 81
pemjh\challenge220\challenge220      17     13      6      5    22%   2-14, 17, 22
pemjh\challenge225\challenge225      14     11      8      7    18%   4-14, 19
pemjh\challenge230\challenge230      34     30     12     11    11%   2-37, 40-47, 52-53
pemjh\challenge231\challenge231      41     40     14     14     2%   3-72
pemjh\challenge234\challenge234      25     24     10     10     3%   3-44
pemjh\challenge235\challenge235      15     12      8      7    17%   2-14, 19
pemjh\challenge243\challenge243      33     32     20     20     2%   3-49
pemjh\challenge250\challenge250      16     12      8      7    21%   2-18, 21-22, 27
pemjh\challenge259\challenge259      42     32     18     17    18%   4-8, 11, 14, 17, 20, 23-53, 58-63, 66
pemjh\challenge265\challenge265      35     27     10      9    20%   2-9, 13-15, 18, 21-33, 37-47, 50, 55
pemjh\main                           51     33     20     15    32%   7-8, 13-28, 39-57, 63, 66-68
-----------------------------------------------------------------------------
TOTAL                              4960   4272   2571   2370    12%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\pypy-2.6.1-win32\lib-python\2.7\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "E:\software_tools\python\pypy-2.6.1-win32\lib-python\2.7\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\Development\pemjh\.tox\pypy\bin\py.test.EXE\__main__.py", line 9, in <module>
    sys.exit(main())
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\pypy\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
CoverageError: Required test coverage of 100% not reached. Total coverage: 11.80%
ERROR: InvocationError: 'D:\\Development\\pemjh\\.tox\\pypy\\bin\\py.test.EXE --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100'
___________________________________ summary ___________________________________
ERROR:   py27: commands failed
ERROR:   py27_64: commands failed
ERROR:   py34: commands failed
ERROR:   py34_64: commands failed
ERROR:   pypy: commands failed
