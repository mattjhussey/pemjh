running test
Searching for tox
Best match: tox 2.1.1
Processing tox-2.1.1-py2.7.egg

Using d:\development\pemjh\.eggs\tox-2.1.1-py2.7.egg
Searching for pluggy<0.4.0,>=0.3.0
Best match: pluggy 0.3.0
Processing pluggy-0.3.0-py2.7.egg

Using d:\development\pemjh\.eggs\pluggy-0.3.0-py2.7.egg
Searching for py>=1.4.17
Best match: py 1.4.30
Processing py-1.4.30-py2.7.egg

Using d:\development\pemjh\.eggs\py-1.4.30-py2.7.egg
Searching for virtualenv>=1.11.2
Best match: virtualenv 13.1.2
Processing virtualenv-13.1.2-py2.7.egg

Using d:\development\pemjh\.eggs\virtualenv-13.1.2-py2.7.egg
running egg_info
writing pemjh.egg-info\PKG-INFO
writing top-level names to pemjh.egg-info\top_level.txt
writing dependency_links to pemjh.egg-info\dependency_links.txt
package init file 'pemjh\__init__.py' not found (or not a regular file)
reading manifest file 'pemjh.egg-info\SOURCES.txt'
writing manifest file 'pemjh.egg-info\SOURCES.txt'
running build_ext
GLOB sdist-make: D:\Development\pemjh\setup.py
py27 inst-nodeps: D:\Development\pemjh\.tox\dist\pemjh-0.0.1.zip
py27 installed: apipkg==1.4,astroid==1.3.8,colorama==0.3.3,coverage==3.7.1,execnet==1.4.1,flake8==2.4.1,logilab-common==1.0.2,mccabe==0.3.1,pemjh==0.0.1,pep8==1.5.7,py==1.4.30,pyflakes==0.8.1,pylint==1.4.4,pytest==2.7.2,pytest-cache==1.0,pytest-cov==2.1.0,pytest-flake8==0.1,pytest-pylint==0.3.0,six==1.9.0,wheel==0.24.0
py27 runtests: PYTHONHASHSEED='631'
py27 runtests: commands[0] | py.test --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100
============================= test session starts =============================
platform win32 -- Python 2.7.10 -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh, inifile: 
plugins: cache, cov, flake8, pylint
collected 364 items / 65 errors

setup.py FF
pemjh\main.py FF
pemjh\challenge001\challenge001.py FF
pemjh\challenge002\challenge002.py FF
pemjh\challenge003\challenge003.py FF
pemjh\challenge004\challenge004.py FF
pemjh\challenge005\challenge005.py FF
pemjh\challenge006\challenge006.py FF
pemjh\challenge007\challenge007.py FF
pemjh\challenge008\challenge008.py FF
pemjh\challenge009\challenge009.py FF
pemjh\challenge010\challenge010.py FF
pemjh\challenge011\challenge011.py FF
pemjh\challenge012\challenge012.py FF
pemjh\challenge013\challenge013.py FF
pemjh\challenge014\challenge014.py FF
pemjh\challenge015\challenge015.py FF
pemjh\challenge016\challenge016.py FF
pemjh\challenge017\challenge017.py FF
pemjh\challenge018\challenge018.py FF
pemjh\challenge019\challenge019.py FF
pemjh\challenge020\challenge020.py FF
pemjh\challenge021\challenge021.py FF
pemjh\challenge022\challenge022.py FF
pemjh\challenge023\challenge023.py FF
pemjh\challenge024\challenge024.py FF
pemjh\challenge025\challenge025.py FF
pemjh\challenge026\challenge026.py FF
pemjh\challenge027\challenge027.py FF
pemjh\challenge028\challenge028.py FF
pemjh\challenge029\challenge029.py FF
pemjh\challenge030\challenge030.py FF
pemjh\challenge031\challenge031.py FF
pemjh\challenge032\challenge032.py FF
pemjh\challenge033\challenge033.py FF
pemjh\challenge034\challenge034.py FF
pemjh\challenge035\challenge035.py FF
pemjh\challenge036\challenge036.py FF
pemjh\challenge037\challenge037.py FF
pemjh\challenge038\challenge038.py FF
pemjh\challenge039\challenge039.py FF
pemjh\challenge040\challenge040.py FF
pemjh\challenge041\challenge041.py FF
pemjh\challenge042\challenge042.py FF
pemjh\challenge043\challenge043.py FF
pemjh\challenge044\challenge044.py FF
pemjh\challenge045\challenge045.py FF
pemjh\challenge046\challenge046.py FF
pemjh\challenge047\challenge047.py FF
pemjh\challenge048\challenge048.py FF
pemjh\challenge049\challenge049.py FF
pemjh\challenge050\challenge050.py FF
pemjh\challenge051\challenge051.py FF
pemjh\challenge052\challenge052.py FF
pemjh\challenge053\challenge053.py FF
pemjh\challenge054\challenge054.py FF
pemjh\challenge055\challenge055.py FF
pemjh\challenge056\challenge056.py FF
pemjh\challenge057\challenge057.py FF
pemjh\challenge058\challenge058.py FF
pemjh\challenge059\challenge059.py FF
pemjh\challenge060\challenge060.py FF
pemjh\challenge061\challenge061.py FF
pemjh\challenge062\challenge062.py FF
pemjh\challenge063\challenge063.py FF
pemjh\challenge064\challenge064.py FF
pemjh\challenge065\challenge065.py FF
pemjh\challenge066\challenge066.py FF
pemjh\challenge067\challenge067.py FF
pemjh\challenge068\challenge068.py FF
pemjh\challenge069\challenge069.py FF
pemjh\challenge070\challenge070.py FF
pemjh\challenge071\challenge071.py FF
pemjh\challenge072\challenge072.py FF
pemjh\challenge073\challenge073.py FF
pemjh\challenge074\challenge074.py FF
pemjh\challenge075\challenge075.py FF
pemjh\challenge076\challenge076.py FF
pemjh\challenge077\challenge077.py FF
pemjh\challenge078\challenge078.py FF
pemjh\challenge079\challenge079.py FF
pemjh\challenge080\challenge080.py FF
pemjh\challenge081\challenge081.py FF
pemjh\challenge082\challenge082.py FF
pemjh\challenge083\challenge083.py FF
pemjh\challenge084\challenge084.py FF
pemjh\challenge085\challenge085.py FF
pemjh\challenge086\challenge086.py FF
pemjh\challenge087\challenge087.py FF
pemjh\challenge088\challenge088.py FF
pemjh\challenge089\challenge089.py FF
pemjh\challenge090\challenge090.py FF
pemjh\challenge091\challenge091.py FF
pemjh\challenge092\challenge092.py FF
pemjh\challenge093\challenge093.py FF
pemjh\challenge094\challenge094.py FF
pemjh\challenge095\challenge095.py FF
pemjh\challenge096\challenge096.py FF
pemjh\challenge097\challenge097.py FF
pemjh\challenge098\challenge098.py FF
pemjh\challenge099\challenge099.py FF
pemjh\challenge100\challenge100.py Fs
pemjh\challenge101\challenge101.py FF
pemjh\challenge102\challenge102.py FF
pemjh\challenge103\challenge103.py FF
pemjh\challenge104\challenge104.py FF
pemjh\challenge105\challenge105.py FF
pemjh\challenge106\challenge106.py FF
pemjh\challenge107\challenge107.py FF
pemjh\challenge108\challenge108.py FF
pemjh\challenge109\challenge109.py FF
pemjh\challenge110\challenge110.py FF
pemjh\challenge111\challenge111.py FF
pemjh\challenge112\challenge112.py FF
pemjh\challenge113\challenge113.py FF
pemjh\challenge114\challenge114.py FF
pemjh\challenge115\challenge115.py FF
pemjh\challenge116\challenge116.py FF
pemjh\challenge117\challenge117.py FF
pemjh\challenge118\challenge118.py FF
pemjh\challenge119\challenge119.py FF
pemjh\challenge120\challenge120.py FF
pemjh\challenge121\challenge121.py FF
pemjh\challenge122\challenge122.py FF
pemjh\challenge123\challenge123.py FF
pemjh\challenge124\challenge124.py FF
pemjh\challenge125\challenge125.py Fs
pemjh\challenge126\challenge126.py FF
pemjh\challenge127\challenge127.py FF
pemjh\challenge128\challenge128.py FF
pemjh\challenge129\challenge129.py FF
pemjh\challenge130\challenge130.py FF
pemjh\challenge131\challenge131.py FF
pemjh\challenge132\challenge132.py FF
pemjh\challenge133\challenge133.py FF
pemjh\challenge134\challenge134.py FF
pemjh\challenge135\challenge135.py FF
pemjh\challenge136\challenge136.py FF
pemjh\challenge137\challenge137.py FF
pemjh\challenge138\challenge138.py FF
pemjh\challenge139\challenge139.py FF
pemjh\challenge142\challenge142.py FF
pemjh\challenge144\challenge144.py FF
pemjh\challenge145\challenge145.py Fs
pemjh\challenge146\challenge146.py FF
pemjh\challenge148\challenge148.py FF
pemjh\challenge149\challenge149.py FF
pemjh\challenge151\challenge151.py FF
pemjh\challenge162\challenge162.py FF
pemjh\challenge164\challenge164.py FF
pemjh\challenge166\challenge166.py FF
pemjh\challenge173\challenge173.py FF
pemjh\challenge174\challenge174.py FF
pemjh\challenge179\challenge179.py FF
pemjh\challenge183\challenge183.py FF
pemjh\challenge187\challenge187.py FF
pemjh\challenge188\challenge188.py FF
pemjh\challenge190\challenge190.py FF
pemjh\challenge191\challenge191.py FF
pemjh\challenge197\challenge197.py FF
pemjh\challenge203\challenge203.py FF
pemjh\challenge204\challenge204.py FF
pemjh\challenge205\challenge205.py FF
pemjh\challenge206\challenge206.py FF
pemjh\challenge207\challenge207.py Fs
pemjh\challenge211\challenge211.py FF
pemjh\challenge214\challenge214.py FF
pemjh\challenge215\challenge215.py FF
pemjh\challenge216\challenge216.py FF
pemjh\challenge220\challenge220.py FF
pemjh\challenge225\challenge225.py FF
pemjh\challenge230\challenge230.py FF
pemjh\challenge231\challenge231.py FF
pemjh\challenge234\challenge234.py FF
pemjh\challenge235\challenge235.py FF
pemjh\challenge243\challenge243.py FF
pemjh\challenge250\challenge250.py FF
pemjh\challenge259\challenge259.py FF
pemjh\challenge265\challenge265.py FF
pemjh\utilities\__init__.py .s
pemjh\utilities\numbers.py FF
pemjh\utilities\strings.py Fs

=================================== ERRORS ====================================
__________________________ ERROR collecting setup.py __________________________

self = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
func = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
self       = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>, attrname = '_collected'
function = <function <lambda> at 0x0000000003ECC358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = None
function   = <function <lambda> at 0x0000000003ECC358>
self       = <DoctestModule 'setup.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'setup.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\setup.py'), modname = 'setup'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'setup'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh')
self       = local('D:\\Development\\pemjh\\setup.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    https://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands"""
    
    import os
    import sys
    from setuptools import setup
    from setuptools.command.test import test as TestCommand
    
    def read(fname):
        return open(os.path.join(os.path.dirname(__file__), fname)).read()
    
    class Tox(TestCommand):
        user_options = [('tox-args=', 'a', "Arguments to pass to tox")]
        def initialize_options(self):
            TestCommand.initialize_options(self)
            self.tox_args = None
        def finalize_options(self):
            TestCommand.finalize_options(self)
            self.test_args = []
            self.test_suite = True
        def run_tests(self):
            #import here, cause outside the eggs aren't loaded
            import tox
            import shlex
            args = self.tox_args
            if args:
                args = shlex.split(self.tox_args)
            errno = tox.cmdline(args=args)
            sys.exit(errno)
    
    setup(
        name = "pemjh",
        version = "0.0.1",
        author = "Matthew Hussey",
        author_email = "matthew.hussey@googlemail.com",
        description = ("Project euler (https://projecteuler.net/) challenge "
                       "code in Python."),
        license = "None, private use by myself only",
        keywords = "code challenge euler",
        url = "none.non",
        packages = ["pemjh"],
        long_description = read("README"),
        classifiers=[
            "Development Status :: 1 - Planning"],
        tests_require=['tox'],
>       cmdclass = {"test": Tox},
    )

TestCommand = None
Tox        = None
__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
os         = None
read       = None
setup      = None
sys        = None

setup.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

attrs = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x00000000043B0E88>}, ...}
klass = <class setuptools.dist.Distribution at 0x000000000436D828>
dist = <setuptools.dist.Distribution instance at 0x00000000043A8FC8>
msg = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

    def setup(**attrs):
        """The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
    
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
    
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
    
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.
        """
    
        global _setup_stop_after, _setup_distribution
    
        # Determine the distribution class -- either caller-supplied or
        # our Distribution (see below).
        klass = attrs.get('distclass')
        if klass:
            del attrs['distclass']
        else:
            klass = Distribution
    
        if 'script_name' not in attrs:
            attrs['script_name'] = os.path.basename(sys.argv[0])
        if 'script_args' not in attrs:
            attrs['script_args'] = sys.argv[1:]
    
        # Create the Distribution instance, using the remaining arguments
        # (ie. everything except distclass) to initialize it
        try:
            _setup_distribution = dist = klass(attrs)
        except DistutilsSetupError, msg:
            if 'name' in attrs:
                raise SystemExit, "error in %s setup command: %s" % \
                      (attrs['name'], msg)
            else:
                raise SystemExit, "error in setup command: %s" % msg
    
        if _setup_stop_after == "init":
            return dist
    
        # Find and parse the config file(s): they will override options from
        # the setup script, but be overridden by the command line.
        dist.parse_config_files()
    
        if DEBUG:
            print "options (after parsing config files):"
            dist.dump_option_dicts()
    
        if _setup_stop_after == "config":
            return dist
    
        # Parse the command line and override config files; any
        # command-line errors are the end user's fault, so turn them into
        # SystemExit to suppress tracebacks.
        try:
            ok = dist.parse_command_line()
        except DistutilsArgError, msg:
>           raise SystemExit, gen_usage(dist.script_name) + "\nerror: %s" % msg
E           SystemExit: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
E              or: py.test.EXE --help [cmd1 cmd2 ...]
E              or: py.test.EXE --help-commands
E              or: py.test.EXE cmd --help
E           
E           error: option --pylint not recognized

attrs      = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x00000000043B0E88>}, ...}
dist       = <setuptools.dist.Distribution instance at 0x00000000043A8FC8>
klass      = <class setuptools.dist.Distribution at 0x000000000436D828>
msg        = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

E:\software_tools\python\python27_64\Lib\distutils\core.py:139: SystemExit
_____________ ERROR collecting pemjh/challenge002/challenge002.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030A2DD8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000043E7D48>)
function   = <function <lambda> at 0x00000000030A2DD8>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge002\challenge002.py:5: ImportError
_____________ ERROR collecting pemjh/challenge012/challenge012.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000477F9E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045DA7C8>)
function   = <function <lambda> at 0x000000000477F9E8>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge012\challenge012.py:6: ImportError
_____________ ERROR collecting pemjh/challenge015/challenge015.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047AAA58>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004487FC8>)
function   = <function <lambda> at 0x00000000047AAA58>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge015\challenge015.py:5: ImportError
_____________ ERROR collecting pemjh/challenge018/challenge018.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030C7AC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044F6788>)
function   = <function <lambda> at 0x00000000030C7AC8>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge018\challenge018.py:4: ImportError
_____________ ERROR collecting pemjh/challenge021/challenge021.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004765F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004770588>)
function   = <function <lambda> at 0x0000000004765F98>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge021\challenge021.py:5: ImportError
_____________ ERROR collecting pemjh/challenge024/challenge024.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004765518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x0000000004560388>)
function   = <function <lambda> at 0x0000000004765518>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge024\challenge024.py:5: ImportError
_____________ ERROR collecting pemjh/challenge025/challenge025.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004765AC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045BA948>)
function   = <function <lambda> at 0x0000000004765AC8>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge025\challenge025.py:4: ImportError
_____________ ERROR collecting pemjh/challenge027/challenge027.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004765E48>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000466C208>)
function   = <function <lambda> at 0x0000000004765E48>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge027\challenge027.py:5: ImportError
_____________ ERROR collecting pemjh/challenge032/challenge032.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045A3278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x00000000046509C8>)
function   = <function <lambda> at 0x00000000045A3278>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge032\challenge032.py:5: ImportError
_____________ ERROR collecting pemjh/challenge033/challenge033.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045A36D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000310CA48>)
function   = <function <lambda> at 0x00000000045A36D8>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import lowestCommonTerms
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge033\challenge033.py:5: ImportError
_____________ ERROR collecting pemjh/challenge034/challenge034.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045A3898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000455C908>)
function   = <function <lambda> at 0x00000000045A3898>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge034\challenge034.py:5: ImportError
_____________ ERROR collecting pemjh/challenge035/challenge035.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045A3C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000463BB08>)
function   = <function <lambda> at 0x00000000045A3C88>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge035\challenge035.py:5: ImportError
_____________ ERROR collecting pemjh/challenge037/challenge037.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000456DEB8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047B3EC8>)
function   = <function <lambda> at 0x000000000456DEB8>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge037\challenge037.py:5: ImportError
_____________ ERROR collecting pemjh/challenge041/challenge041.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000456D208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004555508>)
function   = <function <lambda> at 0x000000000456D208>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge041\challenge041.py:5: ImportError
_____________ ERROR collecting pemjh/challenge043/challenge043.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.strings>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.strings>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000456D518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.strings',), <traceback object at 0x00000000048092C8>)
function   = <function <lambda> at 0x000000000456D518>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.strings import permutate
E   ImportError: No module named utils.strings

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge043\challenge043.py:4: ImportError
_____________ ERROR collecting pemjh/challenge046/challenge046.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000456D9E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F932C8>)
function   = <function <lambda> at 0x000000000456D9E8>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import sqrt
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
sqrt       = None

pemjh\challenge046\challenge046.py:6: ImportError
_____________ ERROR collecting pemjh/challenge047/challenge047.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045BE278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004390508>)
function   = <function <lambda> at 0x00000000045BE278>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
count      = None

pemjh\challenge047\challenge047.py:6: ImportError
_____________ ERROR collecting pemjh/challenge049/challenge049.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045BE358>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004770388>)
function   = <function <lambda> at 0x00000000045BE358>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import string
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
string     = None

pemjh\challenge049\challenge049.py:6: ImportError
_____________ ERROR collecting pemjh/challenge050/challenge050.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045BE198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046841C8>)
function   = <function <lambda> at 0x00000000045BE198>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge050\challenge050.py:4: ImportError
_____________ ERROR collecting pemjh/challenge051/challenge051.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045BE438>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F90448>)
function   = <function <lambda> at 0x00000000045BE438>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import cycle
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
cycle      = None

pemjh\challenge051\challenge051.py:6: ImportError
_____________ ERROR collecting pemjh/challenge053/challenge053.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045BE828>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F79E48>)
function   = <function <lambda> at 0x00000000045BE828>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge053\challenge053.py:4: ImportError
_____________ ERROR collecting pemjh/challenge058/challenge058.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000045BED68>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045F01C8>)
function   = <function <lambda> at 0x00000000045BED68>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge058\challenge058.py:4: ImportError
_____________ ERROR collecting pemjh/challenge060/challenge060.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047A46D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F79188>)
function   = <function <lambda> at 0x00000000047A46D8>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge060\challenge060.py:5: ImportError
_____________ ERROR collecting pemjh/challenge064/challenge064.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000047A4898>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045B5A48>)
function   = <function <lambda> at 0x00000000047A4898>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import continueGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge064\challenge064.py:1: ImportError
_____________ ERROR collecting pemjh/challenge065/challenge065.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000446A0B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045D6588>)
function   = <function <lambda> at 0x000000000446A0B8>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge065\challenge065.py:4: ImportError
_____________ ERROR collecting pemjh/challenge066/challenge066.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000446A2E8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048C7CC8>)
function   = <function <lambda> at 0x000000000446A2E8>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import rootConvergentGenerator
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge066\challenge066.py:1: ImportError
_____________ ERROR collecting pemjh/challenge067/challenge067.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000446A048>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004822A08>)
function   = <function <lambda> at 0x000000000446A048>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import with_statement
    from os.path import dirname, abspath
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
abspath    = None
dirname    = None
with_statement = None

pemjh\challenge067\challenge067.py:9: ImportError
_____________ ERROR collecting pemjh/challenge069/challenge069.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000446A5F8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004771BC8>)
function   = <function <lambda> at 0x000000000446A5F8>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge069\challenge069.py:4: ImportError
_____________ ERROR collecting pemjh/challenge070/challenge070.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000446AF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000030EC708>)
function   = <function <lambda> at 0x000000000446AF28>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge070\challenge070.py:4: ImportError
_____________ ERROR collecting pemjh/challenge072/challenge072.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000444F278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004848E48>)
function   = <function <lambda> at 0x000000000444F278>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge072\challenge072.py:5: ImportError
_____________ ERROR collecting pemjh/challenge073/challenge073.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000444F438>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046F2F08>)
function   = <function <lambda> at 0x000000000444F438>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import ceil, floor
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None
ceil       = None
floor      = None

pemjh\challenge073\challenge073.py:6: ImportError
_____________ ERROR collecting pemjh/challenge075/challenge075.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000444F518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004850E48>)
function   = <function <lambda> at 0x000000000444F518>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge075\challenge075.py:1: ImportError
_____________ ERROR collecting pemjh/challenge077/challenge077.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000444F978>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002EA75C8>)
function   = <function <lambda> at 0x000000000444F978>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge077\challenge077.py:1: ImportError
_____________ ERROR collecting pemjh/challenge087/challenge087.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000478F048>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047BE5C8>)
function   = <function <lambda> at 0x000000000478F048>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge087\challenge087.py:4: ImportError
_____________ ERROR collecting pemjh/challenge092/challenge092.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000478FDD8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002F61888>)
function   = <function <lambda> at 0x000000000478FDD8>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge092\challenge092.py:4: ImportError
_____________ ERROR collecting pemjh/challenge104/challenge104.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002F69AC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000030F4308>)
function   = <function <lambda> at 0x0000000002F69AC8>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge104\challenge104.py:1: ImportError
_____________ ERROR collecting pemjh/challenge108/challenge108.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000460BAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004612548>)
function   = <function <lambda> at 0x000000000460BAC8>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge108\challenge108.py:1: ImportError
_____________ ERROR collecting pemjh/challenge110/challenge110.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044E8588>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044E3C08>)
function   = <function <lambda> at 0x00000000044E8588>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge110\challenge110.py:1: ImportError
_____________ ERROR collecting pemjh/challenge111/challenge111.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044E8908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000047C2908>)
function   = <function <lambda> at 0x00000000044E8908>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, roughPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge111\challenge111.py:1: ImportError
_____________ ERROR collecting pemjh/challenge113/challenge113.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000044E8C18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046F7988>)
function   = <function <lambda> at 0x00000000044E8C18>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import polytopicNumbers
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge113\challenge113.py:4: ImportError
_____________ ERROR collecting pemjh/challenge118/challenge118.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004660198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045E48C8>)
function   = <function <lambda> at 0x0000000004660198>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge118\challenge118.py:1: ImportError
_____________ ERROR collecting pemjh/challenge121/challenge121.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004660B38>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048FA808>)
function   = <function <lambda> at 0x0000000004660B38>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fact
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge121\challenge121.py:1: ImportError
_____________ ERROR collecting pemjh/challenge123/challenge123.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004858F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004789208>)
function   = <function <lambda> at 0x0000000004858F98>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge123\challenge123.py:1: ImportError
_____________ ERROR collecting pemjh/challenge124/challenge124.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004858048>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004929988>)
function   = <function <lambda> at 0x0000000004858048>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge124\challenge124.py:1: ImportError
_____________ ERROR collecting pemjh/challenge127/challenge127.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000048580B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004B60208>)
function   = <function <lambda> at 0x00000000048580B8>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import gcd, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge127\challenge127.py:1: ImportError
_____________ ERROR collecting pemjh/challenge128/challenge128.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004858668>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004B776C8>)
function   = <function <lambda> at 0x0000000004858668>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge128\challenge128.py:1: ImportError
_____________ ERROR collecting pemjh/challenge130/challenge130.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004858908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004B7DAC8>)
function   = <function <lambda> at 0x0000000004858908>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge130\challenge130.py:1: ImportError
_____________ ERROR collecting pemjh/challenge131/challenge131.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030D7F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004B7C648>)
function   = <function <lambda> at 0x00000000030D7F98>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge131\challenge131.py:1: ImportError
_____________ ERROR collecting pemjh/challenge132/challenge132.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030D7128>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044D28C8>)
function   = <function <lambda> at 0x00000000030D7128>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge132\challenge132.py:1: ImportError
_____________ ERROR collecting pemjh/challenge133/challenge133.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030D7828>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004646048>)
function   = <function <lambda> at 0x00000000030D7828>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge133\challenge133.py:1: ImportError
_____________ ERROR collecting pemjh/challenge134/challenge134.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030D7048>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048E7AC8>)
function   = <function <lambda> at 0x00000000030D7048>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge134\challenge134.py:1: ImportError
_____________ ERROR collecting pemjh/challenge136/challenge136.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030D7518>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000048A7508>)
function   = <function <lambda> at 0x00000000030D7518>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge136\challenge136.py:1: ImportError
_____________ ERROR collecting pemjh/challenge138/challenge138.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>
attrname = '_collected', function = <function <lambda> at 0x00000000030D7908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000002E9B088>)
function   = <function <lambda> at 0x00000000030D7908>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge138\challenge138.py:1: ImportError
_____________ ERROR collecting pemjh/challenge139/challenge139.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004916208>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000046D7CC8>)
function   = <function <lambda> at 0x0000000004916208>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge139\challenge139.py:1: ImportError
_____________ ERROR collecting pemjh/challenge174/challenge174.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004916128>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004674D88>)
function   = <function <lambda> at 0x0000000004916128>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge174\challenge174.py:1: ImportError
_____________ ERROR collecting pemjh/challenge183/challenge183.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004982A58>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044F2CC8>)
function   = <function <lambda> at 0x0000000004982A58>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import primeFactors
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge183\challenge183.py:1: ImportError
_____________ ERROR collecting pemjh/challenge187/challenge187.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004982C88>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004701848>)
function   = <function <lambda> at 0x0000000004982C88>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge187\challenge187.py:1: ImportError
_____________ ERROR collecting pemjh/challenge203/challenge203.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004982F98>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000044AEE48>)
function   = <function <lambda> at 0x0000000004982F98>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge203\challenge203.py:1: ImportError
_____________ ERROR collecting pemjh/challenge204/challenge204.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000497B6D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004736948>)
function   = <function <lambda> at 0x000000000497B6D8>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge204\challenge204.py:1: ImportError
_____________ ERROR collecting pemjh/challenge211/challenge211.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>
attrname = '_collected', function = <function <lambda> at 0x000000000497BAC8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000454E788>)
function   = <function <lambda> at 0x000000000497BAC8>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors, sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge211\challenge211.py:1: ImportError
_____________ ERROR collecting pemjh/challenge214/challenge214.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002EB5198>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004BF6848>)
function   = <function <lambda> at 0x0000000002EB5198>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes, primeFactors, phi
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge214\challenge214.py:1: ImportError
_____________ ERROR collecting pemjh/challenge231/challenge231.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002EB5278>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x00000000045355C8>)
function   = <function <lambda> at 0x0000000002EB5278>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge231\challenge231.py:1: ImportError
_____________ ERROR collecting pemjh/challenge234/challenge234.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000002EB5E48>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x000000000489BF48>)
function   = <function <lambda> at 0x0000000002EB5E48>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge234\challenge234.py:1: ImportError
_____________ ERROR collecting pemjh/challenge243/challenge243.py _____________

self = <CallInfo when='memocollect' exception: No module named utils.numbers>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils.numbers>
when       = 'memocollect'

.tox\py27\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>
attrname = '_collected', function = <function <lambda> at 0x0000000004528908>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils.numbers',), <traceback object at 0x0000000004BBEB88>)
function   = <function <lambda> at 0x0000000004528908>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\software_tools\python\python27_64\Lib\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py27\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

.tox\py27\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils.numbers

__builtins__ = <builtins>
__doc__    = None
__file__   = None
__name__   = None
__package__ = None

pemjh\challenge243\challenge243.py:1: ImportError
================================== FAILURES ===================================
______________________________ [pylint] setup.py ______________________________
C: 36, 0: No space allowed around keyword argument assignment
    name = "pemjh",
         ^ (bad-whitespace)
C: 37, 0: No space allowed around keyword argument assignment
    version = "0.0.1",
            ^ (bad-whitespace)
C: 38, 0: No space allowed around keyword argument assignment
    author = "Matthew Hussey",
           ^ (bad-whitespace)
C: 39, 0: No space allowed around keyword argument assignment
    author_email = "matthew.hussey@googlemail.com",
                 ^ (bad-whitespace)
C: 40, 0: No space allowed around keyword argument assignment
    description = ("Project euler (https://projecteuler.net/) challenge "
                ^ (bad-whitespace)
C: 42, 0: No space allowed around keyword argument assignment
    license = "None, private use by myself only",
            ^ (bad-whitespace)
C: 43, 0: No space allowed around keyword argument assignment
    keywords = "code challenge euler",
             ^ (bad-whitespace)
C: 44, 0: No space allowed around keyword argument assignment
    url = "none.non",
        ^ (bad-whitespace)
C: 45, 0: No space allowed around keyword argument assignment
    packages = ["pemjh"],
             ^ (bad-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
    long_description = read("README"),
                     ^ (bad-whitespace)
C: 50, 0: No space allowed around keyword argument assignment
    cmdclass = {"test": Tox},
             ^ (bad-whitespace)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing class docstring (missing-docstring)
F: 27, 8: Unable to import 'tox' (import-error)
W: 24, 8: Attribute 'test_suite' defined outside __init__ (attribute-defined-outside-init)
W: 20, 8: Attribute 'tox_args' defined outside __init__ (attribute-defined-outside-init)
W: 23, 8: Attribute 'test_args' defined outside __init__ (attribute-defined-outside-init)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\setup.py:6:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\setup.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:18:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:21:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:25:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:26:9: E265 block comment should start with '# '
D:\Development\pemjh\setup.py:36:9: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:36:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:12: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:14: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:13: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:19: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:18: E251 unexpected spaces around keyword / parameter equals

___________________________ [pylint] pemjh/main.py ____________________________
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 58, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  9, 0: No exception type(s) specified (bare-except)
F:  6, 4: Unable to import 'psyco' (import-error)
C: 12, 0: Invalid function name "testFunction" (invalid-name)
C: 12, 0: Invalid argument name "id" (invalid-name)
C: 12, 0: Invalid argument name "knownAnswer" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
W: 12,21: Redefining name 'func' from outer scope (line 43) (redefined-outer-name)
W: 12,17: Redefining built-in 'id' (redefined-builtin)
W: 12,27: Redefining name 'knownAnswer' from outer scope (line 46) (redefined-outer-name)
C: 30, 0: Invalid constant name "wholeTime" (invalid-name)
C: 32, 0: Invalid constant name "failures" (invalid-name)
C: 34, 0: Invalid constant name "nChallenges" (invalid-name)
C: 60, 0: Invalid constant name "wholeTime" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\main.py:13:15: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\main.py:32:18: W291 trailing whitespace
D:\Development\pemjh\pemjh\main.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\main.py:58:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge001/challenge001.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid constant name "upper" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  4,15: Used builtin function 'filter' (bad-builtin)
W:  4,15: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C:  6, 0: Invalid constant name "answer" (invalid-name)
W:  9, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge001\challenge001.py:9:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge002/challenge002.py _________________
C: 10, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "numRange" (invalid-name)
C: 10, 4: Invalid variable name "evenNums" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge003/challenge003.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 19,26: More than one statement on a single line (multiple-statements)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import math (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge003\challenge003.py:1:1: F401 'math' imported but unused
D:\Development\pemjh\pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge003\challenge003.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge004/challenge004.py _________________
C:  8, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 18, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 26, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 18,61: More than one statement on a single line (multiple-statements)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W: 36, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge004\challenge004.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge005/challenge005.py _________________
C: 12, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  3, 4: Redefining built-in 'max' (redefined-builtin)
C:  6, 8: Invalid variable name "n" (invalid-name)
C: 14,16: Invalid variable name "n" (invalid-name)
C: 28,23: More than one statement on a single line (multiple-statements)
C: 31, 8: Invalid variable name "n" (invalid-name)
C: 31,11: Invalid variable name "p" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge005\challenge005.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge006/challenge006.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W: 10, 4: Redefining built-in 'sum' (redefined-builtin)
W:  2, 4: Redefining built-in 'max' (redefined-builtin)
C:  4, 4: Invalid variable name "sumOfSquares" (invalid-name)
C:  7, 8: Invalid variable name "sumOfSquares" (invalid-name)
C: 13, 4: Invalid variable name "squareOfSums" (invalid-name)
C: 20, 0: Invalid constant name "answer" (invalid-name)
W: 23, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:23:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge007/challenge007.py _________________
C: 14, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'max' (redefined-builtin)
C: 13, 8: Invalid variable name "primeRange" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
W: 24, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge007\challenge007.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge008/challenge008.py _________________
C: 29, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'input' (redefined-builtin)
C: 26, 8: Invalid variable name "testPart" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
W: 44, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge008\challenge008.py:44:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge009/challenge009.py _________________
C:  8, 0: Exactly one space required after comma
    for a in range(1,(max / 3)):
                    ^ (bad-whitespace)
C: 11, 0: Exactly one space required after comma
        for b in range((a + 1),(a + 1 + (remainder / 2))):
                              ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  4, 4: Redefining built-in 'max' (redefined-builtin)
W:  5, 4: Redefining name 'answer' from outer scope (line 18) (redefined-outer-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C: 11,12: Invalid variable name "b" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge010/challenge010.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  6, 4: Redefining built-in 'max' (redefined-builtin)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ifilter imported from itertools (unused-import)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge010\challenge010.py:1:1: F401 'ifilter' imported but unused
D:\Development\pemjh\pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge010\challenge010.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge011/challenge011.py _________________
C:  2, 0: Line too long (1212/100) (line-too-long)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCols" (invalid-name)
C: 10, 8: Invalid variable name "currentRow" (invalid-name)
C: 12,12: Invalid variable name "nextChunk" (invalid-name)
C: 31,36: More than one statement on a single line (multiple-statements)
C: 38,40: More than one statement on a single line (multiple-statements)
C: 45,40: More than one statement on a single line (multiple-statements)
C: 52,36: More than one statement on a single line (multiple-statements)
W: 11,12: Unused variable 'index' (unused-variable)
R:  1, 0: Too many branches (16/12) (too-many-branches)
C: 58, 0: Invalid constant name "answer" (invalid-name)
W: 61, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:61:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge012/challenge012.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 15, 0: Invalid function name "triangleDivisors" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 16, 4: Invalid variable name "n" (invalid-name)
C: 17, 4: Invalid variable name "nOdd" (invalid-name)
C: 18, 4: Invalid variable name "nEven" (invalid-name)
C: 19, 4: Invalid variable name "knownDivisors" (invalid-name)
C: 24,12: Invalid variable name "nOdd" (invalid-name)
C: 27,12: Invalid variable name "nEven" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36,22: More than one statement on a single line (multiple-statements)
W: 38,12: Using possibly undefined loop variable 'n' (undefined-loop-variable)
W: 38,17: Using possibly undefined loop variable 'n' (undefined-loop-variable)
C: 40, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge013/challenge013.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:111, 0: Invalid constant name "answer" (invalid-name)
W:114, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:114:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge014/challenge014.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getChainSize" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "knownChains" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "knownChains" (invalid-name)
C: 31, 8: Invalid variable name "newChain" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge015/challenge015.py _________________
C:  7, 0: No space allowed around keyword argument assignment
def multiplierGen(n = 0):
                    ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "multiplierGen" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid function name "getRoutes" (invalid-name)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge016/challenge016.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge016\challenge016.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge017/challenge017.py _________________
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 37, 0: Trailing whitespace (trailing-whitespace)
C:103, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumberLength" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "hundredRep" (invalid-name)
C:  1, 0: Invalid argument name "andRep" (invalid-name)
C:  1, 0: Invalid argument name "thousandRep" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "tempN" (invalid-name)
C:  7, 8: Invalid variable name "numberRepresentation" (invalid-name)
C: 13,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 16,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 18,12: Invalid variable name "tempN" (invalid-name)
C: 22,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 29,16: Invalid variable name "tempN" (invalid-name)
C: 31,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 35,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 41, 0: Missing function docstring (missing-docstring)
C: 70, 4: Invalid variable name "knownInts" (invalid-name)
C:100, 4: Invalid variable name "endLine" (invalid-name)
W: 70, 4: Unused variable 'knownInts' (unused-variable)
W:100, 4: Unused variable 'endLine' (unused-variable)
C:106, 0: Invalid constant name "answer" (invalid-name)
W:109, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:5: F841 local variable 'knownInts' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:100:5: F841 local variable 'endLine' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:109:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge018/challenge018.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge018\challenge018.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge019/challenge019.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isLeapYear" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "getYearDays" (invalid-name)
C:  5, 0: Invalid argument name "y" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "getFirstJan" (invalid-name)
C: 11, 0: Invalid argument name "y" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "totalDays" (invalid-name)
C: 14, 8: Invalid variable name "totalDays" (invalid-name)
C: 17, 0: Invalid function name "monthStartDays" (invalid-name)
C: 17, 0: Invalid argument name "y" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "monthLengths" (invalid-name)
C: 25, 8: Invalid variable name "m" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "totalDays" (invalid-name)
C: 34, 8: Invalid variable name "y" (invalid-name)
C: 36,12: Invalid variable name "d" (invalid-name)
C: 38,16: Invalid variable name "totalDays" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
W: 45, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge020/challenge020.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge020\challenge020.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge021/challenge021.py _________________
C: 18, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
W: 11, 4: Redefining built-in 'dict' (redefined-builtin)
C: 12, 8: Invalid variable name "a" (invalid-name)
C: 14, 8: Invalid variable name "b" (invalid-name)
C: 15,12: Invalid variable name "d" (invalid-name)
C: 16,12: Invalid variable name "b" (invalid-name)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'

_________________ [pylint] pemjh/challenge022/challenge022.py _________________
C: 25, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getNames" (invalid-name)
C:  4, 0: Invalid argument name "fp" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7,21: Invalid variable name "f" (invalid-name)
C: 16, 0: Invalid function name "scoredNames" (invalid-name)
C: 16, 0: Invalid argument name "f" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 21,12: Invalid variable name "c" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 29, 8: Invalid variable name "s" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W: 37, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:37:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge023/challenge023.py _________________
C: 10, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "sumOfDivisors" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "p" (invalid-name)
C: 13,12: Invalid variable name "p" (invalid-name)
C: 23, 0: Invalid function name "isSum" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 0: Missing function docstring (missing-docstring)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge024/challenge024.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge024\challenge024.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge025/challenge025.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8,11: Invalid variable name "c" (invalid-name)
C:  9, 8: Invalid variable name "l" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge026/challenge026.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "biggestD" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C: 14,12: Invalid variable name "newSize" (invalid-name)
C: 18,16: Invalid variable name "biggestD" (invalid-name)
C: 20,12: Invalid variable name "newSize" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import string (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge026\challenge026.py:1:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge027/challenge027.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "aMax" (invalid-name)
C: 13, 4: Invalid variable name "bMax" (invalid-name)
C: 16, 4: Invalid variable name "bS" (invalid-name)
C: 17, 8: Invalid variable name "b" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "n" (invalid-name)
C: 21,16: Invalid variable name "f" (invalid-name)
C: 22,35: More than one statement on a single line (multiple-statements)
C: 23,16: Invalid variable name "n" (invalid-name)
C: 27,16: Invalid variable name "aMax" (invalid-name)
C: 28,16: Invalid variable name "bMax" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge027\challenge027.py:6:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge027\challenge027.py:35:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge028/challenge028.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge028\challenge028.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge029/challenge029.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "aLower" (invalid-name)
C:  3, 4: Invalid variable name "aUpper" (invalid-name)
C:  4, 4: Invalid variable name "bLower" (invalid-name)
C:  5, 4: Invalid variable name "bUpper" (invalid-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  9,12: Invalid variable name "b" (invalid-name)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge029\challenge029.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge030/challenge030.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "perDigit" (invalid-name)
C:  7, 4: Invalid variable name "grandTotal" (invalid-name)
C: 11,12: Invalid variable name "c" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "grandTotal" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge030\challenge030.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge031/challenge031.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPatternCount" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid constant name "answer" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
W: 22, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge031\challenge031.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge032/challenge032.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge032\challenge032.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge033/challenge033.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "totalNum" (invalid-name)
C:  9, 4: Invalid variable name "totalDen" (invalid-name)
C: 20,16: Invalid variable name "n1" (invalid-name)
C: 21,16: Invalid variable name "n2" (invalid-name)
C: 22,16: Invalid variable name "d3" (invalid-name)
C: 23,16: Invalid variable name "d4" (invalid-name)
C: 29,24: Invalid variable name "totalNum" (invalid-name)
C: 30,24: Invalid variable name "totalDen" (invalid-name)
C: 37,24: Invalid variable name "totalNum" (invalid-name)
C: 38,24: Invalid variable name "totalDen" (invalid-name)
C: 40, 4: Invalid variable name "totalNum" (invalid-name)
C: 40,14: Invalid variable name "totalDen" (invalid-name)
C: 44, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:47:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge034/challenge034.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "getLimit" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "factSum" (invalid-name)
C:  9, 4: Invalid variable name "factNine" (invalid-name)
C: 13, 8: Invalid variable name "factSum" (invalid-name)
C: 15,29: More than one statement on a single line (multiple-statements)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 8: Invalid variable name "iStr" (invalid-name)
C: 35, 8: Invalid variable name "iTotal" (invalid-name)
C: 36,12: Invalid variable name "c" (invalid-name)
C: 37,12: Invalid variable name "iTotal" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge035/challenge035.py _________________
C: 32, 0: Wrong continued indentation.
              if b == True and
              ^   | (bad-continuation)
C: 33, 0: Wrong continued indentation.
              ((p < 10) or not any(c in str(p) for c in disallowedChars))])
              ^   | (bad-continuation)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "nStr" (invalid-name)
C: 15, 8: Invalid variable name "nextString" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "disallowedChars" (invalid-name)
C: 35, 4: Invalid variable name "circularCount" (invalid-name)
C: 39, 8: Invalid variable name "circularList" (invalid-name)
C: 42, 8: Invalid variable name "allFound" (invalid-name)
C: 48,16: Invalid variable name "allFound" (invalid-name)
C: 51,12: Invalid variable name "circularCount" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused fact imported from utils.numbers (unused-import)
W:  5, 0: Unused sievedPrimes imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'fact' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'sievedPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
D:\Development\pemjh\pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge035\challenge035.py:58:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge036/challenge036.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getBinaryString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "binStr" (invalid-name)
C:  5, 8: Invalid variable name "binStr" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 18, 8: Invalid variable name "decStr" (invalid-name)
C: 21,12: Invalid variable name "binStr" (invalid-name)
W: 14, 4: Unused variable 'binary' (unused-variable)
W: 11, 4: Unused variable 'limit' (unused-variable)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W: 29, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge036\challenge036.py:11:5: F841 local variable 'limit' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:14:5: F841 local variable 'binary' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge037/challenge037.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "isTruncPrime" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 12,23: More than one statement on a single line (multiple-statements)
C: 13,45: More than one statement on a single line (multiple-statements)
C: 18,51: More than one statement on a single line (multiple-statements)
C: 23, 0: Missing function docstring (missing-docstring)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge038/challenge038.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "isPandigital" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "m" (invalid-name)
C: 12,11: Invalid variable name "l" (invalid-name)
C: 12,14: Invalid variable name "u" (invalid-name)
C: 13,12: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge038\challenge038.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge039/challenge039.py _________________
W: 18, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
W: 19, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numPerimeters" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "a" (invalid-name)
C: 16, 8: Invalid variable name "bLimit" (invalid-name)
C: 17,12: Invalid variable name "b" (invalid-name)
C: 18,11: Invalid variable name "c" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "highestVal" (invalid-name)
C: 30, 8: Invalid variable name "iCount" (invalid-name)
C: 33,12: Invalid variable name "highestVal" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge039\challenge039.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge040/challenge040.py _________________
C: 11, 0: No space allowed before bracket
        total *= int (str(currentValue)[index - currentN - 1])
                     ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "currentN" (invalid-name)
C:  5, 4: Invalid variable name "currentValue" (invalid-name)
C:  9,12: Invalid variable name "currentValue" (invalid-name)
C: 10,12: Invalid variable name "currentN" (invalid-name)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
D:\Development\pemjh\pemjh\challenge040\challenge040.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge041/challenge041.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
F:  6, 0: Unable to import 'utils.strings' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 15,36: More than one statement on a single line (multiple-statements)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge041\challenge041.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge042/challenge042.py _________________
C: 35, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "scoreWord" (invalid-name)
C:  4, 0: Invalid argument name "w" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "x" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12,62: Invalid variable name "f" (invalid-name)
C: 23, 8: Invalid variable name "nTriangleWords" (invalid-name)
C: 30,16: Invalid variable name "nTriangleWords" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge042\challenge042.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge043/challenge043.py _________________
C:  8, 0: Trailing whitespace (trailing-whitespace)
W: 19, 0: Bad indentation. Found 12 spaces, expected 8 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.strings' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge044/challenge044.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "isPent" (invalid-name)
C:  6, 0: Invalid argument name "p" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "n" (invalid-name)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "pk" (invalid-name)
C: 19, 8: Invalid variable name "performedOneStep" (invalid-name)
C: 20,12: Invalid variable name "pj" (invalid-name)
C: 21,12: Invalid variable name "diffPkPj" (invalid-name)
C: 22,45: More than one statement on a single line (multiple-statements)
C: 25,12: Invalid variable name "performedOneStep" (invalid-name)
C: 27,33: More than one statement on a single line (multiple-statements)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge044\challenge044.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge045/challenge045.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
W:  4, 0: Redefining built-in 'hex' (redefined-builtin)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "pentAndHex" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "p" (invalid-name)
C: 10, 4: Invalid variable name "h" (invalid-name)
C: 12, 8: Invalid variable name "pVal" (invalid-name)
C: 13, 8: Invalid variable name "hVal" (invalid-name)
C: 19,12: Invalid variable name "p" (invalid-name)
C: 21,12: Invalid variable name "h" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 26, 8: Redefining built-in 'next' (redefined-builtin)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge046/challenge046.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "hasCriteria" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "dSq" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "n" (invalid-name)
C: 25, 8: Invalid variable name "n" (invalid-name)
C: 26,36: More than one statement on a single line (multiple-statements)
C: 26,36: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge046\challenge046.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge047/challenge047.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "numPrimeFactors" (invalid-name)
C:  8, 0: Invalid argument name "nPrimes" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "n" (invalid-name)
C: 11, 8: Invalid variable name "pf" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Invalid function name "hasNumPrimes" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 20,30: More than one statement on a single line (multiple-statements)
C: 24, 0: Missing function docstring (missing-docstring)
W: 30, 4: Redefining name 'count' from outer scope (line 1) (redefined-outer-name)
C: 31, 8: Invalid variable name "p" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused count imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
D:\Development\pemjh\pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge048/challenge048.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid constant name "answer" (invalid-name)
W:  8, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge048\challenge048.py:8:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge049/challenge049.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 18, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 21,12: Invalid variable name "p1" (invalid-name)
C: 22,16: Invalid variable name "p2" (invalid-name)
C: 24,16: Invalid variable name "p3" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge049\challenge049.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge050/challenge050.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
W: 13, 4: Redefining name 'answer' from outer scope (line 26) (redefined-outer-name)
C:  9, 4: Invalid variable name "knownPrimes" (invalid-name)
C: 11, 4: Invalid variable name "nPrimes" (invalid-name)
C: 18,31: More than one statement on a single line (multiple-statements)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge050\challenge050.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge050\challenge050.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge051/challenge051.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "substitutePrimes" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid function name "has3SameDigits" (invalid-name)
C: 24, 0: Invalid argument name "n" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "w" (invalid-name)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
C: 39,12: Invalid variable name "w" (invalid-name)
C: 41,16: Invalid variable name "nPrimes" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge052/challenge052.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getSortedString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "x" (invalid-name)
C:  9, 8: Invalid variable name "x" (invalid-name)
C: 10, 8: Invalid variable name "xStr" (invalid-name)
C: 15,12: Invalid variable name "ix" (invalid-name)
C: 16,12: Invalid variable name "ixStr" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge053/challenge053.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge053\challenge053.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge054/challenge054.py _________________
C:122, 0: Trailing whitespace (trailing-whitespace)
C:131, 0: Trailing whitespace (trailing-whitespace)
C:133, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getDuplicateCounts" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "valCounts" (invalid-name)
C: 14, 0: Invalid function name "isStraight" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid function name "isFlush" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid function name "scoreHand" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 52, 8: Invalid variable name "c1" (invalid-name)
C: 52,12: Invalid variable name "c2" (invalid-name)
C: 53, 8: Invalid variable name "v1" (invalid-name)
C: 53,12: Invalid variable name "v2" (invalid-name)
R: 26, 0: Too many return statements (11/6) (too-many-return-statements)
R: 26, 0: Too many branches (15/12) (too-many-branches)
C: 96, 0: Invalid function name "compareHands" (invalid-name)
C: 96, 0: Invalid argument name "handOne" (invalid-name)
C: 96, 0: Invalid argument name "handTwo" (invalid-name)
C: 96, 0: Missing function docstring (missing-docstring)
C:100, 4: Invalid variable name "handOneScore" (invalid-name)
C:100,18: Invalid variable name "handTwoScore" (invalid-name)
C:106,12: Invalid variable name "c1" (invalid-name)
C:106,16: Invalid variable name "c2" (invalid-name)
C:114, 0: Missing function docstring (missing-docstring)
C:115, 4: Invalid variable name "faceConvert" (invalid-name)
C:118, 4: Invalid variable name "nHandOneWins" (invalid-name)
C:119,62: Invalid variable name "f" (invalid-name)
C:120,12: Invalid variable name "l" (invalid-name)
C:129,16: Invalid variable name "nHandOneWins" (invalid-name)
C:133, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace

_________________ [pylint] pemjh/challenge055/challenge055.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "becomesPalindrome" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "workingN" (invalid-name)
C:  6, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
D:\Development\pemjh\pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge055\challenge055.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge056/challenge056.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "a" (invalid-name)
C:  4,12: Invalid variable name "b" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
W: 16, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge056\challenge056.py:16:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge057/challenge057.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTopHeavy" (invalid-name)
C:  5, 8: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  8,15: Invalid variable name "d" (invalid-name)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 10,11: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nTopHeavy" (invalid-name)
W:  7,12: Unused variable 'i' (unused-variable)
C: 17, 0: Invalid constant name "answer" (invalid-name)
W: 20, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge057\challenge057.py:20:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge058/challenge058.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nPrimes" (invalid-name)
C: 13, 4: Invalid variable name "primeChecker" (invalid-name)
C: 22,16: Invalid variable name "nPrimes" (invalid-name)
W:  9, 4: Unused variable 'total' (unused-variable)
W: 18,12: Unused variable 'j' (unused-variable)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
D:\Development\pemjh\pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge059/challenge059.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 27,64: Invalid variable name "f" (invalid-name)
C: 29,12: Invalid variable name "l" (invalid-name)
W: 48, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge060/challenge060.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 64, 0: Line too long (118/100) (line-too-long)
C: 69, 0: Trailing whitespace (trailing-whitespace)
C: 85, 0: Line too long (141/100) (line-too-long)
C: 94, 0: Trailing whitespace (trailing-whitespace)
C: 95, 0: Trailing whitespace (trailing-whitespace)
C: 97, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid constant name "primeSet" (invalid-name)
C:  8, 0: Invalid constant name "maxPrime" (invalid-name)
C: 10, 0: Invalid function name "getNumLength" (invalid-name)
C: 10, 0: Invalid argument name "n" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 14, 8: Invalid variable name "l" (invalid-name)
C: 17, 0: Invalid argument name "m" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "isConcatPrime" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "newFirst" (invalid-name)
C: 25, 4: Invalid variable name "newLast" (invalid-name)
C: 29, 0: Invalid function name "getPrimePairs" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "nPrimes" (invalid-name)
C: 33, 8: Invalid variable name "m" (invalid-name)
C: 34, 8: Invalid variable name "p" (invalid-name)
C: 38,12: Invalid variable name "n" (invalid-name)
C: 39,12: Invalid variable name "q" (invalid-name)
C: 47, 0: Invalid function name "nextDigits" (invalid-name)
C: 47, 0: Invalid argument name "nToFind" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "currentSum" (invalid-name)
C: 49, 4: Invalid variable name "currentSolution" (invalid-name)
C: 50, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 61,16: Invalid variable name "foundSolution" (invalid-name)
C: 64,16: Invalid variable name "foundSolution" (invalid-name)
C: 67,16: Invalid variable name "currentSolution" (invalid-name)
C: 68,16: Invalid variable name "currentSolutionSum" (invalid-name)
C: 71, 0: Invalid function name "nextDigitsDict" (invalid-name)
C: 71, 0: Invalid argument name "nToFind" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 72, 4: Invalid variable name "currentSum" (invalid-name)
C: 73, 4: Invalid variable name "currentSolution" (invalid-name)
C: 74, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 77, 8: Invalid variable name "p" (invalid-name)
C: 83,12: Invalid variable name "foundSolution" (invalid-name)
C: 86,12: Invalid variable name "newPotential" (invalid-name)
C: 87,12: Invalid variable name "foundSolution" (invalid-name)
C: 92,12: Invalid variable name "currentSolution" (invalid-name)
C: 93,12: Invalid variable name "currentSolutionSum" (invalid-name)
C: 98, 0: Missing function docstring (missing-docstring)
W:109, 4: Redefining name 'answer' from outer scope (line 116) (redefined-outer-name)
C:116, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace

_________________ [pylint] pemjh/challenge061/challenge061.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "hasDuplicates" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "eachInList" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 17,12: Invalid variable name "newNums" (invalid-name)
C: 18,12: Invalid variable name "newLists" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
W: 51, 4: Redefining built-in 'oct' (redefined-builtin)
W: 43, 4: Redefining built-in 'hex' (redefined-builtin)
W: 55, 4: Redefining built-in 'all' (redefined-builtin)
R: 24, 0: Too many local variables (27/15) (too-many-locals)
C: 28, 4: Invalid variable name "allLists" (invalid-name)
C: 35, 4: Invalid variable name "sq" (invalid-name)
C: 56, 4: Invalid variable name "d" (invalid-name)
C: 57, 8: Invalid variable name "n" (invalid-name)
C: 64, 8: Invalid variable name "n" (invalid-name)
C: 70,16: Invalid variable name "l" (invalid-name)
C: 76, 8: Invalid variable name "n1" (invalid-name)
C: 79,12: Invalid variable name "n2" (invalid-name)
C: 82,16: Invalid variable name "n3" (invalid-name)
C: 85,20: Invalid variable name "n4" (invalid-name)
C: 88,24: Invalid variable name "n5" (invalid-name)
C: 91,28: Invalid variable name "n6" (invalid-name)
C: 94,32: Invalid variable name "n7" (invalid-name)
R: 24, 0: Too many branches (17/12) (too-many-branches)
C:101, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'

_________________ [pylint] pemjh/challenge062/challenge062.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "n" (invalid-name)
C:  8, 8: Invalid variable name "potentialAnswer" (invalid-name)
C: 19,20: Invalid variable name "nCubes" (invalid-name)
C: 21,12: Invalid variable name "nCubes" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge063/challenge063.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14,26: More than one statement on a single line (multiple-statements)
C: 20,29: More than one statement on a single line (multiple-statements)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge064/challenge064.py _________________
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getPeriodLength" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "pathGen" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 4: Invalid variable name "nOdd" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 32,12: Invalid variable name "nOdd" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge065/challenge065.py _________________
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "nextDen" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused divisors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge065\challenge065.py:4:1: F401 'divisors' imported but unused
D:\Development\pemjh\pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge066/challenge066.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "diophantineX" (invalid-name)
C:  8, 0: Invalid argument name "d" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "x" (invalid-name)
C: 10,11: Invalid variable name "y" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)

_________________ [pylint] pemjh/challenge067/challenge067.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  9, 0: Unable to import 'utils.numbers' (import-error)
C: 11, 0: Missing function docstring (missing-docstring)
W: 14,65: Redefining built-in 'file' (redefined-builtin)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge067\challenge067.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge068/challenge068.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPairs" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "getSpokes" (invalid-name)
C:  7, 0: Invalid argument name "startIndex" (invalid-name)
C:  7, 0: Invalid argument name "nSpokes" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 18,16: Invalid variable name "nextSpokes" (invalid-name)
C: 19,16: Invalid variable name "y" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 54,20: Unused variable 'move' (unused-variable)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)

_________________ [pylint] pemjh/challenge069/challenge069.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "sp" (invalid-name)
C: 11, 4: Invalid variable name "nPhi" (invalid-name)
C: 12,11: Invalid variable name "n" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge070/challenge070.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "isPermutation" (invalid-name)
C:  8, 0: Invalid argument name "a" (invalid-name)
C:  8, 0: Invalid argument name "b" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 17,11: Invalid variable name "p" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused import string (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge071/challenge071.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "targetNum" (invalid-name)
C:  5, 4: Invalid variable name "targetDen" (invalid-name)
C:  8, 4: Invalid variable name "bestNum" (invalid-name)
C:  9, 4: Invalid variable name "bestDen" (invalid-name)
C: 13, 8: Invalid variable name "highNum" (invalid-name)
C: 14, 8: Invalid variable name "lowNum" (invalid-name)
C: 18,55: More than one statement on a single line (multiple-statements)
C: 20,12: Invalid variable name "leftSide" (invalid-name)
C: 21,12: Invalid variable name "rightSide" (invalid-name)
C: 23,16: Invalid variable name "bestNum" (invalid-name)
C: 23,25: Invalid variable name "bestDen" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge072/challenge072.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge073/challenge073.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "shareDivisors" (invalid-name)
C:  8, 0: Invalid argument name "n1" (invalid-name)
C:  8, 0: Invalid argument name "n2" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "d" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "upperNum" (invalid-name)
C: 19, 4: Invalid variable name "upperDen" (invalid-name)
C: 20, 4: Invalid variable name "lowerNum" (invalid-name)
C: 21, 4: Invalid variable name "lowerDen" (invalid-name)
C: 25, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 26, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 28, 8: Invalid variable name "upperLimit" (invalid-name)
C: 29, 8: Invalid variable name "upperLimit" (invalid-name)
C: 31, 8: Invalid variable name "rangeLimits" (invalid-name)
W: 31, 8: Unused variable 'rangeLimits' (unused-variable)
C: 39, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:31:9: F841 local variable 'rangeLimits' is assigned to but never used

_________________ [pylint] pemjh/challenge074/challenge074.py _________________
C:  2, 0: Line too long (109/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "factSum" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "chainSize" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "w" (invalid-name)
C:  8, 4: Invalid variable name "firstW" (invalid-name)
C:  9, 4: Invalid variable name "routeLen" (invalid-name)
C: 17,12: Invalid variable name "routeLen" (invalid-name)
C: 19,12: Invalid variable name "w" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 27, 4: Unused variable 'target' (unused-variable)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
D:\Development\pemjh\pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:27:5: F841 local variable 'target' is assigned to but never used

_________________ [pylint] pemjh/challenge075/challenge075.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "l" (invalid-name)
C:  8,15: Invalid variable name "a" (invalid-name)
C:  8,18: Invalid variable name "b" (invalid-name)
C:  8,21: Invalid variable name "c" (invalid-name)
C: 21, 4: Invalid variable name "l" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge076/challenge076.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numBreakDowns" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  9, 8: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nBreakDowns" (invalid-name)
C: 12,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 14,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge077/challenge077.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "pc" (invalid-name)
C: 17,12: Invalid variable name "a" (invalid-name)
C: 18,12: Invalid variable name "b" (invalid-name)
C: 21,16: Invalid variable name "abSums" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)

_________________ [pylint] pemjh/challenge078/challenge078.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
W:  6, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W:  7, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W: 15, 0: Found indentation with tabs instead of spaces (mixed-indentation)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "n" (invalid-name)
C:  3, 4: Invalid variable name "p" (invalid-name)
C:  6, 7: Invalid variable name "s" (invalid-name)
C: 10,16: Invalid variable name "s" (invalid-name)
C: 13,16: Invalid variable name "s" (invalid-name)
C: 17, 8: Invalid variable name "m" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge079/challenge079.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
W:  2, 0: Unused import string (unused-import)
W: 14, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge079\challenge079.py:2:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge079\challenge079.py:14:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge080/challenge080.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "buildRoot" (invalid-name)
C:  3, 0: Invalid argument name "sq" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W: 14, 4: Redefining name 'answer' from outer scope (line 36) (redefined-outer-name)
W: 18, 8: Redefining built-in 'next' (redefined-builtin)
C:  5, 4: Invalid function name "getNextNum" (invalid-name)
C:  5, 4: Missing function docstring (missing-docstring)
W:  5,19: Unused argument 'target' (unused-argument)
C: 13, 4: Invalid variable name "prevNum" (invalid-name)
C: 24, 8: Invalid variable name "prevNum" (invalid-name)
W: 16, 8: Unused variable 'i' (unused-variable)
C: 28, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge081/challenge081.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "addRows" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "r1" (invalid-name)
C:  7, 8: Invalid variable name "r2" (invalid-name)
C: 10,12: Invalid variable name "i1" (invalid-name)
C: 11,12: Invalid variable name "i2" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 21,63: Invalid variable name "f" (invalid-name)
C: 22, 8: Invalid variable name "tr" (invalid-name)
C: 26,12: Invalid variable name "n" (invalid-name)
C: 26,15: Invalid variable name "l" (invalid-name)
W: 28,26: Using possibly undefined loop variable 'i' (undefined-loop-variable)
C: 39, 4: Invalid variable name "tr" (invalid-name)
C: 43, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge082/challenge082.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "combineColumns" (invalid-name)
C:  5, 0: Invalid argument name "c1" (invalid-name)
C:  5, 0: Invalid argument name "c2" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "downRow" (invalid-name)
C: 11, 8: Invalid variable name "v1" (invalid-name)
C: 11,12: Invalid variable name "v2" (invalid-name)
C: 23, 4: Invalid variable name "newRow" (invalid-name)
C: 26, 8: Invalid variable name "v1" (invalid-name)
C: 26,12: Invalid variable name "v2" (invalid-name)
C: 39, 0: Missing function docstring (missing-docstring)
C: 42,23: Invalid variable name "f" (invalid-name)
W: 44,16: Used builtin function 'map' (bad-builtin)
W: 48,26: Lambda may not be necessary (unnecessary-lambda)
C: 50, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused izip imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge082\challenge082.py:3:1: F401 'izip' imported but unused
D:\Development\pemjh\pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge083/challenge083.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getGrid" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6,63: Invalid variable name "f" (invalid-name)
C:  9,12: Invalid variable name "nextLine" (invalid-name)
C: 16, 0: Invalid function name "compareToProcess" (invalid-name)
C: 16, 0: Invalid argument name "m" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 27, 0: Missing function docstring (missing-docstring)
W: 35,11: Used builtin function 'map' (bad-builtin)
W: 35,11: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 35,27: Used builtin function 'map' (bad-builtin)
W: 35,27: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C: 38, 4: Invalid variable name "toProcess" (invalid-name)
C: 45, 8: Invalid variable name "x" (invalid-name)
C: 45,11: Invalid variable name "y" (invalid-name)
C: 55,12: Invalid variable name "nx" (invalid-name)
C: 55,16: Invalid variable name "ny" (invalid-name)
C: 56,12: Invalid variable name "newSquare" (invalid-name)
C: 59,12: Invalid variable name "newLength" (invalid-name)
W: 40, 4: Unused variable 'processed' (unused-variable)
C: 77, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge083\challenge083.py:40:5: F841 local variable 'processed' is assigned to but never used
D:\Development\pemjh\pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'

_________________ [pylint] pemjh/challenge084/challenge084.py _________________
C:  8, 0: No space allowed around keyword argument assignment
def chanceCardMove(current, prev = [0]):
                                 ^ (bad-whitespace)
C: 52, 0: No space allowed around keyword argument assignment
def communityChestCardMove(current, prev = [0]):
                                         ^ (bad-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C: 77, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:100, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "rollDice" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  8, 0: Dangerous default value [] as argument (dangerous-default-value)
C:  8, 0: Invalid function name "chanceCardMove" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
R:  8, 0: Too many return statements (13/6) (too-many-return-statements)
R:  8, 0: Too many branches (14/12) (too-many-branches)
W: 52, 0: Dangerous default value [] as argument (dangerous-default-value)
C: 52, 0: Invalid function name "communityChestCardMove" (invalid-name)
C: 52, 0: Missing function docstring (missing-docstring)
C: 68, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "doubleCount" (invalid-name)
C: 85,12: Invalid variable name "doubleCount" (invalid-name)
C: 87,12: Invalid variable name "doubleCount" (invalid-name)
C: 94,12: Invalid variable name "doubleCount" (invalid-name)
C:111, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace

_________________ [pylint] pemjh/challenge085/challenge085.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numRects" (invalid-name)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Invalid argument name "w" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "rh" (invalid-name)
C:  5,12: Invalid variable name "rw" (invalid-name)
C:  6,12: Invalid variable name "numAcross" (invalid-name)
C:  7,12: Invalid variable name "numDown" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 32,16: Invalid variable name "areaRectangles" (invalid-name)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge086/challenge086.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def isInt(a, msq, sqLib, found = list()):
                               ^ (bad-whitespace)
C:  2, 0: Unnecessary parens after 'return' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value list() (__builtin__.list) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "isInt" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "sqLib" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  1,25: Unused argument 'found' (unused-argument)
C:  4, 0: Invalid function name "getNumPairs" (invalid-name)
C:  4, 0: Invalid argument name "pairSum" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nPairs" (invalid-name)
C:  8, 4: Invalid variable name "a" (invalid-name)
C:  9, 4: Invalid variable name "b" (invalid-name)
C: 11, 8: Invalid variable name "a" (invalid-name)
C: 12, 8: Invalid variable name "b" (invalid-name)
C: 16,12: Invalid variable name "nPairs" (invalid-name)
C: 19, 0: Invalid function name "getStepSize" (invalid-name)
C: 19, 0: Invalid argument name "m" (invalid-name)
C: 19, 0: Invalid argument name "sqLib" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "nStep" (invalid-name)
W: 25, 4: Unreachable code (unreachable)
C: 27, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "sqLimit" (invalid-name)
C: 33, 4: Invalid variable name "m" (invalid-name)
C: 36, 8: Invalid variable name "m" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge087/challenge087.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sqLimit" (invalid-name)
C: 13, 4: Invalid variable name "sqPrimes" (invalid-name)
C: 16, 4: Invalid variable name "cuLimit" (invalid-name)
C: 17, 4: Invalid variable name "cuPrimes" (invalid-name)
C: 20, 4: Invalid variable name "foLimit" (invalid-name)
C: 21, 4: Invalid variable name "foPrimes" (invalid-name)
C: 23, 4: Invalid variable name "nAnswers" (invalid-name)
C: 24, 8: Invalid variable name "s" (invalid-name)
C: 25,12: Invalid variable name "c" (invalid-name)
C: 26,12: Invalid variable name "sc" (invalid-name)
C: 29,16: Invalid variable name "f" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge087\challenge087.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge088/challenge088.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def findPossibleProducts(limit, known = dict()):
                                      ^ (bad-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "findPossibleProducts" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12,20: Invalid variable name "s" (invalid-name)
C: 12,23: Invalid variable name "d" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 25, 8: Invalid variable name "pr" (invalid-name)
C: 25,12: Invalid variable name "s" (invalid-name)
C: 25,15: Invalid variable name "d" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ceil imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge088\challenge088.py:1:1: F401 'ceil' imported but unused
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace

_________________ [pylint] pemjh/challenge089/challenge089.py _________________
C: 56, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C: 17, 0: Invalid function name "convertChar" (invalid-name)
C: 17, 0: Invalid argument name "c" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
R: 17, 0: Too many return statements (7/6) (too-many-return-statements)
C: 33, 0: Invalid function name "decypherNumeral" (invalid-name)
C: 33, 0: Invalid argument name "s" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "currentTotal" (invalid-name)
C: 38, 8: Invalid variable name "v" (invalid-name)
C: 41,12: Invalid variable name "currentTotal" (invalid-name)
C: 43,12: Invalid variable name "currentTotal" (invalid-name)
C: 46,12: Invalid variable name "currentTotal" (invalid-name)
C: 53, 0: Invalid function name "getNumeral" (invalid-name)
C: 53, 0: Invalid argument name "n" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 61,13: Invalid variable name "c" (invalid-name)
C: 62, 8: Invalid variable name "nDiv" (invalid-name)
C: 67, 0: Invalid function name "getRomanNumeralSaving" (invalid-name)
C: 67, 0: Invalid argument name "s" (invalid-name)
C: 67, 0: Missing function docstring (missing-docstring)
C: 69, 4: Invalid variable name "preLength" (invalid-name)
C: 75, 4: Invalid variable name "newNumeral" (invalid-name)
C: 76, 4: Invalid variable name "newLength" (invalid-name)
C: 81, 0: Missing function docstring (missing-docstring)
C: 83,62: Invalid variable name "f" (invalid-name)
C: 87, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
D:\Development\pemjh\pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge090/challenge090.py _________________
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 78, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "get6Combs" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "c6" (invalid-name)
C: 10, 8: Invalid variable name "i6" (invalid-name)
C: 15, 8: Invalid variable name "i6" (invalid-name)
C: 20, 0: Invalid function name "fillRemaining" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid function name "validAddition" (invalid-name)
C: 29, 0: Invalid argument name "newFace" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 35, 0: Invalid function name "amendCubesForSquare" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "newCube1" (invalid-name)
C: 56, 8: Invalid variable name "newCube0" (invalid-name)
C: 62, 4: Invalid variable name "newCube0" (invalid-name)
C: 63, 4: Invalid variable name "newCube1" (invalid-name)
C: 71, 0: Invalid function name "buildCubes" (invalid-name)
C: 71, 0: Invalid argument name "squaresLeft" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nextSquare" (invalid-name)
C: 77, 4: Invalid variable name "suitableCubes" (invalid-name)
C:109,16: Invalid variable name "c0" (invalid-name)
C:110,20: Invalid variable name "c1" (invalid-name)
R: 71, 0: Too many branches (13/12) (too-many-branches)
C:116, 0: Missing function docstring (missing-docstring)
C:117, 4: Invalid variable name "squareNumbers" (invalid-name)
C:119, 4: Invalid variable name "possibleNumbers" (invalid-name)
C:125, 8: Invalid variable name "c" (invalid-name)
W:119, 4: Unused variable 'possibleNumbers' (unused-variable)
W:125, 8: Unused variable 'c' (unused-variable)
C:129, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:119:5: F841 local variable 'possibleNumbers' is assigned to but never used

_________________ [pylint] pemjh/challenge091/challenge091.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "bruteForce" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTriangles" (invalid-name)
C:  5, 8: Invalid variable name "x1" (invalid-name)
C:  6,12: Invalid variable name "y1" (invalid-name)
C:  9,16: Invalid variable name "nTriangles" (invalid-name)
C: 12,16: Invalid variable name "nTriangles" (invalid-name)
C: 15,20: Invalid variable name "x2" (invalid-name)
C: 16,24: Invalid variable name "y2" (invalid-name)
C: 29,32: Invalid variable name "nTriangles" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "gridSize" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge092/challenge092.py _________________
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 87, 0: Trailing whitespace (trailing-whitespace)
C:112, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Invalid function name "getDigits" (invalid-name)
C:  6, 0: Invalid argument name "n" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "workingN" (invalid-name)
C: 11, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 20, 8: Invalid variable name "workingN" (invalid-name)
C: 29,20: Invalid variable name "d" (invalid-name)
C: 31,16: Invalid variable name "workingN" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "n" (invalid-name)
C: 41, 8: Invalid variable name "workingN" (invalid-name)
C: 45,12: Invalid variable name "workingN" (invalid-name)
C: 46,19: Invalid variable name "c" (invalid-name)
C: 52,12: Invalid variable name "workingN" (invalid-name)
W: 42, 8: Unused variable 'route' (unused-variable)
C: 58, 0: Invalid function name "buildNumber" (invalid-name)
C: 58, 0: Missing function docstring (missing-docstring)
C: 61, 0: Missing function docstring (missing-docstring)
C: 73, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "prevI" (invalid-name)
C: 75, 4: Invalid variable name "nI" (invalid-name)
C: 80,12: Invalid variable name "nI" (invalid-name)
C: 83,12: Invalid variable name "prevI" (invalid-name)
C: 84,12: Invalid variable name "nI" (invalid-name)
C: 90, 0: Invalid function name "squareVal" (invalid-name)
C: 90, 0: Missing function docstring (missing-docstring)
C: 91, 4: Invalid variable name "n" (invalid-name)
C: 96, 8: Invalid variable name "n" (invalid-name)
C:100, 0: Missing function docstring (missing-docstring)
C:101, 4: Invalid variable name "n" (invalid-name)
C:108,12: Invalid variable name "n" (invalid-name)
C:110, 0: Missing function docstring (missing-docstring)
C:111, 4: Invalid variable name "nDigits" (invalid-name)
C:120, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:42:9: F841 local variable 'route' is assigned to but never used
D:\Development\pemjh\pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:123:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge093/challenge093.py _________________
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 96, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nLeft" (invalid-name)
C: 12, 0: Invalid argument name "a" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "op" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid argument name "l" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "v" (invalid-name)
C: 34, 0: Invalid function name "equatedNumbers" (invalid-name)
C: 34, 0: Invalid argument name "a" (invalid-name)
C: 34, 0: Invalid argument name "b" (invalid-name)
C: 34, 0: Invalid argument name "c" (invalid-name)
C: 34, 0: Invalid argument name "d" (invalid-name)
C: 34, 0: Missing function docstring (missing-docstring)
W: 40, 8: No exception type(s) specified (bare-except)
C: 39,13: More than one statement on a single line (multiple-statements)
C: 40,16: More than one statement on a single line (multiple-statements)
W: 44, 8: No exception type(s) specified (bare-except)
C: 43,13: More than one statement on a single line (multiple-statements)
C: 44,16: More than one statement on a single line (multiple-statements)
W: 48, 8: No exception type(s) specified (bare-except)
C: 47,13: More than one statement on a single line (multiple-statements)
C: 48,16: More than one statement on a single line (multiple-statements)
W: 52, 8: No exception type(s) specified (bare-except)
C: 51,13: More than one statement on a single line (multiple-statements)
C: 52,16: More than one statement on a single line (multiple-statements)
W: 56, 8: No exception type(s) specified (bare-except)
C: 55,13: More than one statement on a single line (multiple-statements)
C: 56,16: More than one statement on a single line (multiple-statements)
C: 60, 0: Missing function docstring (missing-docstring)
C: 68, 8: Invalid variable name "a" (invalid-name)
C: 69,12: Invalid variable name "b" (invalid-name)
C: 70,16: Invalid variable name "c" (invalid-name)
C: 71,20: Invalid variable name "d" (invalid-name)
C: 77,28: Invalid variable name "n" (invalid-name)
W: 90,19: Using possibly undefined loop variable 'd' (undefined-loop-variable)
W: 92,15: Using possibly undefined loop variable 'c' (undefined-loop-variable)
W: 94,11: Using possibly undefined loop variable 'b' (undefined-loop-variable)
C: 99, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge094/challenge094.py _________________
C: 11, 0: Exactly one space required after comma
    prev_2 = (4,  0)
               ^ (bad-whitespace)
C: 12, 0: Exactly one space required after comma
    prev_1 = (15,  1)
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "n" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
W: 38,12: Redefining built-in 'long' (redefined-builtin)
C: 31, 8: Invalid variable name "c" (invalid-name)
C: 33, 8: Invalid variable name "rt" (invalid-name)
C: 50, 0: Invalid constant name "desc" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge095/challenge095.py _________________
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 47, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid function name "chainLengths" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "x" (invalid-name)
C: 38,12: Invalid variable name "lChain" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge096/challenge096.py _________________
C:104, 0: Trailing whitespace (trailing-whitespace)
C:120, 0: Line too long (150/100) (line-too-long)
C:228, 0: Trailing whitespace (trailing-whitespace)
C:240, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  6, 0: Invalid function name "sortSquareLengths" (invalid-name)
C:  6, 0: Invalid argument name "a" (invalid-name)
C:  6, 0: Invalid argument name "b" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "la" (invalid-name)
C:  8, 4: Invalid variable name "lb" (invalid-name)
C: 16, 0: Missing class docstring (missing-docstring)
C: 16, 0: Old-style class defined. (old-style-class)
C: 20, 4: Invalid argument name "s" (invalid-name)
W: 23,50: Unused variable 'i' (unused-variable)
C: 36, 4: Invalid method name "__loadData" (invalid-name)
C: 36, 4: Invalid argument name "s" (invalid-name)
C: 36, 4: Missing method docstring (missing-docstring)
C: 40,12: Invalid variable name "r" (invalid-name)
C: 42,16: Invalid variable name "c" (invalid-name)
C: 46, 4: Invalid method name "__getBox" (invalid-name)
C: 46, 4: Invalid argument name "r" (invalid-name)
C: 46, 4: Invalid argument name "c" (invalid-name)
C: 46, 4: Missing method docstring (missing-docstring)
C: 47, 8: Invalid function name "getStartIndex" (invalid-name)
C: 47, 8: Missing function docstring (missing-docstring)
C: 55, 8: Invalid variable name "rowStart" (invalid-name)
C: 57,12: Invalid variable name "columnStart" (invalid-name)
C: 61, 4: Invalid method name "__removeValueFromList" (invalid-name)
C: 61, 4: Invalid argument name "l" (invalid-name)
C: 61, 4: Missing method docstring (missing-docstring)
C: 62, 8: Invalid variable name "nRemoved" (invalid-name)
C: 64,12: Invalid variable name "sq" (invalid-name)
C: 66,16: Invalid variable name "nRemoved" (invalid-name)
R: 61, 4: Method could be a function (no-self-use)
C: 71, 4: Invalid method name "__setValue" (invalid-name)
C: 71, 4: Invalid argument name "r" (invalid-name)
C: 71, 4: Invalid argument name "c" (invalid-name)
C: 71, 4: Missing method docstring (missing-docstring)
C: 85, 8: Invalid variable name "sq" (invalid-name)
C: 96, 4: Invalid method name "__getAllBlocks" (invalid-name)
C: 96, 4: Missing method docstring (missing-docstring)
C:100,12: Invalid variable name "r" (invalid-name)
C:101,16: Invalid variable name "c" (invalid-name)
C:107, 4: Invalid method name "__processCompletedSquares" (invalid-name)
C:107, 4: Missing method docstring (missing-docstring)
C:110,12: Invalid variable name "r" (invalid-name)
C:111,16: Invalid variable name "sq" (invalid-name)
C:117, 4: Invalid method name "__processGroups" (invalid-name)
C:117, 4: Missing method docstring (missing-docstring)
C:124,16: Invalid variable name "sq" (invalid-name)
C:131,24: Invalid variable name "lSq" (invalid-name)
C:137,28: Invalid variable name "nRemoved" (invalid-name)
C:148, 4: Invalid method name "__getLocation" (invalid-name)
C:148, 4: Invalid argument name "sq" (invalid-name)
C:148, 4: Missing method docstring (missing-docstring)
C:150,12: Invalid variable name "r" (invalid-name)
C:151,16: Invalid variable name "c" (invalid-name)
C:157, 4: Invalid method name "__processOnlyInOneSquare" (invalid-name)
C:157, 4: Missing method docstring (missing-docstring)
C:176, 4: Missing method docstring (missing-docstring)
C:178,12: Invalid variable name "sRow" (invalid-name)
C:178,18: Invalid variable name "tRow" (invalid-name)
W:178,30: Access to a protected member __rows of a client class (protected-access)
C:179,16: Invalid variable name "sSquare" (invalid-name)
C:179,25: Invalid variable name "tSquare" (invalid-name)
C:183, 4: Missing method docstring (missing-docstring)
C:184, 8: Invalid variable name "progressMade" (invalid-name)
C:187,12: Invalid variable name "progressMade" (invalid-name)
C:189,12: Invalid variable name "progressMade" (invalid-name)
C:191,12: Invalid variable name "progressMade" (invalid-name)
C:195,12: Invalid variable name "unsolvedSquares" (invalid-name)
C:196,16: Invalid variable name "r" (invalid-name)
C:197,20: Invalid variable name "c" (invalid-name)
C:205,16: Invalid variable name "sq" (invalid-name)
W:211,20: Access to a protected member __setValue of a client class (protected-access)
W:214,24: Access to a protected member __solve of a client class (protected-access)
C:223, 4: Missing method docstring (missing-docstring)
C:224,12: Invalid variable name "r" (invalid-name)
C:225,16: Invalid variable name "sq" (invalid-name)
C:230, 4: Missing method docstring (missing-docstring)
C:231,12: Invalid variable name "r" (invalid-name)
C:232,16: Invalid variable name "sq" (invalid-name)
W:244, 8: Redefining built-in 'repr' (redefined-builtin)
C:245,12: Invalid variable name "r" (invalid-name)
C:247,16: Invalid variable name "sq" (invalid-name)
C:249,16: Invalid variable name "f1" (invalid-name)
C:250,16: Invalid variable name "f2" (invalid-name)
C:256, 0: Missing function docstring (missing-docstring)
W:267,12: Redefining built-in 'input' (redefined-builtin)
C:257,63: Invalid variable name "f" (invalid-name)
C:260, 8: Invalid variable name "nBroken" (invalid-name)
C:273,16: Invalid variable name "nBroken" (invalid-name)
W:260, 8: Unused variable 'nBroken' (unused-variable)
W:263,12: Unused variable 'i' (unused-variable)
W:267,46: Unused variable 'j' (unused-variable)
C:279, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge096\challenge096.py:3:1: F401 'sys' imported but unused
D:\Development\pemjh\pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge097/challenge097.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid constant name "answer" (invalid-name)
W:  7, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge097\challenge097.py:7:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge098/challenge098.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getMap" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'map' (redefined-builtin)
C:  6, 8: Invalid variable name "w" (invalid-name)
C:  6,11: Invalid variable name "s" (invalid-name)
C: 15, 0: Invalid function name "uniqueRight" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
W: 15,16: Redefining built-in 'map' (redefined-builtin)
C: 25, 0: Invalid function name "mapWord" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 25,18: Redefining built-in 'map' (redefined-builtin)
C: 27, 8: Invalid variable name "c" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
W: 81,16: Redefining built-in 'map' (redefined-builtin)
R: 32, 0: Too many local variables (19/15) (too-many-locals)
C: 35, 4: Invalid variable name "groupedWords" (invalid-name)
C: 37,62: Invalid variable name "f" (invalid-name)
C: 40,16: Invalid variable name "orderedWord" (invalid-name)
C: 46, 4: Invalid variable name "groupedWords" (invalid-name)
C: 70, 8: Invalid variable name "nWords" (invalid-name)
C: 75,12: Invalid variable name "lWord" (invalid-name)
C: 78,16: Invalid variable name "potentialSquare" (invalid-name)
C: 87,24: Invalid variable name "word2Square" (invalid-name)
C: 95, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)

_________________ [pylint] pemjh/challenge099/challenge099.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5,65: Invalid variable name "f" (invalid-name)
C:  6, 8: Invalid variable name "highestIndex" (invalid-name)
C:  7, 8: Invalid variable name "highestNumber" (invalid-name)
C:  8, 8: Invalid variable name "highestLine" (invalid-name)
C:  9,12: Invalid variable name "nL" (invalid-name)
C:  9,16: Invalid variable name "l" (invalid-name)
C: 10,12: Invalid variable name "n" (invalid-name)
C: 11,12: Invalid variable name "rootedPower" (invalid-name)
C: 13,16: Invalid variable name "highestNumber" (invalid-name)
C: 13,31: Invalid variable name "highestIndex" (invalid-name)
C: 13,45: Invalid variable name "highestLine" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
W: 19, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge099\challenge099.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge100/challenge100.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "b" (invalid-name)
C:  3, 4: Invalid variable name "n" (invalid-name)
C:  5, 8: Invalid variable name "b" (invalid-name)
C:  5,11: Invalid variable name "n" (invalid-name)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge101/challenge101.py _________________
C:  5, 0: Line too long (123/100) (line-too-long)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "highestPower" (invalid-name)
C: 14, 8: Invalid variable name "workedSequence" (invalid-name)
C: 16,12: Invalid variable name "x" (invalid-name)
C: 17,12: Invalid variable name "y" (invalid-name)
C: 28,16: Invalid variable name "y" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
D:\Development\pemjh\pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge102/challenge102.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "enclosesOrigin" (invalid-name)
C:  4, 0: Invalid argument name "x1" (invalid-name)
C:  4, 0: Invalid argument name "y1" (invalid-name)
C:  4, 0: Invalid argument name "x2" (invalid-name)
C:  4, 0: Invalid argument name "y2" (invalid-name)
C:  4, 0: Invalid argument name "x3" (invalid-name)
C:  4, 0: Invalid argument name "y3" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
R:  4, 0: Too many arguments (6/5) (too-many-arguments)
C: 17,12: Invalid variable name "i1" (invalid-name)
C: 18,12: Invalid variable name "i2" (invalid-name)
C: 21,12: Invalid variable name "i1" (invalid-name)
C: 22,12: Invalid variable name "i2" (invalid-name)
C: 25,12: Invalid variable name "i1" (invalid-name)
C: 26,12: Invalid variable name "i2" (invalid-name)
C: 33, 0: Invalid function name "getYIntercept" (invalid-name)
C: 33, 0: Invalid argument name "x1" (invalid-name)
C: 33, 0: Invalid argument name "y1" (invalid-name)
C: 33, 0: Invalid argument name "x2" (invalid-name)
C: 33, 0: Invalid argument name "y2" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "m" (invalid-name)
C: 38, 4: Invalid variable name "c" (invalid-name)
C: 43, 0: Missing function docstring (missing-docstring)
C: 46, 4: Invalid variable name "nEnclosing" (invalid-name)
C: 47,23: Invalid variable name "f" (invalid-name)
C: 48,12: Invalid variable name "l" (invalid-name)
C: 49,12: Invalid variable name "ax" (invalid-name)
C: 49,16: Invalid variable name "ay" (invalid-name)
C: 49,20: Invalid variable name "bx" (invalid-name)
C: 49,24: Invalid variable name "by" (invalid-name)
C: 49,28: Invalid variable name "cx" (invalid-name)
C: 49,32: Invalid variable name "cy" (invalid-name)
C: 51,16: Invalid variable name "nEnclosing" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge103/challenge103.py _________________
C: 41, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "subSets" (invalid-name)
C:  1, 0: Invalid argument name "l" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "setA" (invalid-name)
C:  5, 8: Invalid variable name "setB" (invalid-name)
C: 14, 0: Invalid argument name "l" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "B" (invalid-name)
C: 16,11: Invalid variable name "CPart" (invalid-name)
C: 19,16: Invalid variable name "C" (invalid-name)
C: 19,19: Invalid variable name "notUsed" (invalid-name)
C: 23,24: Invalid variable name "wB" (invalid-name)
C: 23,28: Invalid variable name "wC" (invalid-name)
C: 25,24: Invalid variable name "wB" (invalid-name)
C: 25,28: Invalid variable name "wC" (invalid-name)
W: 19,19: Unused variable 'notUsed' (unused-variable)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "midPoint" (invalid-name)
C: 48, 4: Invalid variable name "sumAns" (invalid-name)
C: 49, 8: Invalid variable name "b" (invalid-name)
C: 50, 8: Invalid variable name "newSet" (invalid-name)
C: 54,16: Invalid variable name "sumAns" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge104/challenge104.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "myEnumerate" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Invalid function name "fiboTrunc" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "aStart" (invalid-name)
C: 10,12: Invalid variable name "bStart" (invalid-name)
C: 11, 4: Invalid variable name "aEnd" (invalid-name)
C: 11,10: Invalid variable name "bEnd" (invalid-name)
C: 13, 4: Invalid variable name "endTrunc" (invalid-name)
C: 14, 4: Invalid variable name "startTrunc" (invalid-name)
C: 18, 8: Invalid variable name "aStart" (invalid-name)
C: 18,16: Invalid variable name "bStart" (invalid-name)
C: 19, 8: Invalid variable name "aEnd" (invalid-name)
C: 19,14: Invalid variable name "bEnd" (invalid-name)
C: 22, 8: Invalid variable name "aEnd" (invalid-name)
C: 23, 8: Invalid variable name "bEnd" (invalid-name)
C: 26,12: Invalid variable name "aStart" (invalid-name)
C: 27,12: Invalid variable name "bStart" (invalid-name)
C: 29, 8: Invalid variable name "aStartRet" (invalid-name)
C: 31,12: Invalid variable name "aStartRet" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "lowerLimit" (invalid-name)
C: 38,11: Invalid variable name "f" (invalid-name)
C: 39, 8: Invalid variable name "s" (invalid-name)
C: 40, 8: Invalid variable name "e" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused fibo imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge104\challenge104.py:1:1: F401 'fibo' imported but unused
D:\Development\pemjh\pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge105/challenge105.py _________________
C: 61, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "sizedSubsets" (invalid-name)
C:  4, 0: Invalid argument name "l" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "sizeL" (invalid-name)
C: 21, 0: Invalid function name "checkForDuplicateSetSums" (invalid-name)
C: 21, 0: Invalid argument name "l" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 22, 8: Invalid variable name "setSize" (invalid-name)
C: 23, 8: Invalid variable name "sumSub" (invalid-name)
C: 30, 0: Invalid argument name "l" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "nItems" (invalid-name)
C: 49, 0: Missing function docstring (missing-docstring)
C: 51,61: Invalid variable name "f" (invalid-name)
C: 60, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge106/challenge106.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "incrementTrilist" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "rightIndex" (invalid-name)
C: 16, 0: Invalid function name "allSubsets" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17, 4: Invalid variable name "triList" (invalid-name)
C: 28, 0: Invalid argument name "l" (invalid-name)
C: 28, 0: Missing function docstring (missing-docstring)
C: 48, 0: Invalid function name "getRequiredCompares" (invalid-name)
C: 48, 0: Missing function docstring (missing-docstring)
C: 49, 4: Invalid variable name "allS" (invalid-name)
C: 52, 4: Invalid variable name "workingS" (invalid-name)
C: 55, 4: Invalid variable name "workingS" (invalid-name)
C: 58, 4: Invalid variable name "workingS" (invalid-name)
C: 62, 0: Missing function docstring (missing-docstring)
C: 65, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge107/challenge107.py _________________
C: 22, 0: Line too long (102/100) (line-too-long)
C: 25, 0: Line too long (139/100) (line-too-long)
C: 25, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "skimNetwork" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "connectedRows" (invalid-name)
C:  7, 4: Invalid variable name "availableConnections" (invalid-name)
C: 22, 8: Invalid variable name "availableConnections" (invalid-name)
C: 30, 4: Invalid variable name "newGrid" (invalid-name)
W: 30,35: Unused variable 'row' (unused-variable)
C: 36, 0: Invalid function name "scoreGrid" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "r" (invalid-name)
C: 41,12: Invalid variable name "v" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 50,64: Invalid variable name "f" (invalid-name)
C: 56, 4: Invalid variable name "originalScore" (invalid-name)
C: 59, 4: Invalid variable name "newGrid" (invalid-name)
C: 62, 4: Invalid variable name "newScore" (invalid-name)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)

_________________ [pylint] pemjh/challenge108/challenge108.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge109/challenge109.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def getNonDoubleOuts(n, darts, nums, known = dict()):
                                           ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "getNonDoubleOuts" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nCount" (invalid-name)
C:  7, 8: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "nCount" (invalid-name)
C: 21, 0: Invalid function name "getDoubleOuts" (invalid-name)
C: 21, 0: Invalid argument name "n" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "nCount" (invalid-name)
C: 24,14: Invalid variable name "d" (invalid-name)
C: 26,12: Invalid variable name "nCount" (invalid-name)
C: 28,12: Invalid variable name "nCount" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "nCount" (invalid-name)
C: 43, 8: Invalid variable name "nCount" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge110/challenge110.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge111/challenge111.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def isPrime(p, pc = PrimeChecker()):
                  ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "isPrime" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "pc" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid function name "buildNums" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17,16: Invalid variable name "b" (invalid-name)
C: 24,16: Invalid variable name "b" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "M" (invalid-name)
C: 31, 4: Invalid variable name "N" (invalid-name)
C: 32, 4: Invalid variable name "S" (invalid-name)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36, 8: Invalid variable name "s" (invalid-name)
C: 38,12: Invalid variable name "m" (invalid-name)
C: 40,20: Invalid variable name "b" (invalid-name)
C: 44,28: Invalid variable name "n" (invalid-name)
C: 45,28: Invalid variable name "s" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused roughPrimes imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge111\challenge111.py:1:1: F401 'roughPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge112/challenge112.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isBouncy" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  6,11: Invalid variable name "nextM" (invalid-name)
C:  9,12: Invalid variable name "nextMovement" (invalid-name)
C: 11,12: Invalid variable name "nextMovement" (invalid-name)
C: 13,12: Invalid variable name "nextMovement" (invalid-name)
C: 15, 8: Invalid variable name "m" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "currentBouncy" (invalid-name)
C: 32, 4: Invalid variable name "currentNumber" (invalid-name)
C: 36,12: Invalid variable name "currentBouncy" (invalid-name)
C: 39,54: More than one statement on a single line (multiple-statements)
C: 41, 8: Invalid variable name "currentNumber" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge113/challenge113.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 21, 8: Invalid variable name "d" (invalid-name)
C: 22, 8: Invalid variable name "p" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge114/challenge114.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 14,16: Invalid variable name "nVariations" (invalid-name)
C: 17, 8: Invalid variable name "nVariations" (invalid-name)
C: 20, 8: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 4: Invalid variable name "n" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge115/challenge115.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, minimum, tileSizes, known = dict()):
                                                    ^ (bad-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 15,12: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 21, 8: Invalid variable name "nVariations" (invalid-name)
C: 27, 0: Invalid function name "f" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "b" (invalid-name)
C: 38, 8: Invalid variable name "b" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge116/challenge116.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                        ^ (bad-whitespace)
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                                      ^ (bad-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSize" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  9,12: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 15, 8: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "n2" (invalid-name)
C: 26, 4: Invalid variable name "n3" (invalid-name)
C: 27, 4: Invalid variable name "n4" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge117/challenge117.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 10,16: Invalid variable name "nVariations" (invalid-name)
C: 13, 8: Invalid variable name "nVariations" (invalid-name)
C: 16, 8: Invalid variable name "nVariations" (invalid-name)
C: 22, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "n" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge118/challenge118.py _________________
C: 10, 0: No space allowed around keyword argument assignment
def build_sets(existing, left, lExist = 0):
                                      ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 0: Invalid argument name "lExist" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "lLeft" (invalid-name)
C: 16, 8: Invalid variable name "lNew" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
W: 37,12: Used builtin function 'map' (bad-builtin)
C: 45, 0: Missing function docstring (missing-docstring)
C: 49, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge119/challenge119.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "sumDigits" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "w" (invalid-name)
C:  5, 8: Invalid variable name "w" (invalid-name)
C:  5,11: Invalid variable name "m" (invalid-name)
C:  9, 0: Invalid function name "an" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 16,12: Invalid variable name "p" (invalid-name)
C: 18,12: Invalid variable name "s" (invalid-name)
W: 16,12: Unused variable 'p' (unused-variable)
C: 25, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge120/challenge120.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "highestMod" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge121/challenge121.py _________________
C: 21, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "winChance" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "lossesAllowed" (invalid-name)
C: 22, 8: Invalid variable name "lossesAllowed" (invalid-name)
C: 27, 8: Invalid variable name "wc" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge122/challenge122.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12,16: Invalid variable name "f" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge123/challenge123.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getRemainder" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 11, 8: Invalid variable name "r" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 17, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge124/challenge124.py _________________
C:  5, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] > b[1]))):
        ^   | (bad-continuation)
C: 12, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] < b[1]))):
        ^   | (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 8: Invalid variable name "p" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge125/challenge125.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "rtLimit" (invalid-name)
C:  8, 8: Invalid variable name "rtLimit" (invalid-name)
C:  9, 4: Invalid variable name "rtLimit" (invalid-name)
C: 13, 8: Invalid variable name "sq" (invalid-name)
C: 15,12: Invalid variable name "sq" (invalid-name)
C: 26, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge126/challenge126.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 16, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 20, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 24, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 29, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "surroundingCubes" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Invalid argument name "z" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "maximumResult" (invalid-name)
C: 10, 4: Invalid variable name "maximumDepth" (invalid-name)
C: 12, 8: Invalid variable name "maximumDepth" (invalid-name)
C: 15, 8: Invalid variable name "maximumA" (invalid-name)
C: 17,12: Invalid variable name "maximumA" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "maximumB" (invalid-name)
C: 21,16: Invalid variable name "maximumB" (invalid-name)
C: 22,16: Invalid variable name "b" (invalid-name)
C: 23,16: Invalid variable name "maximumC" (invalid-name)
C: 25,20: Invalid variable name "maximumC" (invalid-name)
C: 26,20: Invalid variable name "c" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)

_________________ [pylint] pemjh/challenge127/challenge127.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 20,12: Redefining built-in 'next' (redefined-builtin)
C: 19, 8: Invalid variable name "c" (invalid-name)
C: 21,12: Invalid variable name "a" (invalid-name)
C: 24,12: Invalid variable name "b" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','

_________________ [pylint] pemjh/challenge128/challenge128.py _________________
C: 23, 0: Line too long (103/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "nPrimes" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)

_________________ [pylint] pemjh/challenge129/challenge129.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "A" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "n" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16,12: Invalid variable name "an" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
F: 25, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge130/challenge130.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "A" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
F: 28, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge131/challenge131.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "p" (invalid-name)
C: 18, 8: Invalid variable name "lowerCube" (invalid-name)
C: 19, 8: Invalid variable name "upperCube" (invalid-name)
C: 25,16: Invalid variable name "lowerCube" (invalid-name)
C: 30,16: Invalid variable name "upperCube" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge132/challenge132.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "R" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 13,33: More than one statement on a single line (multiple-statements)
C: 17, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge133/challenge133.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)

_________________ [pylint] pemjh/challenge134/challenge134.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "jumpSize" (invalid-name)
C:  3, 0: Invalid argument name "t" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "cInd" (invalid-name)
C: 21, 4: Invalid variable name "tInd" (invalid-name)
C: 29, 0: Invalid function name "f" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "s" (invalid-name)
C: 33, 4: Invalid variable name "c" (invalid-name)
C: 35, 4: Invalid variable name "t" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 51, 8: Invalid variable name "r" (invalid-name)
C: 54, 4: Invalid variable name "p1" (invalid-name)
C: 55, 4: Invalid variable name "S" (invalid-name)
C: 56, 8: Invalid variable name "p2" (invalid-name)
C: 61, 8: Invalid variable name "n" (invalid-name)
C: 63, 8: Invalid variable name "S" (invalid-name)
C: 65, 8: Invalid variable name "p1" (invalid-name)
W: 51, 8: Unused variable 'r' (unused-variable)
C: 68, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge135/challenge135.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumTarget" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "x" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "n" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge136/challenge136.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getNumTarget" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "p" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge137/challenge137.py _________________
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  8, 0: No space allowed around keyword argument assignment
def a(n, known = {0: 0, 1: 2, 2: 15}):
               ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining name 'a' from outer scope (line 8) (redefined-outer-name)
C:  2, 4: Invalid variable name "a" (invalid-name)
C:  2, 7: Invalid variable name "b" (invalid-name)
C:  4, 8: Invalid variable name "x" (invalid-name)
C:  6, 8: Invalid variable name "a" (invalid-name)
C:  6,11: Invalid variable name "b" (invalid-name)
W:  4, 8: Unused variable 'x' (unused-variable)
W:  8, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  8, 0: Invalid function name "a" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 19, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge138/challenge138.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 15, 8: Redefining built-in 'next' (redefined-builtin)
C:  4, 4: Invalid variable name "b1" (invalid-name)
C:  5, 4: Invalid variable name "b2" (invalid-name)
C: 17, 8: Invalid variable name "v" (invalid-name)
C: 21,12: Invalid variable name "v" (invalid-name)
C: 27,23: More than one statement on a single line (multiple-statements)
W:  7, 8: Unused variable 'i' (unused-variable)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)

_________________ [pylint] pemjh/challenge139/challenge139.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge142/challenge142.py _________________
C: 32, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "perfectSquare" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "a" (invalid-name)
C:  4, 0: Invalid argument name "b" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)

_________________ [pylint] pemjh/challenge144/challenge144.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "solveQuadratic" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "sqPart" (invalid-name)
C:  7, 0: Invalid argument name "x" (invalid-name)
C:  7, 0: Invalid argument name "y" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "impGrad" (invalid-name)
C: 12, 4: Invalid variable name "impAngle" (invalid-name)
C: 15, 4: Invalid variable name "inAngle" (invalid-name)
C: 18, 4: Invalid variable name "diffAngle" (invalid-name)
C: 21, 4: Invalid variable name "newAngle" (invalid-name)
C: 24, 4: Invalid variable name "newGradient" (invalid-name)
C: 29, 0: Invalid function name "nextStep" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "m" (invalid-name)
C: 34, 4: Invalid variable name "c" (invalid-name)
C: 41, 4: Invalid variable name "x1" (invalid-name)
C: 41, 8: Invalid variable name "x2" (invalid-name)
C: 45, 8: Invalid variable name "xImpact" (invalid-name)
C: 47, 8: Invalid variable name "xImpact" (invalid-name)
C: 49, 4: Invalid variable name "yImpact" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 56, 0: Missing function docstring (missing-docstring)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge145/challenge145.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "d" (invalid-name)
C:  8, 4: Invalid variable name "sevenDigits" (invalid-name)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge146/challenge146.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def is_pseudo_prime(n, known = {1: True, 2: True}):
                             ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "ns" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent

_________________ [pylint] pemjh/challenge148/challenge148.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 31, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge149/challenge149.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid argument name "l" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 29, 0: Missing function docstring (missing-docstring)
W: 35,13: Used builtin function 'map' (bad-builtin)
W: 44,13: Used builtin function 'map' (bad-builtin)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge151/challenge151.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a5" (invalid-name)
C:  1, 0: Invalid argument name "a4" (invalid-name)
C:  1, 0: Invalid argument name "a3" (invalid-name)
C:  1, 0: Invalid argument name "a2" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge162/challenge162.py _________________
C:  2, 0: Line too long (103/100) (line-too-long)
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid constant name "answer" (invalid-name)
C:  8, 0: Invalid constant name "desc" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge164/challenge164.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(size, previousThree, useZero, known = dict()):
                                                  ^ (bad-whitespace)
C: 15, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "useZero" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nLosses" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge166/challenge166.py _________________
C: 60, 0: Line too long (102/100) (line-too-long)
C: 65, 0: Line too long (114/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sq" (invalid-name)
R:  1, 0: Too many branches (14/12) (too-many-branches)
C: 70, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)

_________________ [pylint] pemjh/challenge173/challenge173.py _________________
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numOfSquares" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nSquares" (invalid-name)
C:  3, 4: Invalid variable name "holeWidth" (invalid-name)
C:  6, 8: Invalid variable name "holeArea" (invalid-name)
C: 12, 8: Invalid variable name "surroundingWidth" (invalid-name)
C: 16,12: Invalid variable name "totalArea" (invalid-name)
C: 19,12: Invalid variable name "surroundingArea" (invalid-name)
C: 24,12: Invalid variable name "surroundingWidth" (invalid-name)
C: 25,12: Invalid variable name "nSquares" (invalid-name)
C: 27, 8: Invalid variable name "holeWidth" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge174/challenge174.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def getDivisors(n, known = dict()):
                         ^ (bad-whitespace)
C: 11, 0: No space allowed around keyword argument assignment
def getNumEvenDivisors(n, known = dict()):
                                ^ (bad-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "getDivisors" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "d" (invalid-name)
W: 11, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 11, 0: Invalid function name "getNumEvenDivisors" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 4: Invalid variable name "nDiv" (invalid-name)
C: 20,12: Invalid variable name "nDiv" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nSquares" (invalid-name)
C: 31, 4: Invalid variable name "nMatches" (invalid-name)
C: 32, 8: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "nMatches" (invalid-name)
W: 33,24: Used builtin function 'filter' (bad-builtin)
W: 33,24: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 33,46: Cell variable n defined in loop (cell-var-from-loop)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge179/challenge179.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nSame" (invalid-name)
C:  8,12: Invalid variable name "a" (invalid-name)
C: 13,12: Invalid variable name "nSame" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge183/challenge183.py _________________
C:  4, 0: No space allowed around keyword argument assignment
def pf(n, known = dict()):
                ^ (bad-whitespace)
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 12, 0: No space allowed around keyword argument assignment
def factPower(b, f, known = dict()):
                          ^ (bad-whitespace)
C: 30, 0: Line too long (106/100) (line-too-long)
C: 32, 0: Line too long (107/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  4, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  4, 0: Invalid function name "pf" (invalid-name)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W: 12, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 12, 0: Invalid function name "factPower" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "f" (invalid-name)
C: 20,11: Invalid variable name "m" (invalid-name)
C: 26, 0: Invalid argument name "n" (invalid-name)
C: 26, 0: Invalid argument name "d" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "dFacts" (invalid-name)
C: 31, 4: Invalid variable name "termDen" (invalid-name)
C: 32, 4: Invalid variable name "dFacts" (invalid-name)
C: 36, 0: Invalid function name "M" (invalid-name)
C: 36, 0: Invalid argument name "N" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 0: Invalid function name "SD" (invalid-name)
C: 40, 0: Missing function docstring (missing-docstring)
C: 42, 8: Invalid variable name "N" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 53, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge187/challenge187.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nPrimes" (invalid-name)
C:  7, 4: Invalid variable name "nTwos" (invalid-name)
C: 12,12: Invalid variable name "nTwos" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge188/challenge188.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge190/challenge190.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "P" (invalid-name)
C:  1, 0: Invalid argument name "m" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge191/challenge191.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(days, previousThree, latesLeft, known = dict()):
                                                    ^ (bad-whitespace)
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
                                                              ^ (bad-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Line too long (105/100) (line-too-long)
C: 67, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "latesLeft" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  7, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "numVariations" (invalid-name)
C: 25, 0: Invalid argument name "tilePatterns" (invalid-name)
C: 25, 0: Invalid argument name "losingPatterns" (invalid-name)
R: 25, 0: Too many local variables (16/15) (too-many-locals)
C: 29, 4: Invalid variable name "nVariations" (invalid-name)
C: 35,16: Invalid variable name "c" (invalid-name)
C: 36,16: Invalid variable name "nVariations" (invalid-name)
C: 39,16: Invalid variable name "tilePattern" (invalid-name)
C: 41,16: Invalid variable name "lTilePattern" (invalid-name)
C: 45,24: Invalid variable name "nVariations" (invalid-name)
C: 50,16: Invalid variable name "nLeft" (invalid-name)
C: 52,20: Invalid variable name "nLeft" (invalid-name)
C: 55,20: Invalid variable name "lPattern" (invalid-name)
C: 62,24: Invalid variable name "nVariations" (invalid-name)
C: 66,12: Invalid variable name "nVariations" (invalid-name)
W: 35,16: Unused variable 'c' (unused-variable)
R: 25, 0: Too many branches (13/12) (too-many-branches)
C: 72, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nPatterns" (invalid-name)
C: 76, 4: Invalid variable name "nLosses" (invalid-name)
C: 80, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge197/challenge197.py _________________
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "f" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "n" (invalid-name)
C:  6, 4: Invalid variable name "u" (invalid-name)
C: 13, 8: Invalid variable name "u" (invalid-name)
W: 10, 4: Unused variable 'odd' (unused-variable)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge197\challenge197.py:10:5: F841 local variable 'odd' is assigned to but never used
D:\Development\pemjh\pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge203/challenge203.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "squareFree" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 29,12: Invalid variable name "p" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
D:\Development\pemjh\pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge204/challenge204.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getHams" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCount" (invalid-name)
C:  5, 8: Invalid variable name "p" (invalid-name)
C:  7, 8: Invalid variable name "pCurrent" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 14,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "pCurrent" (invalid-name)
C: 19, 0: Invalid function name "hamNums" (invalid-name)
C: 19, 0: Invalid argument name "maxPrime" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 23, 4: Unused variable 'found' (unused-variable)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:23:5: F841 local variable 'found' is assigned to but never used
D:\Development\pemjh\pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge205/challenge205.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "diceRolls" (invalid-name)
C:  7, 0: Invalid argument name "nDice" (invalid-name)
C:  7, 0: Invalid argument name "nSides" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nRolls" (invalid-name)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17,10: Invalid variable name "nPete" (invalid-name)
C: 18,11: Invalid variable name "nColin" (invalid-name)
C: 20, 4: Invalid variable name "peteWin" (invalid-name)
C: 21, 4: Invalid variable name "totalRolls" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 22,11: Invalid variable name "f" (invalid-name)
C: 24, 8: Invalid variable name "nWins" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge206/challenge206.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "v" (invalid-name)
C: 12, 0: Invalid function name "hasMask" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "w" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "lowestRoot" (invalid-name)
C: 34, 8: Invalid variable name "sq" (invalid-name)
C: 36, 8: Invalid variable name "hasM" (invalid-name)
C: 36,14: Invalid variable name "wrongIndex" (invalid-name)
C: 51,12: Invalid variable name "sq" (invalid-name)
C: 58,32: More than one statement on a single line (multiple-statements)
C: 62, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused floor imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge206\challenge206.py:1:1: F401 'floor' imported but unused
D:\Development\pemjh\pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge207/challenge207.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "a" (invalid-name)
C:  6, 4: Invalid variable name "b" (invalid-name)
C:  7, 4: Invalid variable name "t" (invalid-name)
C:  8, 4: Invalid variable name "nextPower" (invalid-name)
C: 10, 8: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "t" (invalid-name)
C: 16,12: Invalid variable name "nextPower" (invalid-name)
C: 20, 8: Invalid variable name "a" (invalid-name)
C: 20,11: Invalid variable name "b" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge211/challenge211.py _________________
C: 13, 0: Line too long (112/100) (line-too-long)
C: 54, 0: No space allowed around keyword argument assignment
def challenge211(calc = False):
                      ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "squareSum" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "slowButRight" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "d" (invalid-name)
C: 27,11: Invalid variable name "m" (invalid-name)
C: 30,12: Invalid variable name "a" (invalid-name)
C: 33,16: Invalid variable name "a" (invalid-name)
C: 34,16: Invalid variable name "d" (invalid-name)
C: 34,19: Invalid variable name "m" (invalid-name)
C: 44, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "x" (invalid-name)
C: 48, 8: Invalid variable name "s" (invalid-name)
C: 54, 0: Missing function docstring (missing-docstring)
C: 63, 0: Invalid constant name "answer" (invalid-name)
F: 66, 4: Unable to import 'psyco' (import-error)
W:  2, 0: Unused takewhile imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge211\challenge211.py:2:1: F401 'takewhile' imported but unused
D:\Development\pemjh\pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
D:\Development\pemjh\pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge214/challenge214.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def totients(n, primes = None):
                       ^ (bad-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def totientChainLength(n, current, limit, steps, known = dict()):
                                                       ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "p" (invalid-name)
C: 19,12: Invalid variable name "t" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "totientChainLength" (invalid-name)
C: 25, 0: Invalid argument name "n" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 51,12: Invalid variable name "v" (invalid-name)
W: 25,26: Unused argument 'current' (unused-argument)
C: 58, 0: Missing function docstring (missing-docstring)
C: 64, 8: Invalid variable name "p" (invalid-name)
C: 71, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused phi imported from utils.numbers (unused-import)
W:  1, 0: Unused primeFactors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'phi' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'primeFactors' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge215/challenge215.py _________________
C:  3, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  6, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C:  9, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 12, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "buildRowOptions" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid function name "runningCrack" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 31, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 31, 0: Invalid function name "W" (invalid-name)
C: 31, 0: Invalid argument name "startRow" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 39,16: Invalid variable name "subRow" (invalid-name)
C: 46, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "wallWidth" (invalid-name)
C: 49, 4: Invalid variable name "wallHeight" (invalid-name)
C: 51, 4: Invalid variable name "rowLinks" (invalid-name)
W: 53,11: Used builtin function 'map' (bad-builtin)
C: 61, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)

_________________ [pylint] pemjh/challenge216/challenge216.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
def challenge216(skip = True):
                      ^ (bad-whitespace)
C: 49, 0: Trailing whitespace (trailing-whitespace)
C: 51, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 54, 0: Exactly one space required after comma
    primes[0:2] = [False,False]
                        ^ (bad-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 60, 0: Trailing whitespace (trailing-whitespace)
C: 62, 0: Trailing whitespace (trailing-whitespace)
C: 63, 0: Exactly one space required after comma
    t[0:2] = [False,False]
                   ^ (bad-whitespace)
C: 64, 0: Trailing whitespace (trailing-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "l" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "v" (invalid-name)
C:  8,12: Invalid variable name "v" (invalid-name)
C: 20, 0: Invalid function name "sq" (invalid-name)
C: 20, 0: Invalid argument name "a" (invalid-name)
C: 20, 0: Invalid argument name "p" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 21, 4: Invalid variable name "q" (invalid-name)
C: 21, 7: Invalid variable name "e" (invalid-name)
C: 23, 8: Invalid variable name "e" (invalid-name)
C: 24, 8: Invalid variable name "q" (invalid-name)
C: 25, 4: Invalid variable name "n" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 28, 4: Invalid variable name "z" (invalid-name)
C: 29, 4: Invalid variable name "y" (invalid-name)
C: 29, 7: Invalid variable name "r" (invalid-name)
C: 29,10: Invalid variable name "x" (invalid-name)
C: 30, 4: Invalid variable name "b" (invalid-name)
C: 31, 4: Invalid variable name "x" (invalid-name)
C: 33, 8: Invalid variable name "bb" (invalid-name)
C: 33,12: Invalid variable name "m" (invalid-name)
C: 35,12: Invalid variable name "bb" (invalid-name)
C: 36,12: Invalid variable name "m" (invalid-name)
C: 39, 8: Invalid variable name "t" (invalid-name)
C: 41,12: Invalid variable name "t" (invalid-name)
C: 42, 8: Invalid variable name "y" (invalid-name)
C: 42,11: Invalid variable name "r" (invalid-name)
C: 42,14: Invalid variable name "x" (invalid-name)
C: 43, 8: Invalid variable name "b" (invalid-name)
W: 40,12: Unused variable 'k' (unused-variable)
C: 46, 0: Missing function docstring (missing-docstring)
C: 56, 8: Invalid variable name "x" (invalid-name)
C: 58,16: Invalid variable name "y" (invalid-name)
C: 61, 4: Invalid variable name "t" (invalid-name)
C: 65, 8: Invalid variable name "x" (invalid-name)
C: 67,12: Invalid variable name "s" (invalid-name)
C: 78, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge220/challenge220.py _________________
C:  2, 0: Exactly one space required after comma
    c = [0,1]
          ^ (bad-whitespace)
C: 13, 0: Exactly one space required after comma
    c2 = [-c2[1],c2[0]]
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "c" (invalid-name)
C:  5, 8: Invalid variable name "c" (invalid-name)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 12, 4: Invalid variable name "c2" (invalid-name)
C: 13, 4: Invalid variable name "c2" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
W: 17,20: Used builtin function 'map' (bad-builtin)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge225/challenge225.py _________________
C:  2, 0: Line too long (108/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 10,12: Invalid variable name "a" (invalid-name)
C: 10,15: Invalid variable name "b" (invalid-name)
C: 10,18: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)

_________________ [pylint] pemjh/challenge230/challenge230.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Line too long (110/100) (line-too-long)
C: 41, 0: Line too long (110/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "D" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "aSize" (invalid-name)
C:  7, 4: Invalid variable name "bSize" (invalid-name)
C:  9, 8: Invalid variable name "aSize" (invalid-name)
C:  9,15: Invalid variable name "bSize" (invalid-name)
C: 14, 4: Invalid variable name "workingN" (invalid-name)
C: 22, 8: Invalid variable name "firstSize" (invalid-name)
C: 25,12: Invalid variable name "workingN" (invalid-name)
C: 33, 8: Invalid variable name "containingStr" (invalid-name)
C: 35, 8: Invalid variable name "containingStr" (invalid-name)
W:  2, 4: Unused variable 'size' (unused-variable)
C: 39, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "a" (invalid-name)
C: 41, 4: Invalid variable name "b" (invalid-name)
C: 44,15: Invalid variable name "n" (invalid-name)
C: 49, 0: Invalid constant name "answer" (invalid-name)
W: 52, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge230\challenge230.py:2:5: F841 local variable 'size' is assigned to but never used
D:\Development\pemjh\pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:52:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge231/challenge231.py _________________
C: 43, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getFirstMultipleOnOrAfter" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "m" (invalid-name)
C: 10, 0: Invalid function name "getFirstMultipleOnOrBefore" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 17, 0: Invalid function name "numInRange" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 23, 0: Missing function docstring (missing-docstring)
C: 24, 4: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "p" (invalid-name)
C: 43,12: Invalid variable name "numRange" (invalid-name)
C: 49,12: Invalid variable name "denRange" (invalid-name)
C: 53,12: Invalid variable name "inRange" (invalid-name)
C: 59,16: Invalid variable name "inRange" (invalid-name)
C: 62,16: Invalid variable name "inRange" (invalid-name)
W: 36, 8: Unused variable 'index' (unused-variable)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:36:9: F841 local variable 'index' is assigned to but never used
D:\Development\pemjh\pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace

_________________ [pylint] pemjh/challenge234/challenge234.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Wrong continued indentation.
                          next**2 if next**2 < limit + 1 else limit + 1,
                          ^| (bad-continuation)
C: 24, 0: Wrong continued indentation.
                          current))
                          ^| (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Missing function docstring (missing-docstring)
W: 19, 8: Redefining built-in 'next' (redefined-builtin)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent

_________________ [pylint] pemjh/challenge235/challenge235.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "r" (invalid-name)
C:  4, 4: Invalid variable name "dr" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  7, 8: Invalid variable name "s" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 11,12: Invalid variable name "r" (invalid-name)
C: 12, 8: Invalid variable name "dr" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge243/challenge243.py _________________
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "d" (invalid-name)
C: 24,23: More than one statement on a single line (multiple-statements)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 37,20: Invalid variable name "m" (invalid-name)
C: 38,20: Invalid variable name "d" (invalid-name)
C: 46, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge250/challenge250.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W: 12,12: Unused variable 'j' (unused-variable)
C: 20, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge259/challenge259.py _________________
C: 22, 0: No space allowed around keyword argument assignment
def get_totals(start, end, known = {}):
                                 ^ (bad-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "g" (invalid-name)
C: 10, 0: Invalid argument name "a" (invalid-name)
C: 10, 0: Invalid argument name "b" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid argument name "a" (invalid-name)
C: 13, 0: Invalid argument name "b" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid argument name "a" (invalid-name)
C: 16, 0: Invalid argument name "b" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid argument name "a" (invalid-name)
C: 19, 0: Invalid argument name "b" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 22, 0: Dangerous default value {} as argument (dangerous-default-value)
C: 22, 0: Missing function docstring (missing-docstring)
C: 55, 0: Invalid constant name "answer" (invalid-name)
C: 57, 0: Missing function docstring (missing-docstring)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)

_________________ [pylint] pemjh/challenge265/challenge265.py _________________
C: 10, 0: Trailing whitespace (trailing-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Trailing whitespace (trailing-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  3, 4: Invalid variable name "s" (invalid-name)
C:  4, 4: Invalid variable name "d" (invalid-name)
C:  4, 7: Invalid variable name "m" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  6, 4: Invalid variable name "d" (invalid-name)
C:  6, 7: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "s" (invalid-name)
C:  8, 4: Invalid variable name "s" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Invalid argument name "d" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "b" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "getSequences" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 26, 8: Invalid variable name "b" (invalid-name)
C: 30,16: Invalid variable name "s" (invalid-name)
C: 35, 0: Invalid function name "S" (invalid-name)
C: 35, 0: Invalid argument name "n" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 49, 0: Missing function docstring (missing-docstring)
C: 52, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace

_____________________ [pylint] pemjh/utilities/numbers.py _____________________
C: 92, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  7, 0: Invalid function name "getPrimitiveTriples" (invalid-name)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 16, 8: Invalid variable name "m" (invalid-name)
C: 23,20: Invalid variable name "a" (invalid-name)
C: 24,20: Invalid variable name "b" (invalid-name)
C: 25,20: Invalid variable name "c" (invalid-name)
C: 36,12: Invalid variable name "m" (invalid-name)
C: 37, 8: Invalid variable name "n" (invalid-name)
C: 40, 0: Missing function docstring (missing-docstring)
C: 41, 8: Invalid variable name "n" (invalid-name)
C: 63, 0: Invalid function name "rootConvergentGenerator" (invalid-name)
C: 63, 0: Missing function docstring (missing-docstring)
C: 64, 4: Invalid variable name "A" (invalid-name)
C: 65, 4: Invalid variable name "A_1" (invalid-name)
C: 67, 4: Invalid variable name "B" (invalid-name)
C: 68, 4: Invalid variable name "B_1" (invalid-name)
C: 70, 8: Invalid variable name "b" (invalid-name)
C: 71, 8: Invalid variable name "newA" (invalid-name)
C: 72, 8: Invalid variable name "newB" (invalid-name)
C: 75, 8: Invalid variable name "A_1" (invalid-name)
C: 75,13: Invalid variable name "A" (invalid-name)
C: 75,16: Invalid variable name "B_1" (invalid-name)
C: 75,21: Invalid variable name "B" (invalid-name)
C: 78, 0: Invalid function name "continueGenerator" (invalid-name)
C: 78, 0: Missing function docstring (missing-docstring)
C: 80, 4: Invalid variable name "b" (invalid-name)
C:103, 8: Invalid variable name "newB" (invalid-name)
C:105, 8: Invalid variable name "nSubtracts" (invalid-name)
C:107,12: Invalid variable name "newB" (invalid-name)
C:108,12: Invalid variable name "nSubtracts" (invalid-name)
C:110, 8: Invalid variable name "b" (invalid-name)
C:130, 0: Invalid function name "polytopicNumbers" (invalid-name)
C:130, 0: Invalid argument name "f" (invalid-name)
C:130, 0: Missing function docstring (missing-docstring)
C:132, 8: Invalid variable name "n" (invalid-name)
C:139, 0: Missing function docstring (missing-docstring)
W:151, 8: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:144, 4: Invalid function name "applyMultiple" (invalid-name)
C:144, 4: Missing function docstring (missing-docstring)
W:144,38: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:160, 0: Invalid function name "numPermutations" (invalid-name)
C:160, 0: Invalid argument name "numString" (invalid-name)
C:160, 0: Missing function docstring (missing-docstring)
C:161, 4: Invalid variable name "maximumPermutations" (invalid-name)
C:163, 4: Invalid variable name "tempString" (invalid-name)
C:166, 8: Invalid variable name "c" (invalid-name)
C:168, 8: Invalid variable name "cCount" (invalid-name)
C:173, 8: Invalid variable name "tempString" (invalid-name)
C:178, 0: Invalid argument name "x" (invalid-name)
C:178, 0: Missing function docstring (missing-docstring)
C:185, 0: Missing function docstring (missing-docstring)
C:186, 4: Invalid variable name "a" (invalid-name)
C:187, 4: Invalid variable name "b" (invalid-name)
C:190, 8: Invalid variable name "a" (invalid-name)
C:190,11: Invalid variable name "b" (invalid-name)
C:193, 0: Invalid function name "getNumDivisors" (invalid-name)
C:193, 0: Invalid argument name "n" (invalid-name)
C:193, 0: Missing function docstring (missing-docstring)
C:194, 4: Invalid variable name "nDivisors" (invalid-name)
C:196, 4: Invalid variable name "potentialDivisor" (invalid-name)
C:197, 4: Invalid variable name "remainingN" (invalid-name)
C:199, 8: Invalid variable name "divideCount" (invalid-name)
C:201,12: Invalid variable name "divideCount" (invalid-name)
C:202,12: Invalid variable name "remainingN" (invalid-name)
C:205,12: Invalid variable name "nDivisors" (invalid-name)
C:207, 8: Invalid variable name "potentialDivisor" (invalid-name)
C:212, 0: Invalid function name "getNumDivisorsHelped" (invalid-name)
C:212, 0: Invalid argument name "n" (invalid-name)
C:212, 0: Missing function docstring (missing-docstring)
C:217, 8: Invalid variable name "nDivisors" (invalid-name)
C:219, 8: Invalid variable name "potentialDivisor" (invalid-name)
C:220, 8: Invalid variable name "remainingN" (invalid-name)
C:223,16: Invalid variable name "divideCount" (invalid-name)
C:225,20: Invalid variable name "divideCount" (invalid-name)
C:226,20: Invalid variable name "remainingN" (invalid-name)
C:229,20: Invalid variable name "nDivisors" (invalid-name)
C:233,20: Invalid variable name "nDivisors" (invalid-name)
C:234,20: Invalid variable name "remainingN" (invalid-name)
C:236,12: Invalid variable name "potentialDivisor" (invalid-name)
C:243, 0: Invalid argument name "n" (invalid-name)
C:243, 0: Invalid argument name "includeN" (invalid-name)
C:243, 0: Missing function docstring (missing-docstring)
C:263, 0: Invalid argument name "n" (invalid-name)
C:263, 0: Missing function docstring (missing-docstring)
C:269, 0: Invalid function name "millerRabinPrime" (invalid-name)
C:269, 0: Invalid argument name "n" (invalid-name)
C:269, 0: Missing function docstring (missing-docstring)
C:274, 8: Invalid variable name "s" (invalid-name)
C:275, 8: Invalid variable name "d" (invalid-name)
C:277,12: Invalid variable name "d" (invalid-name)
C:278,12: Invalid variable name "s" (invalid-name)
W:289, 8: Else clause on loop without a break statement (useless-else-on-loop)
C:282,12: Invalid variable name "a" (invalid-name)
W:280,39: Unused variable 'i' (unused-variable)
C:295, 0: Invalid function name "storedPrimes" (invalid-name)
C:295, 0: Invalid argument name "n" (invalid-name)
C:295, 0: Missing function docstring (missing-docstring)
W:302,20: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
W:309, 4: No exception type(s) specified (bare-except)
C:297,73: Invalid variable name "f" (invalid-name)
C:299,12: Invalid variable name "nPrimes" (invalid-name)
C:314, 8: Invalid variable name "p" (invalid-name)
C:318, 0: Invalid function name "generateStoredPrimes" (invalid-name)
C:318, 0: Invalid argument name "n" (invalid-name)
C:318, 0: Missing function docstring (missing-docstring)
W:326,12: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:321,69: Invalid variable name "f" (invalid-name)
E:332,25: Undefined variable 'sievedPrimes_sieve' (undefined-variable)
E:340,25: Undefined variable 'sievedPrimes_sieve' (undefined-variable)
W:334,20: Unused variable 'i' (unused-variable)
R:318, 0: Too many branches (13/12) (too-many-branches)
C:368, 0: Invalid argument name "n" (invalid-name)
C:368, 0: Missing function docstring (missing-docstring)
C:373, 4: Invalid variable name "s" (invalid-name)
C:377, 4: Invalid variable name "m" (invalid-name)
C:386, 8: Invalid variable name "m" (invalid-name)
C:390, 0: Invalid function name "sievedPrimes_New" (invalid-name)
C:390, 0: Invalid argument name "n" (invalid-name)
C:390, 0: Missing function docstring (missing-docstring)
C:392, 8: Invalid variable name "p" (invalid-name)
C:396, 0: Invalid function name "sievedPrimes" (invalid-name)
C:396, 0: Invalid argument name "n" (invalid-name)
C:396, 0: Missing function docstring (missing-docstring)
C:405, 4: Invalid function name "filterNum" (invalid-name)
C:405, 4: Missing function docstring (missing-docstring)
W:405,18: Redefining built-in 'filter' (redefined-builtin)
C:407, 8: Invalid variable name "myMultiple" (invalid-name)
C:421,16: Invalid variable name "nextPrime" (invalid-name)
C:429,20: Invalid variable name "nextPrime" (invalid-name)
C:433,20: Invalid variable name "nextPrime" (invalid-name)
C:438, 0: Invalid function name "primeFactors" (invalid-name)
C:438, 0: Invalid argument name "n" (invalid-name)
C:438, 0: Missing function docstring (missing-docstring)
C:439, 4: Invalid variable name "workingN" (invalid-name)
C:440, 8: Invalid variable name "p" (invalid-name)
C:445,12: Invalid variable name "workingN" (invalid-name)
C:449, 0: Missing function docstring (missing-docstring)
W:453, 8: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:458, 0: Invalid function name "combinedRow" (invalid-name)
C:458, 0: Invalid argument name "t" (invalid-name)
C:458, 0: Invalid argument name "b" (invalid-name)
C:458, 0: Missing function docstring (missing-docstring)
C:461, 4: Invalid variable name "topRow" (invalid-name)
C:462, 4: Invalid variable name "bottomRow" (invalid-name)
C:466, 8: Invalid variable name "nextNum" (invalid-name)
C:467, 8: Invalid variable name "leftNum" (invalid-name)
C:468, 8: Invalid variable name "rightNum" (invalid-name)
C:477, 0: Invalid function name "getTriangleRouteLength" (invalid-name)
C:477, 0: Missing function docstring (missing-docstring)
C:480, 8: Invalid variable name "bottomRow" (invalid-name)
C:483, 8: Invalid variable name "currentRow" (invalid-name)
C:485, 8: Invalid variable name "newRow" (invalid-name)
C:495, 0: Invalid function name "roughPrimes" (invalid-name)
C:495, 0: Missing function docstring (missing-docstring)
C:506, 8: Invalid attribute name "_highestFound" (invalid-name)
C:503, 0: Missing class docstring (missing-docstring)
C:503, 0: Old-style class defined. (old-style-class)
C:509, 4: Invalid method name "_factorInPrimes" (invalid-name)
C:509, 4: Invalid argument name "n" (invalid-name)
C:509, 4: Missing method docstring (missing-docstring)
C:511,12: Invalid variable name "p" (invalid-name)
C:518, 4: Invalid method name "isPrime" (invalid-name)
C:518, 4: Invalid argument name "n" (invalid-name)
C:518, 4: Missing method docstring (missing-docstring)
W:537,16: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:532,12: Invalid variable name "nextTested" (invalid-name)
C:534,16: Invalid variable name "nextTested" (invalid-name)
C:538,20: Invalid variable name "p" (invalid-name)
R:503, 0: Too few public methods (1/2) (too-few-public-methods)
C:554, 0: Invalid function name "isPrime" (invalid-name)
C:554, 0: Invalid argument name "n" (invalid-name)
C:554, 0: Missing function docstring (missing-docstring)
C:571, 0: Invalid function name "lowestCommonTerms" (invalid-name)
C:571, 0: Invalid argument name "n" (invalid-name)
C:571, 0: Invalid argument name "d" (invalid-name)
C:571, 0: Missing function docstring (missing-docstring)
C:572, 4: Invalid variable name "n2" (invalid-name)
C:573, 4: Invalid variable name "d2" (invalid-name)
C:577,12: Invalid variable name "n2" (invalid-name)
C:578,12: Invalid variable name "d2" (invalid-name)
C:584, 0: Invalid argument name "a" (invalid-name)
C:584, 0: Invalid argument name "b" (invalid-name)
C:584, 0: Missing function docstring (missing-docstring)
C:588, 4: Invalid variable name "bIna" (invalid-name)
C:588,10: Invalid variable name "r" (invalid-name)
W:588, 4: Unused variable 'bIna' (unused-variable)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\utilities\numbers.py:332:26: F821 undefined name 'sievedPrimes_sieve'
D:\Development\pemjh\pemjh\utilities\numbers.py:340:26: F821 undefined name 'sievedPrimes_sieve'

_____________________ [pylint] pemjh/utilities/strings.py _____________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "s" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7,12: Invalid variable name "n" (invalid-name)
C:  7,15: Invalid variable name "c" (invalid-name)
C:  8,16: Invalid variable name "p" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
--------------- coverage: platform win32, python 2.7.10-final-0 ---------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge001\challenge001       7      3      4      3    45%   4, 9-10
pemjh\challenge002\challenge002      12     10      8      7    15%   2-3, 6-16
pemjh\challenge003\challenge003      17     13     10      5    33%   5-23, 28-29
pemjh\challenge004\challenge004      19     16     10      9    14%   5-31, 36-37
pemjh\challenge005\challenge005      24     21     18     17    10%   2-34, 39-40
pemjh\challenge006\challenge006      13     10      4      3    24%   2-18, 23-24
pemjh\challenge007\challenge007      18     13      9      8    22%   5-19, 24-25
pemjh\challenge008\challenge008      16     13     10      9    15%   2-39, 44-45
pemjh\challenge009\challenge009      14     11      8      7    18%   4-16, 21-22
pemjh\challenge010\challenge010      14      9     10      9    25%   6-13, 18-19
pemjh\challenge011\challenge011      39     36     26     25     6%   2-56, 61-62
pemjh\challenge012\challenge012      31     28     14      9    18%   2-3, 7-44
pemjh\challenge013\challenge013      11      8      4      3    27%   2-109, 114-115
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      8      5    17%   2-3, 7-32
pemjh\challenge016\challenge016      12      9      4      3    25%   2-12, 17-18
pemjh\challenge017\challenge017      33     29     16     15    10%   2-39, 42-104, 109-110
pemjh\challenge018\challenge018      26     24      4      3    10%   2-3, 6-31
pemjh\challenge019\challenge019      32     25     18     17    16%   2, 6-9, 12-15, 19-28, 33-40, 45-46
pemjh\challenge020\challenge020      16     12      6      5    23%   2-5, 9-16, 21-22
pemjh\challenge021\challenge021      21     19     14     13     9%   2-3, 7-33
pemjh\challenge022\challenge022      28     21     10      9    21%   5-14, 17-24, 28-32, 37-38
pemjh\challenge023\challenge023      24     18     16     14    20%   2-3, 7-21, 24, 27-29, 34
pemjh\challenge024\challenge024      14     12      6      5    15%   2-3, 7-18
pemjh\challenge025\challenge025      15     13     10      9    12%   2-3, 5-19
pemjh\challenge026\challenge026      21     17     10      9    16%   4-23, 28-29
pemjh\challenge027\challenge027      27     25     14     11    12%   2-3, 6-36
pemjh\challenge028\challenge028      14     11      4      3    22%   2-13, 18-19
pemjh\challenge029\challenge029      14     11      6      5    20%   2-12, 17-18
pemjh\challenge030\challenge030      19     16     10      9    14%   3-16, 21-22
pemjh\challenge031\challenge031      16     12      6      5    23%   2-14, 19, 22-23
pemjh\challenge032\challenge032      20     18     10      9    10%   2-3, 7-27
pemjh\challenge033\challenge033      33     31     18     17     6%   2-3, 7-48
pemjh\challenge034\challenge034      30     28     14     11    11%   2-3, 7-46
pemjh\challenge035\challenge035      38     36     24     23     5%   2-3, 6-59
pemjh\challenge036\challenge036      22     18     10      9    16%   2-7, 11-24, 29-30
pemjh\challenge037\challenge037      27     25     18     15    11%   2-3, 7-36
pemjh\challenge038\challenge038      20     15     10      9    20%   4, 7-21, 26-27
pemjh\challenge039\challenge039      27     23     14     13    12%   2-23, 26-34, 39-40
pemjh\challenge040\challenge040      15     12      6      5    19%   2-13, 18-19
pemjh\challenge041\challenge041      17     15      8      7    12%   2-3, 6-23
pemjh\challenge042\challenge042      30     24     14     13    16%   5-9, 12-36, 41-42
pemjh\challenge043\challenge043      14     12      6      5    15%   2-3, 6-27
pemjh\challenge044\challenge044      27     21     14     13    17%   4, 7-11, 14-29, 34-35
pemjh\challenge045\challenge045      25     19     12      7    30%   2, 5, 9-21, 24-29, 34-35
pemjh\challenge046\challenge046      23     20     12      9    17%   4-5, 8-32
pemjh\challenge047\challenge047      37     34     22     19    10%   4-5, 8-50
pemjh\challenge048\challenge048       7      4      2      1    44%   2-3, 8-10
pemjh\challenge049\challenge049      24     21     16     15    10%   4-5, 8-32
pemjh\challenge050\challenge050      24     22     12     11     8%   2-3, 6-30
pemjh\challenge051\challenge051      38     35     24     21    10%   4-5, 8-50
pemjh\challenge052\challenge052      20     16      8      7    18%   2, 5-22, 27-28
pemjh\challenge053\challenge053      16     14     10      9    12%   2-3, 6-20
pemjh\challenge054\challenge054      71     61     44     43    10%   5-12, 16-19, 22-24, 39-93, 98-111, 115-131, 136
pemjh\challenge055\challenge055      23     19     12      9    20%   2-12, 15-21, 26-27
pemjh\challenge056\challenge056      14     11      8      7    18%   2-11, 16-17
pemjh\challenge057\challenge057      15     12      8      7    17%   2-15, 20-21
pemjh\challenge058\challenge058      26     24     12      9    13%   2-3, 6-38
pemjh\challenge059\challenge059      29     22     19     18    17%   6-21, 27-45, 48-49
pemjh\challenge060\challenge060      75     73     37     36     3%   2-3, 7-119
pemjh\challenge061\challenge061      65     59     42     41     7%   4, 7-22, 28-99, 104
pemjh\challenge062\challenge062      23     19      8      5    23%   4-29, 34
pemjh\challenge063\challenge063      18     14      6      3    29%   4-22, 27-28
pemjh\challenge064\challenge064      24     23      8      8     3%   3-39
pemjh\challenge065\challenge065      20     18      8      7    11%   2-3, 6-37
pemjh\challenge066\challenge066      15     14      8      8     4%   5-23
pemjh\challenge067\challenge067      17     13      6      5    22%   5-6, 11-25
pemjh\challenge068\challenge068      48     43     32     31     8%   2-5, 8-21, 24-65, 70
pemjh\challenge069\challenge069      20     18     10      9    10%   2-3, 6-24
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
pemjh\challenge071\challenge071      25     21     12     11    14%   4-27, 32
pemjh\challenge072\challenge072      10      8      4      3    21%   2-3, 7-14
pemjh\challenge073\challenge073      31     28     16     15     9%   4-5, 8-42
pemjh\challenge074\challenge074      33     28     10      9    14%   2-3, 6-23, 26-36, 41
pemjh\challenge075\challenge075      16     15      8      8     4%   3-27
pemjh\challenge076\challenge076      20     16     10      9    17%   2-17, 30-32, 37
pemjh\challenge077\challenge077      20     19     12     10     9%   3-34
pemjh\challenge078\challenge078      20     17     12     11    13%   2-19, 24
pemjh\challenge079\challenge079       8      3      2      1    60%   9, 14-15
pemjh\challenge080\challenge080      26     21     12     11    16%   5-26, 29-34, 39
pemjh\challenge081\challenge081      32     26     13     12    16%   5-17, 20-41, 46
pemjh\challenge082\challenge082      34     27     12     11    17%   7-37, 41-48, 53
pemjh\challenge083\challenge083      45     38     20     19    12%   6-14, 17-25, 29-75, 80
pemjh\challenge084\challenge084      74     67     48     47     7%   4-6, 10-50, 54-66, 69-109, 114
pemjh\challenge085\challenge085      34     30     16     11    18%   3-10, 13-46, 51
pemjh\challenge086\challenge086      32     26     14     11    20%   2, 6-17, 20-25, 28-39, 44
pemjh\challenge087\challenge087      30     28     14     13     7%   2-3, 5-40
pemjh\challenge088\challenge088      24     19     12     11    17%   5-19, 22-31, 36
pemjh\challenge089\challenge089      51     42     26     25    13%   18-31, 35-51, 54-65, 69-79, 83-85, 90
pemjh\challenge090\challenge090      78     68     50     49     9%   5-18, 21-27, 30-33, 36-69, 74-114, 117-127, 132
pemjh\challenge091\challenge091      23     19     20     19    12%   2-30, 33-35, 40
pemjh\challenge092\challenge092      96     94     50     45     5%   2-3, 6-124
pemjh\challenge093\challenge093      67     59     50     49     8%   4-10, 14-24, 27-32, 35-58, 61-97, 102
pemjh\challenge094\challenge094      35     30     12     11    13%   2-7, 11-48, 54
pemjh\challenge095\challenge095      35     30     22     21    11%   3-10, 14-48, 51-56, 61
pemjh\challenge096\challenge096     181    155    116    115     9%   7-14, 22-34, 40-44, 47-59, 62-69, 73-94, 97-105, 108-115, 118-146, 150-155, 158-174, 178-181, 184-221, 224-228, 231-235, 238-241, 244-254, 257-277, 294
pemjh\challenge097\challenge097       6      3      2      1    50%   2, 7-8
pemjh\challenge098\challenge098      62     54     34     33     9%   5-13, 16-23, 26-30, 33-93, 98
pemjh\challenge099\challenge099      17     12      7      6    25%   5-14, 19-20
pemjh\challenge100\challenge100       9      6      4      3    31%   2-6, 11
pemjh\challenge101\challenge101      26     23     18     17     9%   2-38, 43
pemjh\challenge102\challenge102      34     27     14     13    17%   9-31, 35-41, 45-53, 59
pemjh\challenge103\challenge103      40     35     30     29     9%   3-12, 16-34, 37-56, 61
pemjh\challenge104\challenge104      34     33     15     15     2%   3-50
pemjh\challenge105\challenge105      40     32     22     21    15%   5-19, 22-28, 32-47, 51-58, 65
pemjh\challenge106\challenge106      37     30     16     15    15%   2-14, 17-26, 29-46, 49-60, 63, 68
pemjh\challenge107\challenge107      38     31     12     11    16%   6-34, 37-45, 48-65, 70
pemjh\challenge108\challenge108      35     34     16     16     2%   3-59
pemjh\challenge109\challenge109      37     32     18     17    11%   2-19, 23-29, 32-45, 50
pemjh\challenge110\challenge110      35     34     16     16     2%   3-59
pemjh\challenge111\challenge111      38     37     31     31     1%   3-54
pemjh\challenge112\challenge112      32     28     20     17    13%   2-27, 30-43, 48
pemjh\challenge113\challenge113      16     14      6      5    14%   2-3, 6-61
pemjh\challenge114\challenge114      24     19     12     11    17%   2-24, 27-28, 31-32, 37
pemjh\challenge115\challenge115      30     25     14     13    14%   2-25, 28-29, 32-38, 43
pemjh\challenge116\challenge116      24     19     10      9    18%   2-22, 25-28, 31-32, 37
pemjh\challenge117\challenge117      21     16     10      9    19%   2-20, 23-24, 27-28, 33
pemjh\challenge118\challenge118      36     35     14     14     2%   2-52
pemjh\challenge119\challenge119      24     19     10      9    18%   2-7, 12-23, 26-28, 33
pemjh\challenge120\challenge120      10      6      4      3    36%   2-6, 9-10, 15
pemjh\challenge121\challenge121      26     25     10     10     3%   3-39
pemjh\challenge122\challenge122      15     12     12     11    15%   2-23, 28
pemjh\challenge123\challenge123      16     15      6      6     5%   3-20
pemjh\challenge124\challenge124      21     20     14     14     3%   3-41
pemjh\challenge125\challenge125      21     18     12     11    12%   2-24, 29
pemjh\challenge126\challenge126      31     27     24     23     9%   2, 6-36, 41
pemjh\challenge127\challenge127      23     22     15     15     3%   3-35
pemjh\challenge128\challenge128      23     22     10     10     3%   3-33
pemjh\challenge129\challenge129      22     18     10      9    16%   2-8, 11-20, 25-27
pemjh\challenge130\challenge130      21     20      8      8     3%   3-30
pemjh\challenge131\challenge131      22     21     10     10     3%   3-41
pemjh\challenge132\challenge132      16     15      8      8     4%   3-24
pemjh\challenge133\challenge133      10      9      2      2     8%   3-16
pemjh\challenge134\challenge134      42     41     20     20     2%   3-72
pemjh\challenge135\challenge135      15     11     10      9    20%   2-16, 19, 25
pemjh\challenge136\challenge136      19     18     10     10     3%   3-26
pemjh\challenge137\challenge137      16     11      6      5    27%   2-6, 10-17, 20, 25
pemjh\challenge138\challenge138      23     22     14     14     3%   3-34
pemjh\challenge139\challenge139      11     10      6      6     6%   3-19
pemjh\challenge142\challenge142      26     21     18     17    14%   2, 5, 8-34, 39
pemjh\challenge144\challenge144      34     26      6      5    23%   4-5, 9-27, 31-51, 54, 57-67, 72
pemjh\challenge145\challenge145      11      8      4      3    27%   2-10, 15
pemjh\challenge146\challenge146      18     13     14     13    19%   2-6, 9, 17-26, 31
pemjh\challenge148\challenge148      22     17      6      5    21%   2-8, 11-29, 32-34, 39
pemjh\challenge149\challenge149      32     26     12     11    16%   2, 5, 9-27, 30-46, 51
pemjh\challenge151\challenge151      21     17     14     13    14%   2-20, 23, 28
pemjh\challenge162\challenge162       7      3      4      3    45%   2-4, 11
pemjh\challenge164\challenge164      20     16     10      9    17%   3-23, 27-31, 36
pemjh\challenge166\challenge166      40     37     33     32     5%   3-68, 73
pemjh\challenge173\challenge173      21     17      6      5    19%   2-27, 30, 35
pemjh\challenge174\challenge174      27     26     14     14     2%   3-40
pemjh\challenge179\challenge179      18     14      8      7    19%   3-17, 20-21, 26
pemjh\challenge183\challenge183      39     38     12     12     2%   2-56
pemjh\challenge187\challenge187      16     15      8      8     4%   3-22
pemjh\challenge188\challenge188      15     11      6      5    24%   2-10, 13, 18
pemjh\challenge190\challenge190       7      3      6      5    38%   2, 6, 11
pemjh\challenge191\challenge191      48     43     34     33     7%   2-23, 27-70, 73-78, 83
pemjh\challenge197\challenge197      19     15      8      7    19%   2, 5-22, 27
pemjh\challenge203\challenge203      27     26     16     16     2%   3-44
pemjh\challenge204\challenge204      21     20      8      8     3%   3-32
pemjh\challenge205\challenge205      25     20     10      9    17%   2-4, 8-14, 17-27, 32
pemjh\challenge206\challenge206      45     37     16     13    18%   6-10, 13-22, 26-60, 65
pemjh\challenge207\challenge207      20     17      6      5    15%   3-20, 25
pemjh\challenge211\challenge211      46     45     24     24     1%   2-68
pemjh\challenge214\challenge214      45     44     26     26     1%   3-76
pemjh\challenge215\challenge215      45     39     32     31     9%   2-23, 26-29, 32-44, 48-59, 64
pemjh\challenge216\challenge216      67     61     48     47     6%   4-18, 21-44, 47-76, 81
pemjh\challenge220\challenge220      17     13      6      5    22%   2-14, 17, 22
pemjh\challenge225\challenge225      14     11      8      7    18%   4-14, 19
pemjh\challenge230\challenge230      34     30     12     11    11%   2-37, 40-47, 52-53
pemjh\challenge231\challenge231      41     40     14     14     2%   3-72
pemjh\challenge234\challenge234      25     24     10     10     3%   3-44
pemjh\challenge235\challenge235      15     12      8      7    17%   2-14, 19
pemjh\challenge243\challenge243      33     32     20     20     2%   3-49
pemjh\challenge250\challenge250      16     12      8      7    21%   2-18, 21-22, 27
pemjh\challenge259\challenge259      42     32     18     17    18%   4-8, 11, 14, 17, 20, 23-53, 58-63, 66
pemjh\challenge265\challenge265      35     27     10      9    20%   2-9, 13-15, 18, 21-33, 37-47, 50, 55
pemjh\main                           51     33     20     15    32%   7-8, 13-28, 39-57, 63, 66-68
pemjh\utilities\__init__              0      0      0      0   100%   
pemjh\utilities\numbers             394    359    207    199     7%   10-37, 41-60, 64-75, 79-127, 131-136, 140-154, 161-175, 179-182, 186-190, 194-209, 214-240, 244-260, 264-266, 270-292, 296-315, 319-365, 369-387, 391-393, 398-435, 439-446, 450-455, 461-474, 478-492, 496-500, 505-507, 510-516, 520-549, 555-568, 572-581, 585-594
pemjh\utilities\strings               8      7      6      6     7%   2-10
-----------------------------------------------------------------------------
TOTAL                              5363   4639   2784   2575    11%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\python27_64\Lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "E:\software_tools\python\python27_64\Lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\Development\pemjh\.tox\py27\Scripts\py.test.EXE\__main__.py", line 9, in <module>
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py27\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py27\lib\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
pytest_cov.plugin.CoverageError: Required test coverage of 100% not reached. Total coverage: 11.45%
ERROR: InvocationError: 'D:\\Development\\pemjh\\.tox\\py27\\Scripts\\py.test.EXE --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100'
py27_64 create: D:\Development\pemjh\.tox\py27_64
ERROR: invocation failed (exit code 1), logfile: D:\Development\pemjh\.tox\py27_64\log\py27_64-0.log
ERROR: actionid: py27_64
msg: getenv
cmdargs: ['D:\\Development\\pemjh\\.venv\\py27_64\\Scripts\\python.exe', '-m', 'virtualenv', '--python', 'D:\\Development\\pemjh\\.venv\\py27_64\\Scripts\\python.exe', 'py27_64']
env: {'TMP': 'C:\\Users\\Matt\\AppData\\Local\\Temp', 'COMPUTERNAME': 'SLAYER', 'VS140COMNTOOLS': 'C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\Common7\\Tools\\', 'VS110COMNTOOLS': 'C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\Common7\\Tools\\', 'USERDOMAIN': 'SLAYER', 'AV_APPDATA': 'C:\\Users\\Matt\\AppData\\Roaming', 'PSMODULEPATH': 'C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules\\', 'COMMONPROGRAMFILES': 'C:\\Program Files\\Common Files', 'PROCESSOR_IDENTIFIER': 'AMD64 Family 21 Model 2 Stepping 0, AuthenticAMD', 'VBOX_MSI_INSTALL_PATH': 'C:\\Program Files\\Oracle\\VirtualBox\\', 'PROGRAMFILES': 'C:\\Program Files', 'PROCESSOR_REVISION': '0200', 'PATH': 'D:\\Development\\pemjh\\.tox\\py27_64\\Scripts;D:\\Development\\pemjh\\.venv\\py27_64\\Scripts;E:\\software_tools\\python\\python27_64;E:\\software_tools\\python\\python27_64\\Scripts;E:\\software_tools\\python\\pypy-2.6.1-win32;E:\\software_tools\\python\\pypy-2.6.1-win32\\bin;E:\\software_tools\\python\\python34_64;E:\\software_tools\\python\\python34_64\\Scripts;E:\\software_tools\\python\\python27;E:\\software_tools\\python\\python27\\Scripts;E:\\software_tools\\python\\python34;E:\\software_tools\\python\\python34\\Scripts;C:\\Program Files\\Haskell\\bin;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\lib\\extralibs\\bin;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\bin;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files (x86)\\EasyPHP-DevServer-14.1VC11\\binaries\\php\\php_runningversion;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Program Files\\Common Files\\Microsoft Shared\\Windows Live;C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\Windows Live;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\ATI Technologies\\ATI.ACE\\Core-Static;C:\\Program Files (x86)\\Windows Live\\Shared;C:\\Program Files (x86)\\AMD\\ATI.ACE\\Core-Static;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\mingw\\bin;C:\\Program Files\\Microsoft SQL Server\\110\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\120\\Tools\\Binn\\;C:\\Program Files\\TortoiseHg\\;C:\\WINDOWS\\system32\\config\\systemprofile\\.dnx\\bin;C:\\Program Files\\Microsoft DNX\\Dnvm\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\QuickTime\\QTSystem\\;C:\\Users\\Matt\\AppData\\Roaming\\cabal\\bin', 'SYSTEMROOT': 'C:\\WINDOWS', 'PROGRAMFILES(X86)': 'C:\\Program Files (x86)', '_OLD_VIRTUAL_PATH': 'E:\\software_tools\\python\\python27_64;E:\\software_tools\\python\\python27_64\\Scripts;E:\\software_tools\\python\\pypy-2.6.1-win32;E:\\software_tools\\python\\pypy-2.6.1-win32\\bin;E:\\software_tools\\python\\python34_64;E:\\software_tools\\python\\python34_64\\Scripts;E:\\software_tools\\python\\python27;E:\\software_tools\\python\\python27\\Scripts;E:\\software_tools\\python\\python34;E:\\software_tools\\python\\python34\\Scripts;C:\\Program Files\\Haskell\\bin;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\lib\\extralibs\\bin;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\bin;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files (x86)\\EasyPHP-DevServer-14.1VC11\\binaries\\php\\php_runningversion;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Program Files\\Common Files\\Microsoft Shared\\Windows Live;C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\Windows Live;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\ATI Technologies\\ATI.ACE\\Core-Static;C:\\Program Files (x86)\\Windows Live\\Shared;C:\\Program Files (x86)\\AMD\\ATI.ACE\\Core-Static;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\mingw\\bin;C:\\Program Files\\Microsoft SQL Server\\110\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\120\\Tools\\Binn\\;C:\\Program Files\\TortoiseHg\\;C:\\WINDOWS\\system32\\config\\systemprofile\\.dnx\\bin;C:\\Program Files\\Microsoft DNX\\Dnvm\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\QuickTime\\QTSystem\\;C:\\Users\\Matt\\AppData\\Roaming\\cabal\\bin', 'VIRTUAL_ENV': 'D:\\Development\\pemjh\\.tox\\py27_64', 'TEMP': 'C:\\Users\\Matt\\AppData\\Local\\Temp', 'COMMONPROGRAMFILES(X86)': 'C:\\Program Files (x86)\\Common Files', 'PROCESSOR_ARCHITECTURE': 'AMD64', 'ALLUSERSPROFILE': 'C:\\ProgramData', 'PYTHONHASHSEED': '631', 'LOCALAPPDATA': 'C:\\Users\\Matt\\AppData\\Local', 'FPS_BROWSER_USER_PROFILE_STRING': 'Default', 'HOMEPATH': '\\Users\\Matt', 'USERDOMAIN_ROAMINGPROFILE': 'SLAYER', 'VS120COMNTOOLS': 'C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\Tools\\', 'PROGRAMW6432': 'C:\\Program Files', 'USERNAME': 'Matt', 'LOGONSERVER': '\\\\MicrosoftAccount', 'PROMPT': 'py27_64 $P$G', 'SESSIONNAME': 'Console', 'PROGRAMDATA': 'C:\\ProgramData', 'PLAT': 'win-amd64', 'FPS_BROWSER_APP_PROFILE_STRING': 'Internet Explorer', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY', 'ASL.LOG': 'Destination=file', 'FP_NO_HOST_CHECK': 'NO', 'WINDIR': 'C:\\WINDOWS', 'OPENSSL_CONF': 'C:\\Program Files\\PostgreSQL\\psqlODBC\\0903\\etc\\openssl.cnf', 'HOMEDRIVE': 'C:', 'APPDATA': 'C:\\Users\\Matt\\AppData\\Roaming', 'SYSTEMDRIVE': 'C:', 'VIRTUALENVDIR': 'cd\\virtualenvs', 'COMSPEC': 'C:\\WINDOWS\\system32\\cmd.exe', 'NUMBER_OF_PROCESSORS': '6', '_OLD_VIRTUAL_PROMPT': '$P$G', 'PROCESSOR_LEVEL': '21', 'COMMONPROGRAMW6432': 'C:\\Program Files\\Common Files', 'OS': 'Windows_NT', 'PUBLIC': 'C:\\Users\\Public', 'USERPROFILE': 'C:\\Users\\Matt'}

D:\Development\pemjh\.venv\py27_64\Scripts\python.exe: No module named virtualenv

ERROR: InvocationError: D:\Development\pemjh\.venv\py27_64\Scripts\python.exe -m virtualenv --python D:\Development\pemjh\.venv\py27_64\Scripts\python.exe py27_64 (see D:\Development\pemjh\.tox\py27_64\log\py27_64-0.log)
py34 inst-nodeps: D:\Development\pemjh\.tox\dist\pemjh-0.0.1.zip
py34 installed: apipkg==1.4,astroid==1.3.8,colorama==0.3.3,coverage==3.7.1,execnet==1.4.1,flake8==2.4.1,logilab-common==1.0.2,mccabe==0.3.1,pemjh==0.0.1,pep8==1.5.7,py==1.4.30,pyflakes==0.8.1,pylint==1.4.4,pytest==2.7.2,pytest-cache==1.0,pytest-cov==2.1.0,pytest-flake8==0.1,pytest-pylint==0.3.0,six==1.9.0,wheel==0.24.0
py34 runtests: PYTHONHASHSEED='631'
py34 runtests: commands[0] | py.test --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100
============================= test session starts =============================
platform win32 -- Python 3.4.3 -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh, inifile: 
plugins: cache, cov, flake8, pylint
collected 364 items / 179 errors

setup.py FF
pemjh\main.py FF
pemjh\challenge001\challenge001.py FF
pemjh\challenge002\challenge002.py FF
pemjh\challenge003\challenge003.py FF
pemjh\challenge004\challenge004.py FF
pemjh\challenge005\challenge005.py FF
pemjh\challenge006\challenge006.py FF
pemjh\challenge007\challenge007.py FF
pemjh\challenge008\challenge008.py FF
pemjh\challenge009\challenge009.py FF
pemjh\challenge010\challenge010.py FF
pemjh\challenge011\challenge011.py FF
pemjh\challenge012\challenge012.py FF
pemjh\challenge013\challenge013.py FF
pemjh\challenge014\challenge014.py FF
pemjh\challenge015\challenge015.py FF
pemjh\challenge016\challenge016.py FF
pemjh\challenge017\challenge017.py FF
pemjh\challenge018\challenge018.py FF
pemjh\challenge019\challenge019.py FF
pemjh\challenge020\challenge020.py FF
pemjh\challenge021\challenge021.py FF
pemjh\challenge022\challenge022.py FF
pemjh\challenge023\challenge023.py FF
pemjh\challenge024\challenge024.py FF
pemjh\challenge025\challenge025.py FF
pemjh\challenge026\challenge026.py FF
pemjh\challenge027\challenge027.py FF
pemjh\challenge028\challenge028.py FF
pemjh\challenge029\challenge029.py FF
pemjh\challenge030\challenge030.py FF
pemjh\challenge031\challenge031.py FF
pemjh\challenge032\challenge032.py FF
pemjh\challenge033\challenge033.py FF
pemjh\challenge034\challenge034.py FF
pemjh\challenge035\challenge035.py FF
pemjh\challenge036\challenge036.py FF
pemjh\challenge037\challenge037.py FF
pemjh\challenge038\challenge038.py FF
pemjh\challenge039\challenge039.py FF
pemjh\challenge040\challenge040.py FF
pemjh\challenge041\challenge041.py FF
pemjh\challenge042\challenge042.py FF
pemjh\challenge043\challenge043.py FF
pemjh\challenge044\challenge044.py FF
pemjh\challenge045\challenge045.py FF
pemjh\challenge046\challenge046.py FF
pemjh\challenge047\challenge047.py FF
pemjh\challenge048\challenge048.py FF
pemjh\challenge049\challenge049.py FF
pemjh\challenge050\challenge050.py FF
pemjh\challenge051\challenge051.py FF
pemjh\challenge052\challenge052.py FF
pemjh\challenge053\challenge053.py FF
pemjh\challenge054\challenge054.py FF
pemjh\challenge055\challenge055.py FF
pemjh\challenge056\challenge056.py FF
pemjh\challenge057\challenge057.py FF
pemjh\challenge058\challenge058.py FF
pemjh\challenge059\challenge059.py FF
pemjh\challenge060\challenge060.py FF
pemjh\challenge061\challenge061.py FF
pemjh\challenge062\challenge062.py FF
pemjh\challenge063\challenge063.py FF
pemjh\challenge064\challenge064.py FF
pemjh\challenge065\challenge065.py FF
pemjh\challenge066\challenge066.py FF
pemjh\challenge067\challenge067.py FF
pemjh\challenge068\challenge068.py FF
pemjh\challenge069\challenge069.py FF
pemjh\challenge070\challenge070.py FF
pemjh\challenge071\challenge071.py FF
pemjh\challenge072\challenge072.py FF
pemjh\challenge073\challenge073.py FF
pemjh\challenge074\challenge074.py FF
pemjh\challenge075\challenge075.py FF
pemjh\challenge076\challenge076.py FF
pemjh\challenge077\challenge077.py FF
pemjh\challenge078\challenge078.py FF
pemjh\challenge079\challenge079.py FF
pemjh\challenge080\challenge080.py FF
pemjh\challenge081\challenge081.py FF
pemjh\challenge082\challenge082.py FF
pemjh\challenge083\challenge083.py FF
pemjh\challenge084\challenge084.py FF
pemjh\challenge085\challenge085.py FF
pemjh\challenge086\challenge086.py FF
pemjh\challenge087\challenge087.py FF
pemjh\challenge088\challenge088.py FF
pemjh\challenge089\challenge089.py FF
pemjh\challenge090\challenge090.py FF
pemjh\challenge091\challenge091.py FF
pemjh\challenge092\challenge092.py FF
pemjh\challenge093\challenge093.py FF
pemjh\challenge094\challenge094.py FF
pemjh\challenge095\challenge095.py FF
pemjh\challenge096\challenge096.py FF
pemjh\challenge097\challenge097.py FF
pemjh\challenge098\challenge098.py FF
pemjh\challenge099\challenge099.py FF
pemjh\challenge100\challenge100.py FF
pemjh\challenge101\challenge101.py FF
pemjh\challenge102\challenge102.py FF
pemjh\challenge103\challenge103.py FF
pemjh\challenge104\challenge104.py FF
pemjh\challenge105\challenge105.py FF
pemjh\challenge106\challenge106.py FF
pemjh\challenge107\challenge107.py FF
pemjh\challenge108\challenge108.py FF
pemjh\challenge109\challenge109.py FF
pemjh\challenge110\challenge110.py FF
pemjh\challenge111\challenge111.py FF
pemjh\challenge112\challenge112.py FF
pemjh\challenge113\challenge113.py FF
pemjh\challenge114\challenge114.py FF
pemjh\challenge115\challenge115.py FF
pemjh\challenge116\challenge116.py FF
pemjh\challenge117\challenge117.py FF
pemjh\challenge118\challenge118.py FF
pemjh\challenge119\challenge119.py FF
pemjh\challenge120\challenge120.py FF
pemjh\challenge121\challenge121.py FF
pemjh\challenge122\challenge122.py FF
pemjh\challenge123\challenge123.py FF
pemjh\challenge124\challenge124.py FF
pemjh\challenge125\challenge125.py FF
pemjh\challenge126\challenge126.py FF
pemjh\challenge127\challenge127.py FF
pemjh\challenge128\challenge128.py FF
pemjh\challenge129\challenge129.py FF
pemjh\challenge130\challenge130.py FF
pemjh\challenge131\challenge131.py FF
pemjh\challenge132\challenge132.py FF
pemjh\challenge133\challenge133.py FF
pemjh\challenge134\challenge134.py FF
pemjh\challenge135\challenge135.py FF
pemjh\challenge136\challenge136.py FF
pemjh\challenge137\challenge137.py FF
pemjh\challenge138\challenge138.py FF
pemjh\challenge139\challenge139.py FF
pemjh\challenge142\challenge142.py FF
pemjh\challenge144\challenge144.py FF
pemjh\challenge145\challenge145.py FF
pemjh\challenge146\challenge146.py FF
pemjh\challenge148\challenge148.py FF
pemjh\challenge149\challenge149.py FF
pemjh\challenge151\challenge151.py FF
pemjh\challenge162\challenge162.py FF
pemjh\challenge164\challenge164.py FF
pemjh\challenge166\challenge166.py FF
pemjh\challenge173\challenge173.py FF
pemjh\challenge174\challenge174.py FF
pemjh\challenge179\challenge179.py FF
pemjh\challenge183\challenge183.py FF
pemjh\challenge187\challenge187.py FF
pemjh\challenge188\challenge188.py FF
pemjh\challenge190\challenge190.py FF
pemjh\challenge191\challenge191.py FF
pemjh\challenge197\challenge197.py FF
pemjh\challenge203\challenge203.py FF
pemjh\challenge204\challenge204.py FF
pemjh\challenge205\challenge205.py FF
pemjh\challenge206\challenge206.py FF
pemjh\challenge207\challenge207.py FF
pemjh\challenge211\challenge211.py FF
pemjh\challenge214\challenge214.py FF
pemjh\challenge215\challenge215.py FF
pemjh\challenge216\challenge216.py FF
pemjh\challenge220\challenge220.py FF
pemjh\challenge225\challenge225.py FF
pemjh\challenge230\challenge230.py FF
pemjh\challenge231\challenge231.py FF
pemjh\challenge234\challenge234.py FF
pemjh\challenge235\challenge235.py FF
pemjh\challenge243\challenge243.py FF
pemjh\challenge250\challenge250.py FF
pemjh\challenge259\challenge259.py FF
pemjh\challenge265\challenge265.py FF
pemjh\utilities\__init__.py ..
pemjh\utilities\numbers.py FF
pemjh\utilities\strings.py F.

=================================== ERRORS ====================================
__________________________ ERROR collecting setup.py __________________________

self = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
func = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
self       = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>, attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000046C39D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = None
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000046C39D8>
self       = <DoctestModule 'setup.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'setup.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\setup.py'), modname = 'setup'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'setup'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh')
self       = local('D:\\Development\\pemjh\\setup.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    https://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands"""
    
    import os
    import sys
    from setuptools import setup
    from setuptools.command.test import test as TestCommand
    
    def read(fname):
        return open(os.path.join(os.path.dirname(__file__), fname)).read()
    
    class Tox(TestCommand):
        user_options = [('tox-args=', 'a', "Arguments to pass to tox")]
        def initialize_options(self):
            TestCommand.initialize_options(self)
            self.tox_args = None
        def finalize_options(self):
            TestCommand.finalize_options(self)
            self.test_args = []
            self.test_suite = True
        def run_tests(self):
            #import here, cause outside the eggs aren't loaded
            import tox
            import shlex
            args = self.tox_args
            if args:
                args = shlex.split(self.tox_args)
            errno = tox.cmdline(args=args)
            sys.exit(errno)
    
    setup(
        name = "pemjh",
        version = "0.0.1",
        author = "Matthew Hussey",
        author_email = "matthew.hussey@googlemail.com",
        description = ("Project euler (https://projecteuler.net/) challenge "
                       "code in Python."),
        license = "None, private use by myself only",
        keywords = "code challenge euler",
        url = "none.non",
        packages = ["pemjh"],
        long_description = read("README"),
        classifiers=[
            "Development Status :: 1 - Planning"],
        tests_require=['tox'],
>       cmdclass = {"test": Tox},
    )

TestCommand = <class 'setuptools.command.test.test'>
Tox        = <class 'setup.Tox'>
__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\__pycache__\\setup.cpython-34.pyc'
__doc__    = ' Setup file for install and test. Taken from:\nhttps://pythonhosted.org/an_example_pypi_project/setuptools.html\nfor ...html\nfor tox:\nhttps://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands'
__file__   = 'D:\\Development\\pemjh\\setup.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x0000000004956B70>
__name__   = 'setup'
__package__ = ''
__spec__   = ModuleSpec(name='setup', loader=<_frozen_importlib.SourceFileLoader object at 0x0000000004956B70>, origin='D:\\Development\\pemjh\\setup.py')
__warningregistry__ = {'version': 1, ("unclosed file <_io.TextIOWrapper name='D:\\\\Development\\\\pemjh\\\\README' mode='r' encoding='cp1252'>", <class 'ResourceWarning'>, 14): True}
os         = <module 'os' from 'd:\\development\\pemjh\\.tox\\py34\\lib\\os.py'>
read       = <function read at 0x00000000049621E0>
setup      = <function setup at 0x0000000003B52D90>
sys        = <module 'sys' (built-in)>

setup.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

attrs = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class 'setup.Tox'>}, ...}
klass = <class 'setuptools.dist.Distribution'>
dist = <setuptools.dist.Distribution object at 0x0000000004963160>

    def setup (**attrs):
        """The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
    
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
    
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
    
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.
        """
    
        global _setup_stop_after, _setup_distribution
    
        # Determine the distribution class -- either caller-supplied or
        # our Distribution (see below).
        klass = attrs.get('distclass')
        if klass:
            del attrs['distclass']
        else:
            klass = Distribution
    
        if 'script_name' not in attrs:
            attrs['script_name'] = os.path.basename(sys.argv[0])
        if 'script_args'  not in attrs:
            attrs['script_args'] = sys.argv[1:]
    
        # Create the Distribution instance, using the remaining arguments
        # (ie. everything except distclass) to initialize it
        try:
            _setup_distribution = dist = klass(attrs)
        except DistutilsSetupError as msg:
            if 'name' not in attrs:
                raise SystemExit("error in setup command: %s" % msg)
            else:
                raise SystemExit("error in %s setup command: %s" % \
                      (attrs['name'], msg))
    
        if _setup_stop_after == "init":
            return dist
    
        # Find and parse the config file(s): they will override options from
        # the setup script, but be overridden by the command line.
        dist.parse_config_files()
    
        if DEBUG:
            print("options (after parsing config files):")
            dist.dump_option_dicts()
    
        if _setup_stop_after == "config":
            return dist
    
        # Parse the command line and override config files; any
        # command-line errors are the end user's fault, so turn them into
        # SystemExit to suppress tracebacks.
        try:
            ok = dist.parse_command_line()
        except DistutilsArgError as msg:
>           raise SystemExit(gen_usage(dist.script_name) + "\nerror: %s" % msg)
E           SystemExit: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
E              or: py.test.EXE --help [cmd1 cmd2 ...]
E              or: py.test.EXE --help-commands
E              or: py.test.EXE cmd --help
E           
E           error: option --pylint not recognized

attrs      = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class 'setup.Tox'>}, ...}
dist       = <setuptools.dist.Distribution object at 0x0000000004963160>
klass      = <class 'setuptools.dist.Distribution'>

E:\software_tools\python\python34_64\Lib\distutils\core.py:136: SystemExit
_______________________ ERROR collecting pemjh/main.py ________________________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (main.py, line 8)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/main.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/main.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (main.py, line 8)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/main.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/main.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/main.py'>, attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A4B6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\main.py', 8, 25, '    print "Psyco working"\n')), <traceback object at 0x0000000004AF0448>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A4B6A8>
self       = <DoctestModule 'pemjh/main.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/main.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/main.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/main.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\main.py'), modname = 'main'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\main.py", line 8
E               print "Psyco working"
E                                   ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'main'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh')
self       = local('D:\\Development\\pemjh\\pemjh\\main.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge001/challenge001.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge001.py, line 10)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge001/challenge001.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge001/challenge001.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge001.py, line 10)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge001/challenge001.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge001/challenge001.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge001/challenge001.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A4B9D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge001\\challenge001.py', 10, 22, '    print challenge001()\n')), <traceback object at 0x0000000004B84E48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A4B9D8>
self       = <DoctestModule 'pemjh/challenge001/challenge001.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge001/challenge001.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge001/challenge001.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge001/challenge001.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge001\\challenge001.py')
modname = 'challenge001', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge001\challenge001.py", line 10
E               print challenge001()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge001'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge001')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge001\\challenge001.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge002/challenge002.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge002.py, line 16)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge002.py, line 16)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A4B950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py', 16, 22, '    print challenge002()\n')), <traceback object at 0x0000000004BDC648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A4B950>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge002\challenge002.py", line 16
E               print challenge002()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge003/challenge003.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge003.py, line 29)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge003/challenge003.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge003/challenge003.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge003.py, line 29)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge003/challenge003.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge003/challenge003.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge003/challenge003.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A0E9D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge003\\challenge003.py', 29, 22, '    print challenge003()\n')), <traceback object at 0x0000000004B95348>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A0E9D8>
self       = <DoctestModule 'pemjh/challenge003/challenge003.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge003/challenge003.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge003/challenge003.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge003/challenge003.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge003\\challenge003.py')
modname = 'challenge003', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge003\challenge003.py", line 29
E               print challenge003()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge003'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge003')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge003\\challenge003.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge004/challenge004.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge004.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge004/challenge004.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge004/challenge004.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge004.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge004/challenge004.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge004/challenge004.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge004/challenge004.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A0EB70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge004\\challenge004.py', 37, 22, '    print challenge004()\n')), <traceback object at 0x0000000004B89608>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004A0EB70>
self       = <DoctestModule 'pemjh/challenge004/challenge004.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge004/challenge004.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge004/challenge004.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge004/challenge004.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge004\\challenge004.py')
modname = 'challenge004', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge004\challenge004.py", line 37
E               print challenge004()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge004'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge004')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge004\\challenge004.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge005/challenge005.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge005.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge005/challenge005.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge005/challenge005.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge005.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge005/challenge005.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge005/challenge005.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge005/challenge005.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5D7B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge005\\challenge005.py', 40, 22, '    print challenge005()\n')), <traceback object at 0x0000000004AF09C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5D7B8>
self       = <DoctestModule 'pemjh/challenge005/challenge005.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge005/challenge005.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge005/challenge005.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge005/challenge005.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge005\\challenge005.py')
modname = 'challenge005', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge005\challenge005.py", line 40
E               print challenge005()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge005'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge005')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge005\\challenge005.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge006/challenge006.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge006.py, line 24)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge006/challenge006.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge006/challenge006.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge006.py, line 24)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge006/challenge006.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge006/challenge006.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge006/challenge006.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5D9D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge006\\challenge006.py', 24, 22, '    print challenge006()\n')), <traceback object at 0x0000000004ADD388>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5D9D8>
self       = <DoctestModule 'pemjh/challenge006/challenge006.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge006/challenge006.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge006/challenge006.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge006/challenge006.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge006\\challenge006.py')
modname = 'challenge006', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge006\challenge006.py", line 24
E               print challenge006()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge006'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge006')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge006\\challenge006.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge007/challenge007.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge007.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge007/challenge007.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge007/challenge007.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge007.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge007/challenge007.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge007/challenge007.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge007/challenge007.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5DBF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge007\\challenge007.py', 25, 22, '    print challenge007()\n')), <traceback object at 0x0000000004C0D888>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5DBF8>
self       = <DoctestModule 'pemjh/challenge007/challenge007.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge007/challenge007.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge007/challenge007.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge007/challenge007.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge007\\challenge007.py')
modname = 'challenge007', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge007\challenge007.py", line 25
E               print challenge007()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge007'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge007')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge007\\challenge007.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge008/challenge008.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge008.py, line 45)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge008/challenge008.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge008/challenge008.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge008.py, line 45)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge008/challenge008.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge008/challenge008.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge008/challenge008.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5DE18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge008\\challenge008.py', 45, 22, '    print challenge008()\n')), <traceback object at 0x0000000004B71108>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5DE18>
self       = <DoctestModule 'pemjh/challenge008/challenge008.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge008/challenge008.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge008/challenge008.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge008/challenge008.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge008\\challenge008.py')
modname = 'challenge008', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge008\challenge008.py", line 45
E               print challenge008()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge008'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge008')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge008\\challenge008.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge009/challenge009.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge009.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge009/challenge009.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge009/challenge009.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge009.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge009/challenge009.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge009/challenge009.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge009/challenge009.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5D598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge009\\challenge009.py', 22, 22, '    print challenge009()\n')), <traceback object at 0x00000000048C9DC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5D598>
self       = <DoctestModule 'pemjh/challenge009/challenge009.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge009/challenge009.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge009/challenge009.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge009/challenge009.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge009\\challenge009.py')
modname = 'challenge009', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge009\challenge009.py", line 22
E               print challenge009()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge009'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge009')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge009\\challenge009.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge010/challenge010.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge010.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge010/challenge010.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge010/challenge010.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge010.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge010/challenge010.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge010/challenge010.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge010/challenge010.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5DF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge010\\challenge010.py', 19, 22, '    print challenge010()\n')), <traceback object at 0x0000000004AD7F08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B5DF28>
self       = <DoctestModule 'pemjh/challenge010/challenge010.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge010/challenge010.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge010/challenge010.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge010/challenge010.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge010\\challenge010.py')
modname = 'challenge010', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge010\challenge010.py", line 19
E               print challenge010()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge010'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge010')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge010\\challenge010.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge011/challenge011.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge011.py, line 62)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge011/challenge011.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge011/challenge011.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge011.py, line 62)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge011/challenge011.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge011/challenge011.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge011/challenge011.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge011\\challenge011.py', 62, 22, '    print challenge011()\n')), <traceback object at 0x0000000004A4F608>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56510>
self       = <DoctestModule 'pemjh/challenge011/challenge011.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge011/challenge011.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge011/challenge011.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge011/challenge011.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge011\\challenge011.py')
modname = 'challenge011', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge011\challenge011.py", line 62
E               print challenge011()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge011'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge011')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge011\\challenge011.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge012/challenge012.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x0000000004B30848>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56730>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge012\\__pycache__\\challenge012.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x00000000047776D8>
__name__   = 'challenge012'
__package__ = ''
__spec__   = ModuleSpec(name='challenge012', loader=<_frozen_importlib.SourceFileLoader object at 0x00000000047776D8>, origin='D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
sqrt       = <built-in function sqrt>

pemjh\challenge012\challenge012.py:6: ImportError
_____________ ERROR collecting pemjh/challenge013/challenge013.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge013.py, line 115)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge013/challenge013.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge013/challenge013.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge013.py, line 115)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge013/challenge013.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge013/challenge013.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge013/challenge013.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge013\\challenge013.py', 115, 22, '    print challenge013()\n')), <traceback object at 0x0000000004D251C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56840>
self       = <DoctestModule 'pemjh/challenge013/challenge013.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge013/challenge013.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge013/challenge013.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge013/challenge013.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge013\\challenge013.py')
modname = 'challenge013', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge013\challenge013.py", line 115
E               print challenge013()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge013'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge013')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge013\\challenge013.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge015/challenge015.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B569D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x0000000004ABB248>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B569D8>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge015\\__pycache__\\challenge015.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x00000000047D21D0>
__name__   = 'challenge015'
__package__ = ''
__spec__   = ModuleSpec(name='challenge015', loader=<_frozen_importlib.SourceFileLoader object at 0x00000000047D21D0>, origin='D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

pemjh\challenge015\challenge015.py:5: ImportError
_____________ ERROR collecting pemjh/challenge016/challenge016.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge016.py, line 18)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge016/challenge016.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge016/challenge016.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge016.py, line 18)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge016/challenge016.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge016/challenge016.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge016/challenge016.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56C80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge016\\challenge016.py', 18, 22, '    print challenge016()\n')), <traceback object at 0x0000000004A9EDC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56C80>
self       = <DoctestModule 'pemjh/challenge016/challenge016.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge016/challenge016.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge016/challenge016.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge016/challenge016.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge016\\challenge016.py')
modname = 'challenge016', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge016\challenge016.py", line 18
E               print challenge016()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge016'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge016')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge016\\challenge016.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge017/challenge017.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge017.py, line 110)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge017/challenge017.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge017/challenge017.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge017.py, line 110)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge017/challenge017.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge017/challenge017.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge017/challenge017.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge017\\challenge017.py', 110, 22, '    print challenge017()\n')), <traceback object at 0x0000000004CA3688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56E18>
self       = <DoctestModule 'pemjh/challenge017/challenge017.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge017/challenge017.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge017/challenge017.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge017/challenge017.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge017\\challenge017.py')
modname = 'challenge017', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge017\challenge017.py", line 110
E               print challenge017()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge017'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge017')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge017\\challenge017.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge018/challenge018.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge018.py, line 31)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge018.py, line 31)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56B70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py', 31, 22, '    print challenge018()\n')), <traceback object at 0x0000000004CAF6C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56B70>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge018\challenge018.py", line 31
E               print challenge018()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge019/challenge019.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge019.py, line 46)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge019/challenge019.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge019/challenge019.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge019.py, line 46)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge019/challenge019.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge019/challenge019.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge019/challenge019.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge019\\challenge019.py', 46, 22, '    print challenge019()\n')), <traceback object at 0x0000000004CB9688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B56F28>
self       = <DoctestModule 'pemjh/challenge019/challenge019.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge019/challenge019.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge019/challenge019.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge019/challenge019.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge019\\challenge019.py')
modname = 'challenge019', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge019\challenge019.py", line 46
E               print challenge019()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge019'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge019')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge019\\challenge019.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge020/challenge020.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge020.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge020/challenge020.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge020/challenge020.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge020.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge020/challenge020.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge020/challenge020.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge020/challenge020.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge020\\challenge020.py', 22, 22, '    print challenge020()\n')), <traceback object at 0x0000000004CFC748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12510>
self       = <DoctestModule 'pemjh/challenge020/challenge020.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge020/challenge020.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge020/challenge020.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge020/challenge020.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge020\\challenge020.py')
modname = 'challenge020', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge020\challenge020.py", line 22
E               print challenge020()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge020'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge020')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge020\\challenge020.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge021/challenge021.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge021.py, line 33)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge021.py, line 33)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py', 33, 22, '    print challenge021()\n')), <traceback object at 0x0000000004BC6548>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12730>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge021\challenge021.py", line 33
E               print challenge021()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge022/challenge022.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge022.py, line 38)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge022/challenge022.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge022/challenge022.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge022.py, line 38)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge022/challenge022.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge022/challenge022.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge022/challenge022.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge022\\challenge022.py', 38, 22, '    print challenge022()\n')), <traceback object at 0x0000000004BF3788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12950>
self       = <DoctestModule 'pemjh/challenge022/challenge022.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge022/challenge022.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge022/challenge022.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge022/challenge022.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge022\\challenge022.py')
modname = 'challenge022', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge022\challenge022.py", line 38
E               print challenge022()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge022'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge022')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge022\\challenge022.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge023/challenge023.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge023.py, line 34)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge023/challenge023.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge023/challenge023.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge023.py, line 34)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge023/challenge023.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge023/challenge023.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge023/challenge023.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12B70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge023\\challenge023.py', 34, 22, '    print challenge023()\n')), <traceback object at 0x0000000004D0E808>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12B70>
self       = <DoctestModule 'pemjh/challenge023/challenge023.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge023/challenge023.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge023/challenge023.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge023/challenge023.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge023\\challenge023.py')
modname = 'challenge023', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge023\challenge023.py", line 34
E               print challenge023()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge023'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge023')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge023\\challenge023.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge024/challenge024.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge024.py, line 18)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge024.py, line 18)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py', 18, 22, '    print challenge024()\n')), <traceback object at 0x0000000004BF4708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12D90>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge024\challenge024.py", line 18
E               print challenge024()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge025/challenge025.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge025.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge025.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B122F0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py', 19, 22, '    print challenge025()\n')), <traceback object at 0x0000000004BD4288>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B122F0>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge025\challenge025.py", line 19
E               print challenge025()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge026/challenge026.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge026.py, line 29)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge026/challenge026.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge026/challenge026.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge026.py, line 29)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge026/challenge026.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge026/challenge026.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge026/challenge026.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge026\\challenge026.py', 29, 22, '    print challenge026()\n')), <traceback object at 0x0000000004BE5188>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004B12F28>
self       = <DoctestModule 'pemjh/challenge026/challenge026.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge026/challenge026.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge026/challenge026.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge026/challenge026.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge026\\challenge026.py')
modname = 'challenge026', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge026\challenge026.py", line 29
E               print challenge026()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge026'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge026')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge026\\challenge026.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge027/challenge027.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge027.py, line 36)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge027.py, line 36)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACB488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py', 36, 22, '    print challenge027()\n')), <traceback object at 0x0000000004CDBDC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACB488>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge027\challenge027.py", line 36
E               print challenge027()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge028/challenge028.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge028.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge028/challenge028.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge028/challenge028.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge028.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge028/challenge028.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge028/challenge028.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge028/challenge028.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACB6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge028\\challenge028.py', 19, 22, '    print challenge028()\n')), <traceback object at 0x0000000004D29548>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACB6A8>
self       = <DoctestModule 'pemjh/challenge028/challenge028.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge028/challenge028.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge028/challenge028.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge028/challenge028.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge028\\challenge028.py')
modname = 'challenge028', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge028\challenge028.py", line 19
E               print challenge028()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge028'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge028')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge028\\challenge028.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge029/challenge029.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge029.py, line 18)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge029/challenge029.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge029/challenge029.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge029.py, line 18)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge029/challenge029.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge029/challenge029.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge029/challenge029.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACB8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge029\\challenge029.py', 18, 22, '    print challenge029()\n')), <traceback object at 0x0000000004D24908>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACB8C8>
self       = <DoctestModule 'pemjh/challenge029/challenge029.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge029/challenge029.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge029/challenge029.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge029/challenge029.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge029\\challenge029.py')
modname = 'challenge029', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge029\challenge029.py", line 18
E               print challenge029()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge029'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge029')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge029\\challenge029.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge030/challenge030.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge030.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge030/challenge030.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge030/challenge030.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge030.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge030/challenge030.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge030/challenge030.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge030/challenge030.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACBAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge030\\challenge030.py', 22, 22, '    print challenge030()\n')), <traceback object at 0x0000000004AE0DC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACBAE8>
self       = <DoctestModule 'pemjh/challenge030/challenge030.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge030/challenge030.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge030/challenge030.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge030/challenge030.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge030\\challenge030.py')
modname = 'challenge030', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge030\challenge030.py", line 22
E               print challenge030()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge030'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge030')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge030\\challenge030.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge031/challenge031.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge031.py, line 23)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge031/challenge031.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge031/challenge031.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge031.py, line 23)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge031/challenge031.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge031/challenge031.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge031/challenge031.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACBD08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge031\\challenge031.py', 23, 22, '    print challenge031()\n')), <traceback object at 0x0000000004D28688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACBD08>
self       = <DoctestModule 'pemjh/challenge031/challenge031.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge031/challenge031.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge031/challenge031.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge031/challenge031.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge031\\challenge031.py')
modname = 'challenge031', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge031\challenge031.py", line 23
E               print challenge031()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge031'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge031')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge031\\challenge031.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge032/challenge032.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge032.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge032.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACBF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py', 27, 22, '    print challenge032()\n')), <traceback object at 0x0000000004D33688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACBF28>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge032\challenge032.py", line 27
E               print challenge032()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge033/challenge033.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge033.py, line 48)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge033.py, line 48)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACB268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py', 48, 22, '    print challenge033()\n')), <traceback object at 0x0000000004D00688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004ACB268>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge033\challenge033.py", line 48
E               print challenge033()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge034/challenge034.py _____________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge034.py, line 14)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge034.py, line 14)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py', 14, 20, '        print digits, factSum\n')), <traceback object at 0x0000000004BB5708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB400>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge034\challenge034.py", line 14
E               print digits, factSum
E                          ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge035/challenge035.py _____________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge035.py, line 11)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge035.py, line 11)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py', 11, 18, '        print nStr\n')), <traceback object at 0x0000000005D95548>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB598>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge035\challenge035.py", line 11
E               print nStr
E                        ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge036/challenge036.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge036.py, line 30)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge036/challenge036.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge036/challenge036.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge036.py, line 30)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge036/challenge036.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge036/challenge036.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge036/challenge036.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge036\\challenge036.py', 30, 22, '    print challenge036()\n')), <traceback object at 0x0000000005DAD6C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB730>
self       = <DoctestModule 'pemjh/challenge036/challenge036.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge036/challenge036.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge036/challenge036.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge036/challenge036.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge036\\challenge036.py')
modname = 'challenge036', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge036\challenge036.py", line 30
E               print challenge036()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge036'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge036')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge036\\challenge036.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge037/challenge037.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge037.py, line 36)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge037.py, line 36)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py', 36, 22, '    print challenge037()\n')), <traceback object at 0x0000000005D77608>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB950>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge037\challenge037.py", line 36
E               print challenge037()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge038/challenge038.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge038.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge038/challenge038.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge038/challenge038.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge038.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge038/challenge038.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge038/challenge038.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge038/challenge038.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEBB70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge038\\challenge038.py', 27, 22, '    print challenge038()\n')), <traceback object at 0x0000000005D84588>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEBB70>
self       = <DoctestModule 'pemjh/challenge038/challenge038.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge038/challenge038.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge038/challenge038.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge038/challenge038.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge038\\challenge038.py')
modname = 'challenge038', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge038\challenge038.py", line 27
E               print challenge038()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge038'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge038')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge038\\challenge038.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge039/challenge039.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge039.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge039/challenge039.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge039/challenge039.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge039.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge039/challenge039.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge039/challenge039.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge039/challenge039.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEBD90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge039\\challenge039.py', 40, 22, '    print challenge039()\n')), <traceback object at 0x0000000004B699C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEBD90>
self       = <DoctestModule 'pemjh/challenge039/challenge039.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge039/challenge039.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge039/challenge039.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge039/challenge039.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge039\\challenge039.py')
modname = 'challenge039', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge039\challenge039.py", line 40
E               print challenge039()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge039'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge039')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge039\\challenge039.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge040/challenge040.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge040.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge040/challenge040.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge040/challenge040.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge040.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge040/challenge040.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge040/challenge040.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge040/challenge040.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB1E0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge040\\challenge040.py', 19, 22, '    print challenge040()\n')), <traceback object at 0x0000000005D836C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEB1E0>
self       = <DoctestModule 'pemjh/challenge040/challenge040.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge040/challenge040.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge040/challenge040.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge040/challenge040.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge040\\challenge040.py')
modname = 'challenge040', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge040\challenge040.py", line 19
E               print challenge040()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge040'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge040')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge040\\challenge040.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge041/challenge041.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge041.py, line 23)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge041.py, line 23)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEBF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py', 23, 22, '    print challenge041()\n')), <traceback object at 0x0000000004CDB488>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BEBF28>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge041\challenge041.py", line 23
E               print challenge041()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge042/challenge042.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge042.py, line 42)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge042/challenge042.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge042/challenge042.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge042.py, line 42)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge042/challenge042.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge042/challenge042.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge042/challenge042.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0E488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge042\\challenge042.py', 42, 22, '    print challenge042()\n')), <traceback object at 0x0000000004CBD308>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0E488>
self       = <DoctestModule 'pemjh/challenge042/challenge042.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge042/challenge042.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge042/challenge042.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge042/challenge042.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge042\\challenge042.py')
modname = 'challenge042', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge042\challenge042.py", line 42
E               print challenge042()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge042'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge042')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge042\\challenge042.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge043/challenge043.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge043.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge043.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0E6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py', 27, 22, '    print challenge043()\n')), <traceback object at 0x0000000004CB9A88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0E6A8>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge043\challenge043.py", line 27
E               print challenge043()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge044/challenge044.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge044.py, line 35)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge044/challenge044.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge044/challenge044.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge044.py, line 35)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge044/challenge044.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge044/challenge044.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge044/challenge044.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0E8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge044\\challenge044.py', 35, 22, '    print challenge044()\n')), <traceback object at 0x0000000005DA4488>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0E8C8>
self       = <DoctestModule 'pemjh/challenge044/challenge044.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge044/challenge044.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge044/challenge044.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge044/challenge044.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge044\\challenge044.py')
modname = 'challenge044', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge044\challenge044.py", line 35
E               print challenge044()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge044'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge044')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge044\\challenge044.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge045/challenge045.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge045.py, line 35)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge045/challenge045.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge045/challenge045.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge045.py, line 35)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge045/challenge045.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge045/challenge045.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge045/challenge045.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0EAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge045\\challenge045.py', 35, 22, '    print challenge045()\n')), <traceback object at 0x0000000004C5B448>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0EAE8>
self       = <DoctestModule 'pemjh/challenge045/challenge045.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge045/challenge045.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge045/challenge045.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge045/challenge045.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge045\\challenge045.py')
modname = 'challenge045', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge045\challenge045.py", line 35
E               print challenge045()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge045'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge045')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge045\\challenge045.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge046/challenge046.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge046.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge046.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0ED08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py', 32, 22, '    print challenge046()\n')), <traceback object at 0x0000000004C52548>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0ED08>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge046\challenge046.py", line 32
E               print challenge046()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge047/challenge047.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0EF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x0000000004CA86C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0EF28>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge047\\__pycache__\\challenge047.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x0000000004AC8E48>
__name__   = 'challenge047'
__package__ = ''
__spec__   = ModuleSpec(name='challenge047', loader=<_frozen_importlib.SourceFileLoader object at 0x0000000004AC8E48>, origin='D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
count      = <class 'itertools.count'>

pemjh\challenge047\challenge047.py:6: ImportError
_____________ ERROR collecting pemjh/challenge048/challenge048.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge048.py, line 10)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge048/challenge048.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge048/challenge048.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge048.py, line 10)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge048/challenge048.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge048/challenge048.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge048/challenge048.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0E268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge048\\challenge048.py', 10, 22, '    print challenge048()\n')), <traceback object at 0x0000000004C5A6C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0E268>
self       = <DoctestModule 'pemjh/challenge048/challenge048.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge048/challenge048.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge048/challenge048.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge048/challenge048.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge048\\challenge048.py')
modname = 'challenge048', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge048\challenge048.py", line 10
E               print challenge048()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge048'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge048')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge048\\challenge048.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge049/challenge049.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge049.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge049.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0EE18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py', 32, 22, '    print challenge049()\n')), <traceback object at 0x0000000004B8EF08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C0EE18>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge049\challenge049.py", line 32
E               print challenge049()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge050/challenge050.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge050.py, line 30)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge050.py, line 30)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1A488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py', 30, 22, '    print challenge050()\n')), <traceback object at 0x0000000004C00248>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1A488>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge050\challenge050.py", line 30
E               print challenge050()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge051/challenge051.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge051.py, line 50)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge051.py, line 50)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1A6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py', 50, 22, '    print challenge051()\n')), <traceback object at 0x0000000004C4C648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1A6A8>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge051\challenge051.py", line 50
E               print challenge051()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge052/challenge052.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge052.py, line 28)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge052/challenge052.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge052/challenge052.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge052.py, line 28)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge052/challenge052.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge052/challenge052.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge052/challenge052.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1A8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge052\\challenge052.py', 28, 22, '    print challenge052()\n')), <traceback object at 0x0000000004D1D648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1A8C8>
self       = <DoctestModule 'pemjh/challenge052/challenge052.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge052/challenge052.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge052/challenge052.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge052/challenge052.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge052\\challenge052.py')
modname = 'challenge052', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge052\challenge052.py", line 28
E               print challenge052()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge052'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge052')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge052\\challenge052.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge053/challenge053.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge053.py, line 20)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge053.py, line 20)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1AAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py', 20, 22, '    print challenge053()\n')), <traceback object at 0x0000000004ADAB48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1AAE8>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge053\challenge053.py", line 20
E               print challenge053()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge054/challenge054.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge054.py, line 136)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge054/challenge054.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge054/challenge054.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge054.py, line 136)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge054/challenge054.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge054/challenge054.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge054/challenge054.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1AD08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge054\\challenge054.py', 136, 22, '    print challenge054()\n')), <traceback object at 0x0000000004A71288>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1AD08>
self       = <DoctestModule 'pemjh/challenge054/challenge054.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge054/challenge054.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge054/challenge054.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge054/challenge054.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge054\\challenge054.py')
modname = 'challenge054', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge054\challenge054.py", line 136
E               print challenge054()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge054'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge054')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge054\\challenge054.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge055/challenge055.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge055.py, line 2)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge055/challenge055.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge055/challenge055.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge055.py, line 2)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge055/challenge055.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge055/challenge055.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge055/challenge055.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1AF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge055\\challenge055.py', 2, 16, '    workingN = `n`\n')), <traceback object at 0x0000000004BF4088>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1AF28>
self       = <DoctestModule 'pemjh/challenge055/challenge055.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge055/challenge055.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge055/challenge055.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge055/challenge055.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge055\\challenge055.py')
modname = 'challenge055', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge055\challenge055.py", line 2
E               workingN = `n`
E                          ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge055'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge055')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge055\\challenge055.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge056/challenge056.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge056.py, line 17)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge056/challenge056.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge056/challenge056.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge056.py, line 17)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge056/challenge056.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge056/challenge056.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge056/challenge056.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1A268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge056\\challenge056.py', 17, 22, '    print challenge056()\n')), <traceback object at 0x0000000004B79B08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D1A268>
self       = <DoctestModule 'pemjh/challenge056/challenge056.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge056/challenge056.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge056/challenge056.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge056/challenge056.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge056\\challenge056.py')
modname = 'challenge056', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge056\challenge056.py", line 17
E               print challenge056()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge056'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge056')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge056\\challenge056.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge057/challenge057.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge057.py, line 21)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge057/challenge057.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge057/challenge057.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge057.py, line 21)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge057/challenge057.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge057/challenge057.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge057/challenge057.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge057\\challenge057.py', 21, 22, '    print challenge057()\n')), <traceback object at 0x0000000004C28F08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2400>
self       = <DoctestModule 'pemjh/challenge057/challenge057.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge057/challenge057.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge057/challenge057.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge057/challenge057.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge057\\challenge057.py')
modname = 'challenge057', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge057\challenge057.py", line 21
E               print challenge057()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge057'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge057')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge057\\challenge057.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge058/challenge058.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x0000000004CF1508>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2620>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge058\\__pycache__\\challenge058.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x0000000004C02BE0>
__name__   = 'challenge058'
__package__ = ''
__spec__   = ModuleSpec(name='challenge058', loader=<_frozen_importlib.SourceFileLoader object at 0x0000000004C02BE0>, origin='D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

pemjh\challenge058\challenge058.py:4: ImportError
_____________ ERROR collecting pemjh/challenge059/challenge059.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge059.py, line 49)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge059/challenge059.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge059/challenge059.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge059.py, line 49)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge059/challenge059.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge059/challenge059.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge059/challenge059.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF27B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge059\\challenge059.py', 49, 22, '    print challenge059()\n')), <traceback object at 0x0000000004B40188>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF27B8>
self       = <DoctestModule 'pemjh/challenge059/challenge059.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge059/challenge059.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge059/challenge059.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge059/challenge059.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge059\\challenge059.py')
modname = 'challenge059', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge059\challenge059.py", line 49
E               print challenge059()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge059'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge059')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge059\\challenge059.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge060/challenge060.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge060.py, line 119)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge060.py, line 119)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py', 119, 22, '    print challenge060()\n')), <traceback object at 0x0000000004BE0A88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2950>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge060\challenge060.py", line 119
E               print challenge060()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge061/challenge061.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge061.py, line 104)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge061/challenge061.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge061/challenge061.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge061.py, line 104)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge061/challenge061.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge061/challenge061.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge061/challenge061.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2B70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge061\\challenge061.py', 104, 22, '    print challenge061()\n')), <traceback object at 0x0000000005D7EAC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2B70>
self       = <DoctestModule 'pemjh/challenge061/challenge061.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge061/challenge061.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge061/challenge061.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge061/challenge061.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge061\\challenge061.py')
modname = 'challenge061', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge061\challenge061.py", line 104
E               print challenge061()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge061'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge061')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge061\\challenge061.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge062/challenge062.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge062.py, line 34)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge062/challenge062.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge062/challenge062.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge062.py, line 34)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge062/challenge062.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge062/challenge062.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge062/challenge062.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge062\\challenge062.py', 34, 22, '    print challenge062()\n')), <traceback object at 0x0000000004AC7208>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2D90>
self       = <DoctestModule 'pemjh/challenge062/challenge062.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge062/challenge062.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge062/challenge062.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge062/challenge062.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge062\\challenge062.py')
modname = 'challenge062', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge062\challenge062.py", line 34
E               print challenge062()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge062'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge062')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge062\\challenge062.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge063/challenge063.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge063.py, line 28)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge063/challenge063.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge063/challenge063.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge063.py, line 28)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge063/challenge063.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge063/challenge063.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge063/challenge063.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF21E0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge063\\challenge063.py', 28, 22, '    print challenge063()\n')), <traceback object at 0x0000000005DA4B08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF21E0>
self       = <DoctestModule 'pemjh/challenge063/challenge063.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge063/challenge063.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge063/challenge063.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge063/challenge063.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge063\\challenge063.py')
modname = 'challenge063', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge063\challenge063.py", line 28
E               print challenge063()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge063'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge063')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge063\\challenge063.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge064/challenge064.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge064.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge064.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py', 39, 22, '    print challenge064()\n')), <traceback object at 0x0000000004B05708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DF2F28>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge064\challenge064.py", line 39
E               print challenge064()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge065/challenge065.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge065.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge065.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py', 37, 22, '    print challenge065()\n')), <traceback object at 0x0000000004B8F888>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5488>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge065\challenge065.py", line 37
E               print challenge065()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge066/challenge066.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge066.py, line 23)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge066.py, line 23)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD56A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py', 23, 22, '    print challenge066()\n')), <traceback object at 0x0000000004A80D88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD56A8>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge066\challenge066.py", line 23
E               print challenge066()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge067/challenge067.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge067.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge067.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD58C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py', 25, 22, '    print challenge067()\n')), <traceback object at 0x0000000004C5BE48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD58C8>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge067\challenge067.py", line 25
E               print challenge067()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge068/challenge068.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge068.py, line 70)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge068/challenge068.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge068/challenge068.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge068.py, line 70)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge068/challenge068.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge068/challenge068.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge068/challenge068.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5AE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge068\\challenge068.py', 70, 22, '    print challenge068()\n')), <traceback object at 0x0000000004CE1EC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5AE8>
self       = <DoctestModule 'pemjh/challenge068/challenge068.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge068/challenge068.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge068/challenge068.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge068/challenge068.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge068\\challenge068.py')
modname = 'challenge068', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge068\challenge068.py", line 70
E               print challenge068()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge068'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge068')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge068\\challenge068.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge069/challenge069.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge069.py, line 24)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge069.py, line 24)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5D08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py', 24, 22, '    print challenge069()\n')), <traceback object at 0x0000000005DF3F88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5D08>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge069\challenge069.py", line 24
E               print challenge069()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge070/challenge070.py _____________

self = <CallInfo when='memocollect' exception: No module named 'utils'>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named 'utils'>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'ImportError'>, ImportError("No module named 'utils'",), <traceback object at 0x0000000005DF7CC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5F28>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named 'utils'

__builtins__ = <builtins>
__cached__ = 'D:\\Development\\pemjh\\pemjh\\challenge070\\__pycache__\\challenge070.cpython-34.pyc'
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py'
__loader__ = <_frozen_importlib.SourceFileLoader object at 0x0000000004BDA240>
__name__   = 'challenge070'
__package__ = ''
__spec__   = ModuleSpec(name='challenge070', loader=<_frozen_importlib.SourceFileLoader object at 0x0000000004BDA240>, origin='D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

pemjh\challenge070\challenge070.py:4: ImportError
_____________ ERROR collecting pemjh/challenge071/challenge071.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge071.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge071/challenge071.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge071/challenge071.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge071.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge071/challenge071.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge071/challenge071.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge071/challenge071.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge071\\challenge071.py', 32, 22, '    print challenge071()\n')), <traceback object at 0x0000000004CBC788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5268>
self       = <DoctestModule 'pemjh/challenge071/challenge071.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge071/challenge071.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge071/challenge071.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge071/challenge071.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge071\\challenge071.py')
modname = 'challenge071', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge071\challenge071.py", line 32
E               print challenge071()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge071'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge071')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge071\\challenge071.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge072/challenge072.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge072.py, line 14)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge072.py, line 14)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py', 14, 22, '    print challenge072()\n')), <traceback object at 0x0000000004ADB7C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004BD5E18>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge072\challenge072.py", line 14
E               print challenge072()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge073/challenge073.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge073.py, line 42)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge073.py, line 42)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2B488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py', 42, 22, '    print challenge073()\n')), <traceback object at 0x0000000004AB4288>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2B488>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge073\challenge073.py", line 42
E               print challenge073()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge074/challenge074.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge074.py, line 41)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge074/challenge074.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge074/challenge074.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge074.py, line 41)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge074/challenge074.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge074/challenge074.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge074/challenge074.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2B6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge074\\challenge074.py', 41, 22, '    print challenge074()\n')), <traceback object at 0x0000000004D14588>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2B6A8>
self       = <DoctestModule 'pemjh/challenge074/challenge074.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge074/challenge074.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge074/challenge074.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge074/challenge074.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge074\\challenge074.py')
modname = 'challenge074', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge074\challenge074.py", line 41
E               print challenge074()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge074'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge074')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge074\\challenge074.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge075/challenge075.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge075.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge075.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2B8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py', 27, 22, '    print challenge075()\n')), <traceback object at 0x0000000004BD7C08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2B8C8>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge075\challenge075.py", line 27
E               print challenge075()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge076/challenge076.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge076.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge076/challenge076.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge076/challenge076.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge076.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge076/challenge076.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge076/challenge076.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge076/challenge076.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2BAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge076\\challenge076.py', 37, 22, '    print challenge076()\n')), <traceback object at 0x0000000004AA85C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2BAE8>
self       = <DoctestModule 'pemjh/challenge076/challenge076.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge076/challenge076.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge076/challenge076.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge076/challenge076.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge076\\challenge076.py')
modname = 'challenge076', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge076\challenge076.py", line 37
E               print challenge076()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge076'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge076')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge076\\challenge076.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge077/challenge077.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge077.py, line 34)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge077.py, line 34)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2BD08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py', 34, 22, '    print challenge077()\n')), <traceback object at 0x0000000005E7D148>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2BD08>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge077\challenge077.py", line 34
E               print challenge077()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge078/challenge078.py _____________

self = <CallInfo when='memocollect' exception: inconsistent use of tabs and spaces in indentation (challenge078.py, line 6)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge078/challenge078.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge078/challenge078.py'>>
self       = <CallInfo when='memocollect' exception: inconsistent use of tabs and spaces in indentation (challenge078.py, line 6)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge078/challenge078.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge078/challenge078.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge078/challenge078.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2BF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'TabError'>, TabError('inconsistent use of tabs and spaces in indentation', ('D:\\Development\\pemjh\\pemjh\\challenge078\\challenge078.py', 6, 19, '\tj, k, s = 1, 1, 0\n')), <traceback object at 0x0000000005E0FD48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2BF28>
self       = <DoctestModule 'pemjh/challenge078/challenge078.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge078/challenge078.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge078/challenge078.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge078/challenge078.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge078\\challenge078.py')
modname = 'challenge078', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge078\challenge078.py", line 6
E               j, k, s = 1, 1, 0
E                               ^
E           TabError: inconsistent use of tabs and spaces in indentation

ensuresyspath = True
modname    = 'challenge078'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge078')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge078\\challenge078.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: TabError
_____________ ERROR collecting pemjh/challenge079/challenge079.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge079.py, line 15)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge079/challenge079.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge079/challenge079.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge079.py, line 15)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge079/challenge079.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge079/challenge079.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge079/challenge079.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2B268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge079\\challenge079.py', 15, 22, '    print challenge079()\n')), <traceback object at 0x0000000004C21848>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2B268>
self       = <DoctestModule 'pemjh/challenge079/challenge079.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge079/challenge079.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge079/challenge079.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge079/challenge079.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge079\\challenge079.py')
modname = 'challenge079', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge079\challenge079.py", line 15
E               print challenge079()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge079'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge079')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge079\\challenge079.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge080/challenge080.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge080.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge080/challenge080.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge080/challenge080.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge080.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge080/challenge080.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge080/challenge080.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge080/challenge080.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2BE18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge080\\challenge080.py', 39, 22, '    print challenge080()\n')), <traceback object at 0x0000000004BB8F08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E2BE18>
self       = <DoctestModule 'pemjh/challenge080/challenge080.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge080/challenge080.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge080/challenge080.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge080/challenge080.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge080\\challenge080.py')
modname = 'challenge080', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge080\challenge080.py", line 39
E               print challenge080()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge080'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge080')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge080\\challenge080.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge081/challenge081.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge081.py, line 46)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge081/challenge081.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge081/challenge081.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge081.py, line 46)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge081/challenge081.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge081/challenge081.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge081/challenge081.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge081\\challenge081.py', 46, 22, '    print challenge081()\n')), <traceback object at 0x0000000004B673C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40598>
self       = <DoctestModule 'pemjh/challenge081/challenge081.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge081/challenge081.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge081/challenge081.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge081/challenge081.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge081\\challenge081.py')
modname = 'challenge081', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge081\challenge081.py", line 46
E               print challenge081()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge081'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge081')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge081\\challenge081.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge082/challenge082.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge082.py, line 53)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge082/challenge082.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge082/challenge082.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge082.py, line 53)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge082/challenge082.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge082/challenge082.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge082/challenge082.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D407B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge082\\challenge082.py', 53, 22, '    print challenge082()\n')), <traceback object at 0x0000000004B715C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D407B8>
self       = <DoctestModule 'pemjh/challenge082/challenge082.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge082/challenge082.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge082/challenge082.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge082/challenge082.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge082\\challenge082.py')
modname = 'challenge082', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge082\challenge082.py", line 53
E               print challenge082()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge082'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge082')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge082\\challenge082.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge083/challenge083.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge083.py, line 80)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge083/challenge083.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge083/challenge083.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge083.py, line 80)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge083/challenge083.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge083/challenge083.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge083/challenge083.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D409D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge083\\challenge083.py', 80, 22, '    print challenge083()\n')), <traceback object at 0x0000000004B2C588>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D409D8>
self       = <DoctestModule 'pemjh/challenge083/challenge083.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge083/challenge083.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge083/challenge083.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge083/challenge083.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge083\\challenge083.py')
modname = 'challenge083', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge083\challenge083.py", line 80
E               print challenge083()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge083'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge083')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge083\\challenge083.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge084/challenge084.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge084.py, line 114)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge084/challenge084.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge084/challenge084.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge084.py, line 114)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge084/challenge084.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge084/challenge084.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge084/challenge084.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40BF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge084\\challenge084.py', 114, 22, '    print challenge084()\n')), <traceback object at 0x0000000005E72748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40BF8>
self       = <DoctestModule 'pemjh/challenge084/challenge084.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge084/challenge084.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge084/challenge084.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge084/challenge084.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge084\\challenge084.py')
modname = 'challenge084', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge084\challenge084.py", line 114
E               print challenge084()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge084'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge084')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge084\\challenge084.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge085/challenge085.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge085.py, line 51)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge085/challenge085.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge085/challenge085.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge085.py, line 51)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge085/challenge085.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge085/challenge085.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge085/challenge085.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge085\\challenge085.py', 51, 22, '    print challenge085()\n')), <traceback object at 0x0000000004AB8988>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40E18>
self       = <DoctestModule 'pemjh/challenge085/challenge085.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge085/challenge085.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge085/challenge085.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge085/challenge085.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge085\\challenge085.py')
modname = 'challenge085', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge085\challenge085.py", line 51
E               print challenge085()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge085'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge085')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge085\\challenge085.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge086/challenge086.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge086.py, line 44)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge086/challenge086.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge086/challenge086.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge086.py, line 44)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge086/challenge086.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge086/challenge086.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge086/challenge086.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge086\\challenge086.py', 44, 22, '    print challenge086()\n')), <traceback object at 0x0000000004B39DC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40378>
self       = <DoctestModule 'pemjh/challenge086/challenge086.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge086/challenge086.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge086/challenge086.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge086/challenge086.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge086\\challenge086.py')
modname = 'challenge086', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge086\challenge086.py", line 44
E               print challenge086()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge086'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge086')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge086\\challenge086.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge087/challenge087.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge087.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge087.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py', 40, 22, '    print challenge087()\n')), <traceback object at 0x0000000004A6A3C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D40F28>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge087\challenge087.py", line 40
E               print challenge087()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge088/challenge088.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge088.py, line 36)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge088/challenge088.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge088/challenge088.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge088.py, line 36)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge088/challenge088.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge088/challenge088.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge088/challenge088.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3F510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge088\\challenge088.py', 36, 22, '    print challenge088()\n')), <traceback object at 0x0000000004CD5448>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3F510>
self       = <DoctestModule 'pemjh/challenge088/challenge088.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge088/challenge088.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge088/challenge088.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge088/challenge088.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge088\\challenge088.py')
modname = 'challenge088', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge088\challenge088.py", line 36
E               print challenge088()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge088'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge088')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge088\\challenge088.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge089/challenge089.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge089.py, line 90)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge089/challenge089.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge089/challenge089.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge089.py, line 90)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge089/challenge089.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge089/challenge089.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge089/challenge089.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3F730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge089\\challenge089.py', 90, 22, '    print challenge089()\n')), <traceback object at 0x0000000004AD1F08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3F730>
self       = <DoctestModule 'pemjh/challenge089/challenge089.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge089/challenge089.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge089/challenge089.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge089/challenge089.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge089\\challenge089.py')
modname = 'challenge089', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge089\challenge089.py", line 90
E               print challenge089()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge089'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge089')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge089\\challenge089.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge090/challenge090.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge090.py, line 132)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge090/challenge090.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge090/challenge090.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge090.py, line 132)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge090/challenge090.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge090/challenge090.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge090/challenge090.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3F950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge090\\challenge090.py', 132, 22, '    print challenge090()\n')), <traceback object at 0x0000000004C1A788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3F950>
self       = <DoctestModule 'pemjh/challenge090/challenge090.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge090/challenge090.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge090/challenge090.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge090/challenge090.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge090\\challenge090.py')
modname = 'challenge090', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge090\challenge090.py", line 132
E               print challenge090()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge090'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge090')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge090\\challenge090.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge091/challenge091.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge091.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge091/challenge091.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge091/challenge091.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge091.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge091/challenge091.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge091/challenge091.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge091/challenge091.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3FB70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge091\\challenge091.py', 40, 22, '    print challenge091()\n')), <traceback object at 0x0000000004CE1108>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3FB70>
self       = <DoctestModule 'pemjh/challenge091/challenge091.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge091/challenge091.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge091/challenge091.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge091/challenge091.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge091\\challenge091.py')
modname = 'challenge091', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge091\challenge091.py", line 40
E               print challenge091()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge091'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge091')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge091\\challenge091.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge092/challenge092.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge092.py, line 124)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge092.py, line 124)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3FD90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py', 124, 22, '    print challenge092()\n')), <traceback object at 0x0000000005E20088>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3FD90>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge092\challenge092.py", line 124
E               print challenge092()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge093/challenge093.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge093.py, line 102)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge093/challenge093.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge093/challenge093.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge093.py, line 102)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge093/challenge093.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge093/challenge093.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge093/challenge093.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3F2F0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge093\\challenge093.py', 102, 22, '    print challenge093()\n')), <traceback object at 0x0000000004BA2748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3F2F0>
self       = <DoctestModule 'pemjh/challenge093/challenge093.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge093/challenge093.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge093/challenge093.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge093/challenge093.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge093\\challenge093.py')
modname = 'challenge093', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge093\challenge093.py", line 102
E               print challenge093()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge093'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge093')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge093\\challenge093.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge094/challenge094.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge094.py, line 54)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge094/challenge094.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge094/challenge094.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge094.py, line 54)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge094/challenge094.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge094/challenge094.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge094/challenge094.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3FF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge094\\challenge094.py', 54, 22, '    print challenge094()\n')), <traceback object at 0x0000000004B64688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004D3FF28>
self       = <DoctestModule 'pemjh/challenge094/challenge094.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge094/challenge094.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge094/challenge094.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge094/challenge094.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge094\\challenge094.py')
modname = 'challenge094', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge094\challenge094.py", line 54
E               print challenge094()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge094'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge094')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge094\\challenge094.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge095/challenge095.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge095.py, line 61)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge095/challenge095.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge095/challenge095.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge095.py, line 61)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge095/challenge095.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge095/challenge095.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge095/challenge095.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge095\\challenge095.py', 61, 22, '    print challenge095()\n')), <traceback object at 0x0000000005DFD848>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33488>
self       = <DoctestModule 'pemjh/challenge095/challenge095.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge095/challenge095.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge095/challenge095.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge095/challenge095.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge095\\challenge095.py')
modname = 'challenge095', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge095\challenge095.py", line 61
E               print challenge095()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge095'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge095')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge095\\challenge095.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge096/challenge096.py _____________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge096.py, line 271)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge096/challenge096.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge096/challenge096.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge096.py, line 271)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge096/challenge096.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge096/challenge096.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge096/challenge096.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C336A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge096\\challenge096.py', 271, 50, '                print "!!!!!!!!BROKEN!!!!!!!!!!!!"\n')), <traceback object at 0x0000000004B77EC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C336A8>
self       = <DoctestModule 'pemjh/challenge096/challenge096.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge096/challenge096.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge096/challenge096.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge096/challenge096.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge096\\challenge096.py')
modname = 'challenge096', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge096\challenge096.py", line 271
E               print "!!!!!!!!BROKEN!!!!!!!!!!!!"
E                                                ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'challenge096'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge096')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge096\\challenge096.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge097/challenge097.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge097.py, line 8)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge097/challenge097.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge097/challenge097.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge097.py, line 8)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge097/challenge097.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge097/challenge097.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge097/challenge097.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge097\\challenge097.py', 8, 22, '    print challenge097()\n')), <traceback object at 0x0000000004A88408>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33840>
self       = <DoctestModule 'pemjh/challenge097/challenge097.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge097/challenge097.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge097/challenge097.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge097/challenge097.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge097\\challenge097.py')
modname = 'challenge097', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge097\challenge097.py", line 8
E               print challenge097()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge097'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge097')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge097\\challenge097.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge098/challenge098.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge098.py, line 98)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge098/challenge098.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge098/challenge098.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge098.py, line 98)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge098/challenge098.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge098/challenge098.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge098/challenge098.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33A60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge098\\challenge098.py', 98, 22, '    print challenge098()\n')), <traceback object at 0x0000000004B1E0C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33A60>
self       = <DoctestModule 'pemjh/challenge098/challenge098.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge098/challenge098.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge098/challenge098.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge098/challenge098.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge098\\challenge098.py')
modname = 'challenge098', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge098\challenge098.py", line 98
E               print challenge098()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge098'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge098')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge098\\challenge098.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge099/challenge099.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge099.py, line 20)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge099/challenge099.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge099/challenge099.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge099.py, line 20)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge099/challenge099.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge099/challenge099.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge099/challenge099.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33C80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge099\\challenge099.py', 20, 22, '    print challenge099()\n')), <traceback object at 0x0000000004ABB0C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33C80>
self       = <DoctestModule 'pemjh/challenge099/challenge099.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge099/challenge099.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge099/challenge099.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge099/challenge099.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge099\\challenge099.py')
modname = 'challenge099', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge099\challenge099.py", line 20
E               print challenge099()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge099'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge099')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge099\\challenge099.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge100/challenge100.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge100.py, line 11)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge100/challenge100.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge100/challenge100.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge100.py, line 11)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge100/challenge100.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge100/challenge100.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge100/challenge100.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge100\\challenge100.py', 11, 22, '    print challenge100()\n')), <traceback object at 0x0000000005E0B7C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33EA0>
self       = <DoctestModule 'pemjh/challenge100/challenge100.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge100/challenge100.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge100/challenge100.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge100/challenge100.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge100\\challenge100.py')
modname = 'challenge100', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge100\challenge100.py", line 11
E               print challenge100()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge100'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge100')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge100\\challenge100.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge101/challenge101.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge101.py, line 43)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge101/challenge101.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge101/challenge101.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge101.py, line 43)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge101/challenge101.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge101/challenge101.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge101/challenge101.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge101\\challenge101.py', 43, 22, '    print challenge101()\n')), <traceback object at 0x0000000004A865C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000004C33268>
self       = <DoctestModule 'pemjh/challenge101/challenge101.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge101/challenge101.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge101/challenge101.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge101/challenge101.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge101\\challenge101.py')
modname = 'challenge101', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge101\challenge101.py", line 43
E               print challenge101()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge101'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge101')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge101\\challenge101.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge102/challenge102.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge102.py, line 59)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge102/challenge102.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge102/challenge102.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge102.py, line 59)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge102/challenge102.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge102/challenge102.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge102/challenge102.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge102\\challenge102.py', 59, 22, '    print challenge102()\n')), <traceback object at 0x0000000004D2F948>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6378>
self       = <DoctestModule 'pemjh/challenge102/challenge102.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge102/challenge102.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge102/challenge102.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge102/challenge102.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge102\\challenge102.py')
modname = 'challenge102', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge102\challenge102.py", line 59
E               print challenge102()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge102'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge102')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge102\\challenge102.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge103/challenge103.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge103.py, line 61)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge103/challenge103.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge103/challenge103.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge103.py, line 61)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge103/challenge103.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge103/challenge103.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge103/challenge103.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge103\\challenge103.py', 61, 22, '    print challenge103()\n')), <traceback object at 0x0000000004A7EDC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6598>
self       = <DoctestModule 'pemjh/challenge103/challenge103.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge103/challenge103.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge103/challenge103.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge103/challenge103.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge103\\challenge103.py')
modname = 'challenge103', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge103\challenge103.py", line 61
E               print challenge103()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge103'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge103')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge103\\challenge103.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge104/challenge104.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge104.py, line 50)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge104.py, line 50)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE67B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py', 50, 22, '    print challenge104()\n')), <traceback object at 0x0000000004A96088>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE67B8>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge104\challenge104.py", line 50
E               print challenge104()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge105/challenge105.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge105.py, line 65)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge105/challenge105.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge105/challenge105.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge105.py, line 65)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge105/challenge105.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge105/challenge105.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge105/challenge105.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE69D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge105\\challenge105.py', 65, 22, '    print challenge105()\n')), <traceback object at 0x0000000005EA0EC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE69D8>
self       = <DoctestModule 'pemjh/challenge105/challenge105.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge105/challenge105.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge105/challenge105.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge105/challenge105.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge105\\challenge105.py')
modname = 'challenge105', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge105\challenge105.py", line 65
E               print challenge105()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge105'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge105')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge105\\challenge105.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge106/challenge106.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge106.py, line 68)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge106/challenge106.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge106/challenge106.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge106.py, line 68)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge106/challenge106.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge106/challenge106.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge106/challenge106.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6BF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge106\\challenge106.py', 68, 22, '    print challenge106()\n')), <traceback object at 0x0000000005DFA7C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6BF8>
self       = <DoctestModule 'pemjh/challenge106/challenge106.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge106/challenge106.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge106/challenge106.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge106/challenge106.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge106\\challenge106.py')
modname = 'challenge106', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge106\challenge106.py", line 68
E               print challenge106()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge106'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge106')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge106\\challenge106.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge107/challenge107.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge107.py, line 70)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge107/challenge107.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge107/challenge107.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge107.py, line 70)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge107/challenge107.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge107/challenge107.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge107/challenge107.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge107\\challenge107.py', 70, 22, '    print challenge107()\n')), <traceback object at 0x0000000004B1E648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6E18>
self       = <DoctestModule 'pemjh/challenge107/challenge107.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge107/challenge107.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge107/challenge107.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge107/challenge107.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge107\\challenge107.py')
modname = 'challenge107', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge107\challenge107.py", line 70
E               print challenge107()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge107'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge107')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge107\\challenge107.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge108/challenge108.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge108.py, line 59)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge108.py, line 59)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6158>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py', 59, 22, '    print challenge108()\n')), <traceback object at 0x0000000004CA9AC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6158>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge108\challenge108.py", line 59
E               print challenge108()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge109/challenge109.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge109.py, line 50)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge109/challenge109.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge109/challenge109.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge109.py, line 50)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge109/challenge109.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge109/challenge109.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge109/challenge109.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge109\\challenge109.py', 50, 22, '    print challenge109()\n')), <traceback object at 0x0000000004D313C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005DE6F28>
self       = <DoctestModule 'pemjh/challenge109/challenge109.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge109/challenge109.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge109/challenge109.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge109/challenge109.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge109\\challenge109.py')
modname = 'challenge109', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge109\challenge109.py", line 50
E               print challenge109()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge109'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge109')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge109\\challenge109.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge110/challenge110.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge110.py, line 59)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge110.py, line 59)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8F510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py', 59, 22, '    print challenge110()\n')), <traceback object at 0x0000000005D8DB88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8F510>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge110\challenge110.py", line 59
E               print challenge110()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge111/challenge111.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge111.py, line 54)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge111.py, line 54)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8F730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py', 54, 22, '    print challenge111()\n')), <traceback object at 0x0000000004CBE388>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8F730>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge111\challenge111.py", line 54
E               print challenge111()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge112/challenge112.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge112.py, line 48)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge112/challenge112.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge112/challenge112.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge112.py, line 48)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge112/challenge112.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge112/challenge112.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge112/challenge112.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8F950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge112\\challenge112.py', 48, 22, '    print challenge112()\n')), <traceback object at 0x0000000005D34888>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8F950>
self       = <DoctestModule 'pemjh/challenge112/challenge112.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge112/challenge112.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge112/challenge112.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge112/challenge112.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge112\\challenge112.py')
modname = 'challenge112', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge112\challenge112.py", line 48
E               print challenge112()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge112'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge112')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge112\\challenge112.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge113/challenge113.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge113.py, line 61)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge113.py, line 61)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8FB70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py', 61, 22, '    print challenge113()\n')), <traceback object at 0x0000000004B6F508>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8FB70>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge113\challenge113.py", line 61
E               print challenge113()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge114/challenge114.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge114.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge114/challenge114.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge114/challenge114.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge114.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge114/challenge114.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge114/challenge114.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge114/challenge114.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8FD90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge114\\challenge114.py', 37, 22, '    print challenge114()\n')), <traceback object at 0x0000000005F2C248>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8FD90>
self       = <DoctestModule 'pemjh/challenge114/challenge114.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge114/challenge114.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge114/challenge114.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge114/challenge114.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge114\\challenge114.py')
modname = 'challenge114', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge114\challenge114.py", line 37
E               print challenge114()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge114'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge114')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge114\\challenge114.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge115/challenge115.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge115.py, line 43)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge115/challenge115.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge115/challenge115.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge115.py, line 43)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge115/challenge115.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge115/challenge115.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge115/challenge115.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8F2F0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge115\\challenge115.py', 43, 22, '    print challenge115()\n')), <traceback object at 0x0000000005E72488>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8F2F0>
self       = <DoctestModule 'pemjh/challenge115/challenge115.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge115/challenge115.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge115/challenge115.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge115/challenge115.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge115\\challenge115.py')
modname = 'challenge115', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge115\challenge115.py", line 43
E               print challenge115()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge115'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge115')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge115\\challenge115.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge116/challenge116.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge116.py, line 37)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge116/challenge116.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge116/challenge116.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge116.py, line 37)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge116/challenge116.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge116/challenge116.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge116/challenge116.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8FF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge116\\challenge116.py', 37, 22, '    print challenge116()\n')), <traceback object at 0x0000000005E0F248>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E8FF28>
self       = <DoctestModule 'pemjh/challenge116/challenge116.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge116/challenge116.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge116/challenge116.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge116/challenge116.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge116\\challenge116.py')
modname = 'challenge116', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge116\challenge116.py", line 37
E               print challenge116()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge116'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge116')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge116\\challenge116.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge117/challenge117.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge117.py, line 33)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge117/challenge117.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge117/challenge117.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge117.py, line 33)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge117/challenge117.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge117/challenge117.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge117/challenge117.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFA488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge117\\challenge117.py', 33, 22, '    print challenge117()\n')), <traceback object at 0x0000000004D13788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFA488>
self       = <DoctestModule 'pemjh/challenge117/challenge117.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge117/challenge117.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge117/challenge117.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge117/challenge117.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge117\\challenge117.py')
modname = 'challenge117', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge117\challenge117.py", line 33
E               print challenge117()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge117'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge117')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge117\\challenge117.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge118/challenge118.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge118.py, line 52)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge118.py, line 52)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFA6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py', 52, 22, '    print challenge118()\n')), <traceback object at 0x0000000004AD5888>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFA6A8>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge118\challenge118.py", line 52
E               print challenge118()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge119/challenge119.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge119.py, line 33)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge119/challenge119.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge119/challenge119.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge119.py, line 33)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge119/challenge119.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge119/challenge119.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge119/challenge119.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFA8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge119\\challenge119.py', 33, 22, '    print challenge119()\n')), <traceback object at 0x0000000004D07FC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFA8C8>
self       = <DoctestModule 'pemjh/challenge119/challenge119.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge119/challenge119.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge119/challenge119.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge119/challenge119.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge119\\challenge119.py')
modname = 'challenge119', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge119\challenge119.py", line 33
E               print challenge119()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge119'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge119')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge119\\challenge119.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge120/challenge120.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge120.py, line 15)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge120/challenge120.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge120/challenge120.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge120.py, line 15)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge120/challenge120.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge120/challenge120.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge120/challenge120.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFAAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge120\\challenge120.py', 15, 22, '    print challenge120()\n')), <traceback object at 0x0000000004D48748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFAAE8>
self       = <DoctestModule 'pemjh/challenge120/challenge120.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge120/challenge120.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge120/challenge120.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge120/challenge120.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge120\\challenge120.py')
modname = 'challenge120', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge120\challenge120.py", line 15
E               print challenge120()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge120'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge120')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge120\\challenge120.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge121/challenge121.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge121.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge121.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFAD08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py', 39, 22, '    print challenge121()\n')), <traceback object at 0x0000000005DDDC88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFAD08>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge121\challenge121.py", line 39
E               print challenge121()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge122/challenge122.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge122.py, line 28)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge122/challenge122.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge122/challenge122.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge122.py, line 28)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge122/challenge122.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge122/challenge122.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge122/challenge122.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFAF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge122\\challenge122.py', 28, 22, '    print challenge122()\n')), <traceback object at 0x0000000004D58448>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFAF28>
self       = <DoctestModule 'pemjh/challenge122/challenge122.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge122/challenge122.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge122/challenge122.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge122/challenge122.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge122\\challenge122.py')
modname = 'challenge122', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge122\challenge122.py", line 28
E               print challenge122()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge122'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge122')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge122\\challenge122.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge123/challenge123.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge123.py, line 20)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge123.py, line 20)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFA268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py', 20, 22, '    print challenge123()\n')), <traceback object at 0x0000000005E824C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EFA268>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge123\challenge123.py", line 20
E               print challenge123()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge124/challenge124.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge124.py, line 41)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge124.py, line 41)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6F400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py', 41, 22, '    print challenge124()\n')), <traceback object at 0x0000000004CAE508>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6F400>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge124\challenge124.py", line 41
E               print challenge124()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge125/challenge125.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge125.py, line 29)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge125/challenge125.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge125/challenge125.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge125.py, line 29)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge125/challenge125.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge125/challenge125.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge125/challenge125.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6F620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge125\\challenge125.py', 29, 22, '    print challenge125()\n')), <traceback object at 0x0000000004B90CC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6F620>
self       = <DoctestModule 'pemjh/challenge125/challenge125.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge125/challenge125.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge125/challenge125.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge125/challenge125.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge125\\challenge125.py')
modname = 'challenge125', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge125\challenge125.py", line 29
E               print challenge125()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge125'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge125')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge125\\challenge125.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge126/challenge126.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge126.py, line 41)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge126/challenge126.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge126/challenge126.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge126.py, line 41)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge126/challenge126.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge126/challenge126.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge126/challenge126.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6F840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge126\\challenge126.py', 41, 22, '    print challenge126()\n')), <traceback object at 0x0000000005DFBB88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6F840>
self       = <DoctestModule 'pemjh/challenge126/challenge126.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge126/challenge126.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge126/challenge126.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge126/challenge126.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge126\\challenge126.py')
modname = 'challenge126', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge126\challenge126.py", line 41
E               print challenge126()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge126'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge126')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge126\\challenge126.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge127/challenge127.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge127.py, line 35)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge127.py, line 35)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6FA60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py', 35, 22, '    print challenge127()\n')), <traceback object at 0x0000000005E52A08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6FA60>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge127\challenge127.py", line 35
E               print challenge127()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge128/challenge128.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge128.py, line 33)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge128.py, line 33)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6FC80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py', 33, 22, '    print challenge128()\n')), <traceback object at 0x0000000005F271C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6FC80>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge128\challenge128.py", line 33
E               print challenge128()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge129/challenge129.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge129.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge129/challenge129.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge129/challenge129.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge129.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge129/challenge129.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge129/challenge129.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge129/challenge129.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6FEA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge129\\challenge129.py', 27, 22, '    print challenge129()\n')), <traceback object at 0x0000000004D3C088>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6FEA0>
self       = <DoctestModule 'pemjh/challenge129/challenge129.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge129/challenge129.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge129/challenge129.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge129/challenge129.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge129\\challenge129.py')
modname = 'challenge129', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge129\challenge129.py", line 27
E               print challenge129()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge129'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge129')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge129\\challenge129.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge130/challenge130.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge130.py, line 30)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge130.py, line 30)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6F1E0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py', 30, 22, '    print challenge130()\n')), <traceback object at 0x0000000004B0E848>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E6F1E0>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge130\challenge130.py", line 30
E               print challenge130()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge131/challenge131.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge131.py, line 41)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge131.py, line 41)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py', 41, 22, '    print challenge131()\n')), <traceback object at 0x0000000004A6A7C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68378>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge131\challenge131.py", line 41
E               print challenge131()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge132/challenge132.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge132.py, line 24)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge132.py, line 24)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py', 24, 22, '    print challenge132()\n')), <traceback object at 0x0000000004AB2448>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68598>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge132\challenge132.py", line 24
E               print challenge132()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge133/challenge133.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge133.py, line 16)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge133.py, line 16)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E687B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py', 16, 22, '    print challenge133()\n')), <traceback object at 0x0000000005DEA1C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E687B8>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge133\challenge133.py", line 16
E               print challenge133()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge134/challenge134.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge134.py, line 72)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge134.py, line 72)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E689D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py', 72, 22, '    print challenge134()\n')), <traceback object at 0x0000000004C00688>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E689D8>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge134\challenge134.py", line 72
E               print challenge134()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge135/challenge135.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge135.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge135/challenge135.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge135/challenge135.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge135.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge135/challenge135.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge135/challenge135.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge135/challenge135.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68BF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge135\\challenge135.py', 25, 22, '    print challenge135()\n')), <traceback object at 0x0000000005FEED08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68BF8>
self       = <DoctestModule 'pemjh/challenge135/challenge135.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge135/challenge135.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge135/challenge135.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge135/challenge135.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge135\\challenge135.py')
modname = 'challenge135', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge135\challenge135.py", line 25
E               print challenge135()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge135'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge135')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge135\\challenge135.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge136/challenge136.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge136.py, line 26)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge136.py, line 26)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68E18>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py', 26, 22, '    print challenge136()\n')), <traceback object at 0x0000000005DDF788>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68E18>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge136\challenge136.py", line 26
E               print challenge136()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge137/challenge137.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge137.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge137/challenge137.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge137/challenge137.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge137.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge137/challenge137.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge137/challenge137.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge137/challenge137.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68158>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge137\\challenge137.py', 25, 22, '    print challenge137()\n')), <traceback object at 0x0000000005DF4B08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68158>
self       = <DoctestModule 'pemjh/challenge137/challenge137.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge137/challenge137.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge137/challenge137.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge137/challenge137.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge137\\challenge137.py')
modname = 'challenge137', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge137\challenge137.py", line 25
E               print challenge137()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge137'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge137')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge137\\challenge137.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge138/challenge138.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge138.py, line 34)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge138.py, line 34)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py', 34, 22, '    print challenge138()\n')), <traceback object at 0x0000000004CE98C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005E68F28>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge138\challenge138.py", line 34
E               print challenge138()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge139/challenge139.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge139.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge139.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51510>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py', 19, 22, '    print challenge139()\n')), <traceback object at 0x0000000005D34508>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51510>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge139\challenge139.py", line 19
E               print challenge139()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge142/challenge142.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge142.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge142/challenge142.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge142/challenge142.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge142.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge142/challenge142.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge142/challenge142.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge142/challenge142.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51730>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge142\\challenge142.py', 39, 22, '    print challenge142()\n')), <traceback object at 0x0000000005EDB508>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51730>
self       = <DoctestModule 'pemjh/challenge142/challenge142.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge142/challenge142.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge142/challenge142.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge142/challenge142.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge142\\challenge142.py')
modname = 'challenge142', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge142\challenge142.py", line 39
E               print challenge142()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge142'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge142')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge142\\challenge142.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge144/challenge144.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge144.py, line 72)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge144/challenge144.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge144/challenge144.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge144.py, line 72)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge144/challenge144.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge144/challenge144.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge144/challenge144.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51950>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge144\\challenge144.py', 72, 22, '    print challenge144()\n')), <traceback object at 0x0000000004B72C88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51950>
self       = <DoctestModule 'pemjh/challenge144/challenge144.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge144/challenge144.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge144/challenge144.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge144/challenge144.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge144\\challenge144.py')
modname = 'challenge144', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge144\challenge144.py", line 72
E               print challenge144()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge144'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge144')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge144\\challenge144.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge145/challenge145.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge145.py, line 15)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge145/challenge145.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge145/challenge145.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge145.py, line 15)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge145/challenge145.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge145/challenge145.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge145/challenge145.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51B70>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge145\\challenge145.py', 15, 22, '    print challenge145()\n')), <traceback object at 0x0000000005EDAB48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51B70>
self       = <DoctestModule 'pemjh/challenge145/challenge145.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge145/challenge145.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge145/challenge145.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge145/challenge145.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge145\\challenge145.py')
modname = 'challenge145', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge145\challenge145.py", line 15
E               print challenge145()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge145'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge145')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge145\\challenge145.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge146/challenge146.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge146.py, line 31)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge146/challenge146.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge146/challenge146.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge146.py, line 31)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge146/challenge146.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge146/challenge146.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge146/challenge146.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51D90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge146\\challenge146.py', 31, 22, '    print challenge146()\n')), <traceback object at 0x0000000006000748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51D90>
self       = <DoctestModule 'pemjh/challenge146/challenge146.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge146/challenge146.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge146/challenge146.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge146/challenge146.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge146\\challenge146.py')
modname = 'challenge146', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge146\challenge146.py", line 31
E               print challenge146()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge146'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge146')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge146\\challenge146.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge148/challenge148.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge148.py, line 39)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge148/challenge148.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge148/challenge148.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge148.py, line 39)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge148/challenge148.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge148/challenge148.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge148/challenge148.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D512F0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge148\\challenge148.py', 39, 22, '    print challenge148()\n')), <traceback object at 0x0000000005FFE1C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D512F0>
self       = <DoctestModule 'pemjh/challenge148/challenge148.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge148/challenge148.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge148/challenge148.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge148/challenge148.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge148\\challenge148.py')
modname = 'challenge148', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge148\challenge148.py", line 39
E               print challenge148()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge148'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge148')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge148\\challenge148.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge149/challenge149.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge149.py, line 51)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge149/challenge149.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge149/challenge149.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge149.py, line 51)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge149/challenge149.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge149/challenge149.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge149/challenge149.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51F28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge149\\challenge149.py', 51, 22, '    print challenge149()\n')), <traceback object at 0x0000000005D8DF48>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005D51F28>
self       = <DoctestModule 'pemjh/challenge149/challenge149.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge149/challenge149.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge149/challenge149.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge149/challenge149.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge149\\challenge149.py')
modname = 'challenge149', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge149\challenge149.py", line 51
E               print challenge149()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge149'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge149')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge149\\challenge149.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge151/challenge151.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge151.py, line 28)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge151/challenge151.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge151/challenge151.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge151.py, line 28)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge151/challenge151.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge151/challenge151.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge151/challenge151.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEC488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge151\\challenge151.py', 28, 22, '    print challenge151()\n')), <traceback object at 0x0000000005E96648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEC488>
self       = <DoctestModule 'pemjh/challenge151/challenge151.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge151/challenge151.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge151/challenge151.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge151/challenge151.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge151\\challenge151.py')
modname = 'challenge151', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge151\challenge151.py", line 28
E               print challenge151()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge151'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge151')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge151\\challenge151.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge162/challenge162.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge162.py, line 11)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge162/challenge162.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge162/challenge162.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge162.py, line 11)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge162/challenge162.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge162/challenge162.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge162/challenge162.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEC6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge162\\challenge162.py', 11, 22, '    print challenge162()\n')), <traceback object at 0x0000000005FC4988>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEC6A8>
self       = <DoctestModule 'pemjh/challenge162/challenge162.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge162/challenge162.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge162/challenge162.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge162/challenge162.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge162\\challenge162.py')
modname = 'challenge162', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge162\challenge162.py", line 11
E               print challenge162()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge162'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge162')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge162\\challenge162.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge164/challenge164.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge164.py, line 36)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge164/challenge164.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge164/challenge164.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge164.py, line 36)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge164/challenge164.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge164/challenge164.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge164/challenge164.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEC8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge164\\challenge164.py', 36, 22, '    print challenge164()\n')), <traceback object at 0x0000000005FBCDC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEC8C8>
self       = <DoctestModule 'pemjh/challenge164/challenge164.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge164/challenge164.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge164/challenge164.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge164/challenge164.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge164\\challenge164.py')
modname = 'challenge164', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge164\challenge164.py", line 36
E               print challenge164()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge164'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge164')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge164\\challenge164.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge166/challenge166.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge166.py, line 73)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge166/challenge166.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge166/challenge166.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge166.py, line 73)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge166/challenge166.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge166/challenge166.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge166/challenge166.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EECAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge166\\challenge166.py', 73, 22, '    print challenge166()\n')), <traceback object at 0x0000000004CB0BC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EECAE8>
self       = <DoctestModule 'pemjh/challenge166/challenge166.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge166/challenge166.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge166/challenge166.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge166/challenge166.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge166\\challenge166.py')
modname = 'challenge166', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge166\challenge166.py", line 73
E               print challenge166()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge166'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge166')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge166\\challenge166.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge173/challenge173.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge173.py, line 35)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge173/challenge173.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge173/challenge173.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge173.py, line 35)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge173/challenge173.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge173/challenge173.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge173/challenge173.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EECD08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge173\\challenge173.py', 35, 22, '    print challenge173()\n')), <traceback object at 0x0000000005E47208>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EECD08>
self       = <DoctestModule 'pemjh/challenge173/challenge173.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge173/challenge173.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge173/challenge173.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge173/challenge173.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge173\\challenge173.py')
modname = 'challenge173', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge173\challenge173.py", line 35
E               print challenge173()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge173'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge173')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge173\\challenge173.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge174/challenge174.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge174.py, line 40)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge174.py, line 40)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EECF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py', 40, 22, '    print challenge174()\n')), <traceback object at 0x0000000005EFF0C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EECF28>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge174\challenge174.py", line 40
E               print challenge174()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge179/challenge179.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge179.py, line 26)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge179/challenge179.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge179/challenge179.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge179.py, line 26)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge179/challenge179.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge179/challenge179.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge179/challenge179.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEC268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge179\\challenge179.py', 26, 22, '    print challenge179()\n')), <traceback object at 0x0000000005D38CC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEC268>
self       = <DoctestModule 'pemjh/challenge179/challenge179.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge179/challenge179.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge179/challenge179.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge179/challenge179.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge179\\challenge179.py')
modname = 'challenge179', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge179\challenge179.py", line 26
E               print challenge179()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge179'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge179')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge179\\challenge179.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge183/challenge183.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge183.py, line 56)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge183.py, line 56)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py', 56, 22, '    print challenge183()\n')), <traceback object at 0x0000000006008508>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022400>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge183\challenge183.py", line 56
E               print challenge183()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge187/challenge187.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge187.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge187.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py', 22, 22, '    print challenge187()\n')), <traceback object at 0x0000000004A88708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022620>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge187\challenge187.py", line 22
E               print challenge187()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge188/challenge188.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge188.py, line 18)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge188/challenge188.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge188/challenge188.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge188.py, line 18)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge188/challenge188.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge188/challenge188.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge188/challenge188.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge188\\challenge188.py', 18, 22, '    print challenge188()\n')), <traceback object at 0x0000000005DCF708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022840>
self       = <DoctestModule 'pemjh/challenge188/challenge188.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge188/challenge188.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge188/challenge188.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge188/challenge188.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge188\\challenge188.py')
modname = 'challenge188', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge188\challenge188.py", line 18
E               print challenge188()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge188'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge188')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge188\\challenge188.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge190/challenge190.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge190.py, line 11)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge190/challenge190.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge190/challenge190.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge190.py, line 11)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge190/challenge190.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge190/challenge190.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge190/challenge190.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022A60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge190\\challenge190.py', 11, 22, '    print challenge190()\n')), <traceback object at 0x0000000005FDAAC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022A60>
self       = <DoctestModule 'pemjh/challenge190/challenge190.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge190/challenge190.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge190/challenge190.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge190/challenge190.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge190\\challenge190.py')
modname = 'challenge190', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge190\challenge190.py", line 11
E               print challenge190()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge190'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge190')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge190\\challenge190.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge191/challenge191.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge191.py, line 83)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge191/challenge191.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge191/challenge191.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge191.py, line 83)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge191/challenge191.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge191/challenge191.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge191/challenge191.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022C80>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge191\\challenge191.py', 83, 22, '    print challenge191()\n')), <traceback object at 0x0000000005FD8A08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022C80>
self       = <DoctestModule 'pemjh/challenge191/challenge191.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge191/challenge191.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge191/challenge191.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge191/challenge191.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge191\\challenge191.py')
modname = 'challenge191', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge191\challenge191.py", line 83
E               print challenge191()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge191'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge191')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge191\\challenge191.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge197/challenge197.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge197.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge197/challenge197.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge197/challenge197.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge197.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge197/challenge197.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge197/challenge197.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge197/challenge197.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022EA0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge197\\challenge197.py', 27, 22, '    print challenge197()\n')), <traceback object at 0x0000000006024EC8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000006022EA0>
self       = <DoctestModule 'pemjh/challenge197/challenge197.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge197/challenge197.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge197/challenge197.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge197/challenge197.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge197\\challenge197.py')
modname = 'challenge197', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge197\challenge197.py", line 27
E               print challenge197()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge197'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge197')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge197\\challenge197.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge203/challenge203.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge203.py, line 44)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge203.py, line 44)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060221E0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py', 44, 22, '    print challenge203()\n')), <traceback object at 0x0000000005DF6B88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060221E0>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge203\challenge203.py", line 44
E               print challenge203()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge204/challenge204.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge204.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge204.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE378>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py', 32, 22, '    print challenge204()\n')), <traceback object at 0x0000000004A98E88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE378>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge204\challenge204.py", line 32
E               print challenge204()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge205/challenge205.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge205.py, line 32)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge205/challenge205.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge205/challenge205.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge205.py, line 32)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge205/challenge205.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge205/challenge205.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge205/challenge205.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE598>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge205\\challenge205.py', 32, 22, '    print challenge205()\n')), <traceback object at 0x0000000004CBB908>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE598>
self       = <DoctestModule 'pemjh/challenge205/challenge205.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge205/challenge205.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge205/challenge205.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge205/challenge205.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge205\\challenge205.py')
modname = 'challenge205', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge205\challenge205.py", line 32
E               print challenge205()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge205'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge205')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge205\\challenge205.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge206/challenge206.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge206.py, line 65)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge206/challenge206.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge206/challenge206.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge206.py, line 65)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge206/challenge206.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge206/challenge206.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge206/challenge206.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE7B8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge206\\challenge206.py', 65, 22, '    print challenge206()\n')), <traceback object at 0x0000000005E94348>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE7B8>
self       = <DoctestModule 'pemjh/challenge206/challenge206.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge206/challenge206.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge206/challenge206.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge206/challenge206.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge206\\challenge206.py')
modname = 'challenge206', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge206\challenge206.py", line 65
E               print challenge206()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge206'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge206')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge206\\challenge206.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge207/challenge207.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge207.py, line 25)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge207/challenge207.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge207/challenge207.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge207.py, line 25)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge207/challenge207.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge207/challenge207.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge207/challenge207.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE9D8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge207\\challenge207.py', 25, 22, '    print challenge207()\n')), <traceback object at 0x0000000005D8F648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE9D8>
self       = <DoctestModule 'pemjh/challenge207/challenge207.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge207/challenge207.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge207/challenge207.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge207/challenge207.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge207\\challenge207.py')
modname = 'challenge207', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge207\challenge207.py", line 25
E               print challenge207()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge207'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge207')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge207\\challenge207.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge211/challenge211.py _____________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge211.py, line 50)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (challenge211.py, line 50)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEEBF8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py', 50, 19, '            print x\n')), <traceback object at 0x0000000004D31388>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEEBF8>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge211\challenge211.py", line 50
E               print x
E                     ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge214/challenge214.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge214.py, line 76)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge214.py, line 76)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEED90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py', 76, 22, '    print challenge214()\n')), <traceback object at 0x0000000005DBCF88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEED90>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge214\challenge214.py", line 76
E               print challenge214()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge215/challenge215.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge215.py, line 64)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge215/challenge215.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge215/challenge215.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge215.py, line 64)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge215/challenge215.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge215/challenge215.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge215/challenge215.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE158>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge215\\challenge215.py', 64, 22, '    print challenge215()\n')), <traceback object at 0x0000000004BE4408>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEE158>
self       = <DoctestModule 'pemjh/challenge215/challenge215.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge215/challenge215.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge215/challenge215.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge215/challenge215.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge215\\challenge215.py')
modname = 'challenge215', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge215\challenge215.py", line 64
E               print challenge215()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge215'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge215')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge215\\challenge215.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge216/challenge216.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge216.py, line 81)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge216/challenge216.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge216/challenge216.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge216.py, line 81)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge216/challenge216.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge216/challenge216.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge216/challenge216.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEEF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge216\\challenge216.py', 81, 22, '    print challenge216()\n')), <traceback object at 0x0000000005E454C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005EEEF28>
self       = <DoctestModule 'pemjh/challenge216/challenge216.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge216/challenge216.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge216/challenge216.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge216/challenge216.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge216\\challenge216.py')
modname = 'challenge216', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge216\challenge216.py", line 81
E               print challenge216()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge216'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge216')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge216\\challenge216.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge220/challenge220.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge220.py, line 22)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge220/challenge220.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge220/challenge220.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge220.py, line 22)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge220/challenge220.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge220/challenge220.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge220/challenge220.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECB488>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge220\\challenge220.py', 22, 22, '    print challenge220()\n')), <traceback object at 0x0000000004B65E88>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECB488>
self       = <DoctestModule 'pemjh/challenge220/challenge220.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge220/challenge220.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge220/challenge220.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge220/challenge220.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge220\\challenge220.py')
modname = 'challenge220', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge220\challenge220.py", line 22
E               print challenge220()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge220'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge220')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge220\\challenge220.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge225/challenge225.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge225.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge225/challenge225.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge225/challenge225.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge225.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge225/challenge225.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge225/challenge225.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge225/challenge225.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECB6A8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge225\\challenge225.py', 19, 22, '    print challenge225()\n')), <traceback object at 0x0000000005D42708>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECB6A8>
self       = <DoctestModule 'pemjh/challenge225/challenge225.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge225/challenge225.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge225/challenge225.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge225/challenge225.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge225\\challenge225.py')
modname = 'challenge225', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge225\challenge225.py", line 19
E               print challenge225()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge225'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge225')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge225\\challenge225.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge230/challenge230.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge230.py, line 53)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge230/challenge230.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge230/challenge230.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge230.py, line 53)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge230/challenge230.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge230/challenge230.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge230/challenge230.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECB8C8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge230\\challenge230.py', 53, 22, '    print challenge230()\n')), <traceback object at 0x0000000004C81348>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECB8C8>
self       = <DoctestModule 'pemjh/challenge230/challenge230.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge230/challenge230.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge230/challenge230.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge230/challenge230.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge230\\challenge230.py')
modname = 'challenge230', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge230\challenge230.py", line 53
E               print challenge230()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge230'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge230')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge230\\challenge230.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge231/challenge231.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge231.py, line 72)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge231.py, line 72)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECBAE8>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py', 72, 22, '    print challenge231()\n')), <traceback object at 0x00000000060019C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECBAE8>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge231\challenge231.py", line 72
E               print challenge231()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge234/challenge234.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge234.py, line 44)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge234.py, line 44)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECBD08>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py', 44, 22, '    print challenge234()\n')), <traceback object at 0x0000000005E43B08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECBD08>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge234\challenge234.py", line 44
E               print challenge234()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge235/challenge235.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge235.py, line 19)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge235/challenge235.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge235/challenge235.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge235.py, line 19)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge235/challenge235.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge235/challenge235.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge235/challenge235.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECBF28>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge235\\challenge235.py', 19, 22, '    print challenge235()\n')), <traceback object at 0x0000000004D26608>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECBF28>
self       = <DoctestModule 'pemjh/challenge235/challenge235.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge235/challenge235.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge235/challenge235.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge235/challenge235.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge235\\challenge235.py')
modname = 'challenge235', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge235\challenge235.py", line 19
E               print challenge235()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge235'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge235')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge235\\challenge235.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge243/challenge243.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge243.py, line 49)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge243.py, line 49)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECB268>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py', 49, 22, '    print challenge243()\n')), <traceback object at 0x0000000006045448>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x0000000005ECB268>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge243\challenge243.py", line 49
E               print challenge243()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge250/challenge250.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge250.py, line 27)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge250/challenge250.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge250/challenge250.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge250.py, line 27)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge250/challenge250.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge250/challenge250.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge250/challenge250.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060D9400>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge250\\challenge250.py', 27, 22, '    print challenge250()\n')), <traceback object at 0x0000000005EF5648>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060D9400>
self       = <DoctestModule 'pemjh/challenge250/challenge250.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge250/challenge250.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge250/challenge250.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge250/challenge250.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge250\\challenge250.py')
modname = 'challenge250', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge250\challenge250.py", line 27
E               print challenge250()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge250'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge250')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge250\\challenge250.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge259/challenge259.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge259.py, line 66)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge259/challenge259.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge259/challenge259.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge259.py, line 66)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge259/challenge259.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge259/challenge259.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge259/challenge259.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060D9620>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge259\\challenge259.py', 66, 22, '    print challenge259()\n')), <traceback object at 0x0000000005FBCE08>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060D9620>
self       = <DoctestModule 'pemjh/challenge259/challenge259.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge259/challenge259.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge259/challenge259.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge259/challenge259.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge259\\challenge259.py')
modname = 'challenge259', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge259\challenge259.py", line 66
E               print challenge259()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge259'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge259')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge259\\challenge259.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_____________ ERROR collecting pemjh/challenge265/challenge265.py _____________

self = <CallInfo when='memocollect' exception: invalid syntax (challenge265.py, line 55)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge265/challenge265.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge265/challenge265.py'>>
self       = <CallInfo when='memocollect' exception: invalid syntax (challenge265.py, line 55)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge265/challenge265.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge265/challenge265.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge265/challenge265.py'>
attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060D9840>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\challenge265\\challenge265.py', 55, 22, '    print challenge265()\n')), <traceback object at 0x0000000004AED748>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060D9840>
self       = <DoctestModule 'pemjh/challenge265/challenge265.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge265/challenge265.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge265/challenge265.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/challenge265/challenge265.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge265\\challenge265.py')
modname = 'challenge265', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\challenge265\challenge265.py", line 55
E               print challenge265()
E                                ^
E           SyntaxError: invalid syntax

ensuresyspath = True
modname    = 'challenge265'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge265')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge265\\challenge265.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
_________________ ERROR collecting pemjh/utilities/numbers.py _________________

self = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (numbers.py, line 310)>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/utilities/numbers.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/utilities/numbers.py'>>
self       = <CallInfo when='memocollect' exception: Missing parentheses in call to 'print' (numbers.py, line 310)>
when       = 'memocollect'

.tox\py34\lib\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/utilities/numbers.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/utilities/numbers.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/utilities/numbers.py'>, attrname = '_collected'
function = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060D9A60>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('D:\\Development\\pemjh\\pemjh\\utilities\\numbers.py', 310, 70, '        print "Getting stored primes failed, will try to generate new"\n')), <traceback object at 0x0000000004BD44C8>)
function   = <function Collector._memocollect.<locals>.<lambda> at 0x00000000060D9A60>
self       = <DoctestModule 'pemjh/utilities/numbers.py'>

.tox\py34\lib\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/utilities/numbers.py'>

.tox\py34\lib\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/utilities/numbers.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\python34_64\\Lib\\doctest.py'>
self       = <DoctestModule 'pemjh/utilities/numbers.py'>

.tox\py34\lib\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\utilities\\numbers.py')
modname = 'utilities.numbers', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)
E             File "D:\Development\pemjh\pemjh\utilities\numbers.py", line 310
E               print "Getting stored primes failed, will try to generate new"
E                                                                            ^
E           SyntaxError: Missing parentheses in call to 'print'

ensuresyspath = True
modname    = 'utilities.numbers'
names      = ['utilities', 'numbers']
pkgpath    = local('D:\\Development\\pemjh\\pemjh\\utilities')
pkgroot    = local('D:\\Development\\pemjh\\pemjh')
self       = local('D:\\Development\\pemjh\\pemjh\\utilities\\numbers.py')

.tox\py34\lib\site-packages\py\_path\local.py:650: SyntaxError
================================== FAILURES ===================================
______________________________ [pylint] setup.py ______________________________
C: 36, 0: No space allowed around keyword argument assignment
    name = "pemjh",
         ^ (bad-whitespace)
C: 37, 0: No space allowed around keyword argument assignment
    version = "0.0.1",
            ^ (bad-whitespace)
C: 38, 0: No space allowed around keyword argument assignment
    author = "Matthew Hussey",
           ^ (bad-whitespace)
C: 39, 0: No space allowed around keyword argument assignment
    author_email = "matthew.hussey@googlemail.com",
                 ^ (bad-whitespace)
C: 40, 0: No space allowed around keyword argument assignment
    description = ("Project euler (https://projecteuler.net/) challenge "
                ^ (bad-whitespace)
C: 42, 0: No space allowed around keyword argument assignment
    license = "None, private use by myself only",
            ^ (bad-whitespace)
C: 43, 0: No space allowed around keyword argument assignment
    keywords = "code challenge euler",
             ^ (bad-whitespace)
C: 44, 0: No space allowed around keyword argument assignment
    url = "none.non",
        ^ (bad-whitespace)
C: 45, 0: No space allowed around keyword argument assignment
    packages = ["pemjh"],
             ^ (bad-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
    long_description = read("README"),
                     ^ (bad-whitespace)
C: 50, 0: No space allowed around keyword argument assignment
    cmdclass = {"test": Tox},
             ^ (bad-whitespace)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing class docstring (missing-docstring)
F: 27, 8: Unable to import 'tox' (import-error)
W: 20, 8: Attribute 'tox_args' defined outside __init__ (attribute-defined-outside-init)
W: 24, 8: Attribute 'test_suite' defined outside __init__ (attribute-defined-outside-init)
W: 23, 8: Attribute 'test_args' defined outside __init__ (attribute-defined-outside-init)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\setup.py:6:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\setup.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:18:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:21:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:25:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:26:9: E265 block comment should start with '# '
D:\Development\pemjh\setup.py:36:9: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:36:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:12: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:14: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:13: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:19: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:18: E251 unexpected spaces around keyword / parameter equals

___________________________ [pylint] pemjh/main.py ____________________________
E:  8, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\main.py:8:26: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\main.py:13:15: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\main.py:32:18: W291 trailing whitespace
D:\Development\pemjh\pemjh\main.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\main.py:58:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge001/challenge001.py _________________
E: 10, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge001\challenge001.py:10:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge002/challenge002.py _________________
E: 16, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge002\challenge002.py:16:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge003/challenge003.py _________________
E: 29, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge003\challenge003.py:29:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge004/challenge004.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge004\challenge004.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge005/challenge005.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge005\challenge005.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge006/challenge006.py _________________
E: 24, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:24:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge007/challenge007.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge007\challenge007.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge008/challenge008.py _________________
E: 45, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge008\challenge008.py:45:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge009/challenge009.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge010/challenge010.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge010\challenge010.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge011/challenge011.py _________________
E: 62, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:62:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge012/challenge012.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
E:  6, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
E:  7, 0: No name 'izip' in module 'itertools' (no-name-in-module)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 15, 0: Invalid function name "triangleDivisors" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 16, 4: Invalid variable name "n" (invalid-name)
C: 17, 4: Invalid variable name "nOdd" (invalid-name)
C: 18, 4: Invalid variable name "nEven" (invalid-name)
C: 19, 4: Invalid variable name "knownDivisors" (invalid-name)
C: 24,12: Invalid variable name "nOdd" (invalid-name)
C: 27,12: Invalid variable name "nEven" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36,22: More than one statement on a single line (multiple-statements)
W: 38,12: Using possibly undefined loop variable 'n' (undefined-loop-variable)
W: 38,17: Using possibly undefined loop variable 'n' (undefined-loop-variable)
C: 40, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge013/challenge013.py _________________
E:115, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:115:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge014/challenge014.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getChainSize" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "knownChains" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "knownChains" (invalid-name)
E: 30,13: Undefined variable 'xrange' (undefined-variable)
C: 31, 8: Invalid variable name "newChain" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge014\challenge014.py:30:14: F821 undefined name 'xrange'
D:\Development\pemjh\pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge015/challenge015.py _________________
C:  7, 0: No space allowed around keyword argument assignment
def multiplierGen(n = 0):
                    ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
E:  5, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "multiplierGen" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid function name "getRoutes" (invalid-name)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge016/challenge016.py _________________
E: 18, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge016\challenge016.py:18:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge017/challenge017.py _________________
E:110, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:110:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge018/challenge018.py _________________
E: 31, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge018\challenge018.py:31:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge019/challenge019.py _________________
E: 46, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:46:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge020/challenge020.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge020\challenge020.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge021/challenge021.py _________________
E: 33, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge021\challenge021.py:33:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge022/challenge022.py _________________
E: 38, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:38:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge023/challenge023.py _________________
E: 34, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:34:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge024/challenge024.py _________________
E: 18, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge024\challenge024.py:18:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge025/challenge025.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge025\challenge025.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge026/challenge026.py _________________
E: 29, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:29:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge027/challenge027.py _________________
E: 36, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge027\challenge027.py:36:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge028/challenge028.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge028\challenge028.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge029/challenge029.py _________________
E: 18, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge029\challenge029.py:18:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge030/challenge030.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge030\challenge030.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge031/challenge031.py _________________
E: 23, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge031\challenge031.py:23:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge032/challenge032.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge032\challenge032.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge033/challenge033.py _________________
E: 48, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:48:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge034/challenge034.py _________________
E: 14, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:14:21: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge035/challenge035.py _________________
E: 11, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:11:19: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
D:\Development\pemjh\pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge036/challenge036.py _________________
E: 30, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge036\challenge036.py:30:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge037/challenge037.py _________________
E: 36, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge037\challenge037.py:36:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge038/challenge038.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge038\challenge038.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge039/challenge039.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge039\challenge039.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge040/challenge040.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
D:\Development\pemjh\pemjh\challenge040\challenge040.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge041/challenge041.py _________________
E: 23, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge041\challenge041.py:23:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge042/challenge042.py _________________
E: 42, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge042\challenge042.py:42:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge043/challenge043.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge044/challenge044.py _________________
E: 35, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge044\challenge044.py:35:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge045/challenge045.py _________________
E: 35, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:35:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge046/challenge046.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge046\challenge046.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge047/challenge047.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
E:  6, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "numPrimeFactors" (invalid-name)
C:  8, 0: Invalid argument name "nPrimes" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "n" (invalid-name)
C: 11, 8: Invalid variable name "pf" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Invalid function name "hasNumPrimes" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 20,30: More than one statement on a single line (multiple-statements)
W: 30, 4: Redefining name 'count' from outer scope (line 1) (redefined-outer-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 31, 8: Invalid variable name "p" (invalid-name)
E: 31,13: Undefined variable 'xrange' (undefined-variable)
E: 35,28: Undefined variable 'xrange' (undefined-variable)
C: 45, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused count imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
D:\Development\pemjh\pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:31:14: F821 undefined name 'xrange'
D:\Development\pemjh\pemjh\challenge047\challenge047.py:35:29: F821 undefined name 'xrange'
D:\Development\pemjh\pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge048/challenge048.py _________________
E: 10, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge048\challenge048.py:10:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge049/challenge049.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge049\challenge049.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge050/challenge050.py _________________
E: 30, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge050\challenge050.py:30:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge051/challenge051.py _________________
E: 50, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:50:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge052/challenge052.py _________________
E: 28, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:28:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge053/challenge053.py _________________
E: 20, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge053\challenge053.py:20:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge054/challenge054.py _________________
E:136, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:136:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge055/challenge055.py _________________
E:  2, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:17: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge056/challenge056.py _________________
E: 17, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge056\challenge056.py:17:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge057/challenge057.py _________________
E: 21, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge057\challenge057.py:21:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge058/challenge058.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
E:  4, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nPrimes" (invalid-name)
C: 13, 4: Invalid variable name "primeChecker" (invalid-name)
E: 18,17: Undefined variable 'xrange' (undefined-variable)
C: 22,16: Invalid variable name "nPrimes" (invalid-name)
W: 18,12: Unused variable 'j' (unused-variable)
W:  9, 4: Unused variable 'total' (unused-variable)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
D:\Development\pemjh\pemjh\challenge058\challenge058.py:18:18: F821 undefined name 'xrange'
D:\Development\pemjh\pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge059/challenge059.py _________________
E: 49, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:49:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge060/challenge060.py _________________
E:119, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:119:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge061/challenge061.py _________________
E:104, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge061\challenge061.py:104:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge062/challenge062.py _________________
E: 34, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge062\challenge062.py:34:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge063/challenge063.py _________________
E: 28, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:28:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge064/challenge064.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge064\challenge064.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge065/challenge065.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge065\challenge065.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge066/challenge066.py _________________
E: 23, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)
D:\Development\pemjh\pemjh\challenge066\challenge066.py:23:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge067/challenge067.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge067\challenge067.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge068/challenge068.py _________________
E: 70, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge068\challenge068.py:70:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge069/challenge069.py _________________
E: 24, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge069\challenge069.py:24:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge070/challenge070.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
E:  4, 0: No name 'numbers' in module 'utils' (no-name-in-module)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
E:  5, 0: No name 'izip' in module 'itertools' (no-name-in-module)
C:  8, 0: Invalid function name "isPermutation" (invalid-name)
C:  8, 0: Invalid argument name "a" (invalid-name)
C:  8, 0: Invalid argument name "b" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 17,11: Invalid variable name "p" (invalid-name)
E: 17,21: Undefined variable 'xrange' (undefined-variable)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused import string (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:17:22: F821 undefined name 'xrange'

_________________ [pylint] pemjh/challenge071/challenge071.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge071\challenge071.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge072/challenge072.py _________________
E: 14, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge072\challenge072.py:14:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge073/challenge073.py _________________
E: 42, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:42:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge074/challenge074.py _________________
E: 41, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
D:\Development\pemjh\pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:41:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge075/challenge075.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge075\challenge075.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge076/challenge076.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge076\challenge076.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge077/challenge077.py _________________
E: 34, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge077\challenge077.py:34:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge078/challenge078.py _________________
E:  6, 0: inconsistent use of tabs and spaces in indentation (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:20: E901 TabError: inconsistent use of tabs and spaces in indentation
D:\Development\pemjh\pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge079/challenge079.py _________________
E: 15, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge079\challenge079.py:15:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge080/challenge080.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge081/challenge081.py _________________
E: 46, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:46:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge082/challenge082.py _________________
E: 53, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:53:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge083/challenge083.py _________________
E: 80, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'
D:\Development\pemjh\pemjh\challenge083\challenge083.py:80:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge084/challenge084.py _________________
E:114, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:114:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge085/challenge085.py _________________
E: 51, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:51:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge086/challenge086.py _________________
E: 44, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:44:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge087/challenge087.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge087\challenge087.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge088/challenge088.py _________________
E: 36, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge088\challenge088.py:36:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge089/challenge089.py _________________
E: 90, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
D:\Development\pemjh\pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:90:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge090/challenge090.py _________________
E:132, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:132:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge091/challenge091.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge091\challenge091.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge092/challenge092.py _________________
E:124, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:124:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge093/challenge093.py _________________
E:102, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:102:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge094/challenge094.py _________________
E: 54, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge094\challenge094.py:54:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge095/challenge095.py _________________
E: 61, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:61:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge096/challenge096.py _________________
E:271, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:271:51: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge097/challenge097.py _________________
E:  8, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge097\challenge097.py:8:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge098/challenge098.py _________________
E: 98, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:98:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge099/challenge099.py _________________
E: 20, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge099\challenge099.py:20:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge100/challenge100.py _________________
E: 11, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge100\challenge100.py:11:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge101/challenge101.py _________________
E: 43, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
D:\Development\pemjh\pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge101\challenge101.py:43:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge102/challenge102.py _________________
E: 59, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge102\challenge102.py:59:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge103/challenge103.py _________________
E: 61, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:61:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge104/challenge104.py _________________
E: 50, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge104\challenge104.py:50:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge105/challenge105.py _________________
E: 65, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:65:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge106/challenge106.py _________________
E: 68, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:68:23: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge107/challenge107.py _________________
E: 70, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:70:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge108/challenge108.py _________________
E: 59, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:59:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge109/challenge109.py _________________
E: 50, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:50:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge110/challenge110.py _________________
E: 59, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:59:23: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge111/challenge111.py _________________
E: 54, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:54:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge112/challenge112.py _________________
E: 48, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge112\challenge112.py:48:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge113/challenge113.py _________________
E: 61, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge113\challenge113.py:61:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge114/challenge114.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge115/challenge115.py _________________
E: 43, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:43:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge116/challenge116.py _________________
E: 37, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:37:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge117/challenge117.py _________________
E: 33, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:33:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge118/challenge118.py _________________
E: 52, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:52:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge119/challenge119.py _________________
E: 33, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:33:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge120/challenge120.py _________________
E: 15, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge120\challenge120.py:15:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge121/challenge121.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge122/challenge122.py _________________
E: 28, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:28:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge123/challenge123.py _________________
E: 20, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:20:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge124/challenge124.py _________________
E: 41, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:41:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge125/challenge125.py _________________
E: 29, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge125\challenge125.py:29:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge126/challenge126.py _________________
E: 41, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:41:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge127/challenge127.py _________________
E: 35, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge127\challenge127.py:35:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge128/challenge128.py _________________
E: 33, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:33:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge129/challenge129.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge129\challenge129.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge130/challenge130.py _________________
E: 30, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge130\challenge130.py:30:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge131/challenge131.py _________________
E: 41, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge131\challenge131.py:41:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge132/challenge132.py _________________
E: 24, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:24:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge133/challenge133.py _________________
E: 16, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge133\challenge133.py:16:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge134/challenge134.py _________________
E: 72, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge134\challenge134.py:72:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge135/challenge135.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge135\challenge135.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge136/challenge136.py _________________
E: 26, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:26:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge137/challenge137.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge138/challenge138.py _________________
E: 34, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)
D:\Development\pemjh\pemjh\challenge138\challenge138.py:34:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge139/challenge139.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge139\challenge139.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge142/challenge142.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge142\challenge142.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge144/challenge144.py _________________
E: 72, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:72:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge145/challenge145.py _________________
E: 15, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge145\challenge145.py:15:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge146/challenge146.py _________________
E: 31, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge146\challenge146.py:31:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge148/challenge148.py _________________
E: 39, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:39:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge149/challenge149.py _________________
E: 51, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:51:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge151/challenge151.py _________________
E: 28, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge151\challenge151.py:28:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge162/challenge162.py _________________
E: 11, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge162\challenge162.py:11:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge164/challenge164.py _________________
E: 36, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:36:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge166/challenge166.py _________________
E: 73, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:73:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge173/challenge173.py _________________
E: 35, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge173\challenge173.py:35:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge174/challenge174.py _________________
E: 40, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge174\challenge174.py:40:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge179/challenge179.py _________________
E: 26, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge179\challenge179.py:26:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge183/challenge183.py _________________
E: 56, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:56:23: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge187/challenge187.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge188/challenge188.py _________________
E: 18, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge188\challenge188.py:18:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge190/challenge190.py _________________
E: 11, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge190\challenge190.py:11:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge191/challenge191.py _________________
E: 83, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:83:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge197/challenge197.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge197\challenge197.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge203/challenge203.py _________________
E: 44, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
D:\Development\pemjh\pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:44:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge204/challenge204.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge205/challenge205.py _________________
E: 32, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:32:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge206/challenge206.py _________________
E: 65, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge206\challenge206.py:65:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge207/challenge207.py _________________
E: 25, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge207\challenge207.py:25:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge211/challenge211.py _________________
E: 50, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
D:\Development\pemjh\pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:50:20: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge214/challenge214.py _________________
E: 76, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:76:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge215/challenge215.py _________________
E: 64, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge215\challenge215.py:64:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge216/challenge216.py _________________
E: 81, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:81:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge220/challenge220.py _________________
E: 22, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge220\challenge220.py:22:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge225/challenge225.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)
D:\Development\pemjh\pemjh\challenge225\challenge225.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge230/challenge230.py _________________
E: 53, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:53:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge231/challenge231.py _________________
E: 72, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge231\challenge231.py:72:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge234/challenge234.py _________________
E: 44, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:44:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge235/challenge235.py _________________
E: 19, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge235\challenge235.py:19:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge243/challenge243.py _________________
E: 49, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge243\challenge243.py:49:23: E901 SyntaxError: invalid syntax
D:\Development\pemjh\pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge250/challenge250.py _________________
E: 27, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge250\challenge250.py:27:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge259/challenge259.py _________________
E: 66, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge259\challenge259.py:66:23: E901 SyntaxError: invalid syntax

_________________ [pylint] pemjh/challenge265/challenge265.py _________________
E: 55, 0: invalid syntax (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:55:23: E901 SyntaxError: invalid syntax

_____________________ [pylint] pemjh/utilities/numbers.py _____________________
E:310, 0: Missing parentheses in call to 'print' (syntax-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\utilities\numbers.py:310:71: E901 SyntaxError: invalid syntax

_____________________ [pylint] pemjh/utilities/strings.py _____________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "s" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7,12: Invalid variable name "n" (invalid-name)
C:  7,15: Invalid variable name "c" (invalid-name)
C:  8,16: Invalid variable name "p" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
--------------- coverage: platform win32, python 3.4.3-final-0 ----------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge012\challenge012      31     28     10      9    10%   2-3, 7-44
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      6      5    11%   2-3, 7-32
pemjh\challenge047\challenge047      37     34     20     19     7%   4-5, 8-50
pemjh\challenge058\challenge058      26     24     10      9     8%   2-3, 6-38
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
pemjh\utilities\__init__              0      0      0      0   100%   
pemjh\utilities\strings               8      7      6      6     7%   2-10
-----------------------------------------------------------------------------
TOTAL                               176    159     76     70     9%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\python34_64\Lib\runpy.py", line 170, in _run_module_as_main
    "__main__", mod_spec)
  File "E:\software_tools\python\python34_64\Lib\runpy.py", line 85, in _run_code
    exec(code, run_globals)
  File "D:\Development\pemjh\.tox\py34\Scripts\py.test.EXE\__main__.py", line 9, in <module>
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\py34\lib\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\py34\lib\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
pytest_cov.plugin.CoverageError: Required test coverage of 100% not reached. Total coverage: 9.13%
ERROR: InvocationError: 'D:\\Development\\pemjh\\.tox\\py34\\Scripts\\py.test.EXE --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100'
py34_64 recreate: D:\Development\pemjh\.tox\py34_64
ERROR: invocation failed (exit code 1), logfile: D:\Development\pemjh\.tox\py34_64\log\py34_64-0.log
ERROR: actionid: py34_64
msg: getenv
cmdargs: ['D:\\Development\\pemjh\\.venv\\py27_64\\Scripts\\python.exe', '-m', 'virtualenv', '--python', 'D:\\Development\\pemjh\\.venv\\py27_64\\Scripts\\python.exe', 'py34_64']
env: {'TMP': 'C:\\Users\\Matt\\AppData\\Local\\Temp', 'COMPUTERNAME': 'SLAYER', 'VS140COMNTOOLS': 'C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\Common7\\Tools\\', 'VS110COMNTOOLS': 'C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\Common7\\Tools\\', 'USERDOMAIN': 'SLAYER', 'AV_APPDATA': 'C:\\Users\\Matt\\AppData\\Roaming', 'PSMODULEPATH': 'C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules\\', 'COMMONPROGRAMFILES': 'C:\\Program Files\\Common Files', 'PROCESSOR_IDENTIFIER': 'AMD64 Family 21 Model 2 Stepping 0, AuthenticAMD', 'VBOX_MSI_INSTALL_PATH': 'C:\\Program Files\\Oracle\\VirtualBox\\', 'PROGRAMFILES': 'C:\\Program Files', 'PROCESSOR_REVISION': '0200', 'PATH': 'D:\\Development\\pemjh\\.tox\\py34_64\\Scripts;D:\\Development\\pemjh\\.venv\\py27_64\\Scripts;E:\\software_tools\\python\\python27_64;E:\\software_tools\\python\\python27_64\\Scripts;E:\\software_tools\\python\\pypy-2.6.1-win32;E:\\software_tools\\python\\pypy-2.6.1-win32\\bin;E:\\software_tools\\python\\python34_64;E:\\software_tools\\python\\python34_64\\Scripts;E:\\software_tools\\python\\python27;E:\\software_tools\\python\\python27\\Scripts;E:\\software_tools\\python\\python34;E:\\software_tools\\python\\python34\\Scripts;C:\\Program Files\\Haskell\\bin;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\lib\\extralibs\\bin;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\bin;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files (x86)\\EasyPHP-DevServer-14.1VC11\\binaries\\php\\php_runningversion;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Program Files\\Common Files\\Microsoft Shared\\Windows Live;C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\Windows Live;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\ATI Technologies\\ATI.ACE\\Core-Static;C:\\Program Files (x86)\\Windows Live\\Shared;C:\\Program Files (x86)\\AMD\\ATI.ACE\\Core-Static;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\mingw\\bin;C:\\Program Files\\Microsoft SQL Server\\110\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\120\\Tools\\Binn\\;C:\\Program Files\\TortoiseHg\\;C:\\WINDOWS\\system32\\config\\systemprofile\\.dnx\\bin;C:\\Program Files\\Microsoft DNX\\Dnvm\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\QuickTime\\QTSystem\\;C:\\Users\\Matt\\AppData\\Roaming\\cabal\\bin', 'SYSTEMROOT': 'C:\\WINDOWS', 'PROGRAMFILES(X86)': 'C:\\Program Files (x86)', '_OLD_VIRTUAL_PATH': 'E:\\software_tools\\python\\python27_64;E:\\software_tools\\python\\python27_64\\Scripts;E:\\software_tools\\python\\pypy-2.6.1-win32;E:\\software_tools\\python\\pypy-2.6.1-win32\\bin;E:\\software_tools\\python\\python34_64;E:\\software_tools\\python\\python34_64\\Scripts;E:\\software_tools\\python\\python27;E:\\software_tools\\python\\python27\\Scripts;E:\\software_tools\\python\\python34;E:\\software_tools\\python\\python34\\Scripts;C:\\Program Files\\Haskell\\bin;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\lib\\extralibs\\bin;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\bin;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files (x86)\\EasyPHP-DevServer-14.1VC11\\binaries\\php\\php_runningversion;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Program Files\\Common Files\\Microsoft Shared\\Windows Live;C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\Windows Live;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\ATI Technologies\\ATI.ACE\\Core-Static;C:\\Program Files (x86)\\Windows Live\\Shared;C:\\Program Files (x86)\\AMD\\ATI.ACE\\Core-Static;C:\\Program Files\\Haskell Platform\\2014.2.0.0\\mingw\\bin;C:\\Program Files\\Microsoft SQL Server\\110\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\120\\Tools\\Binn\\;C:\\Program Files\\TortoiseHg\\;C:\\WINDOWS\\system32\\config\\systemprofile\\.dnx\\bin;C:\\Program Files\\Microsoft DNX\\Dnvm\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\QuickTime\\QTSystem\\;C:\\Users\\Matt\\AppData\\Roaming\\cabal\\bin', 'VIRTUAL_ENV': 'D:\\Development\\pemjh\\.tox\\py34_64', 'TEMP': 'C:\\Users\\Matt\\AppData\\Local\\Temp', 'COMMONPROGRAMFILES(X86)': 'C:\\Program Files (x86)\\Common Files', 'PROCESSOR_ARCHITECTURE': 'AMD64', 'ALLUSERSPROFILE': 'C:\\ProgramData', 'PYTHONHASHSEED': '631', 'LOCALAPPDATA': 'C:\\Users\\Matt\\AppData\\Local', 'FPS_BROWSER_USER_PROFILE_STRING': 'Default', 'HOMEPATH': '\\Users\\Matt', 'USERDOMAIN_ROAMINGPROFILE': 'SLAYER', 'VS120COMNTOOLS': 'C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\Tools\\', 'PROGRAMW6432': 'C:\\Program Files', 'USERNAME': 'Matt', 'LOGONSERVER': '\\\\MicrosoftAccount', 'PROMPT': 'py27_64 $P$G', 'SESSIONNAME': 'Console', 'PROGRAMDATA': 'C:\\ProgramData', 'PLAT': 'win-amd64', 'FPS_BROWSER_APP_PROFILE_STRING': 'Internet Explorer', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY', 'ASL.LOG': 'Destination=file', 'FP_NO_HOST_CHECK': 'NO', 'WINDIR': 'C:\\WINDOWS', 'OPENSSL_CONF': 'C:\\Program Files\\PostgreSQL\\psqlODBC\\0903\\etc\\openssl.cnf', 'HOMEDRIVE': 'C:', 'APPDATA': 'C:\\Users\\Matt\\AppData\\Roaming', 'SYSTEMDRIVE': 'C:', 'VIRTUALENVDIR': 'cd\\virtualenvs', 'COMSPEC': 'C:\\WINDOWS\\system32\\cmd.exe', 'NUMBER_OF_PROCESSORS': '6', '_OLD_VIRTUAL_PROMPT': '$P$G', 'PROCESSOR_LEVEL': '21', 'COMMONPROGRAMW6432': 'C:\\Program Files\\Common Files', 'OS': 'Windows_NT', 'PUBLIC': 'C:\\Users\\Public', 'USERPROFILE': 'C:\\Users\\Matt'}

D:\Development\pemjh\.venv\py27_64\Scripts\python.exe: No module named virtualenv

ERROR: InvocationError: D:\Development\pemjh\.venv\py27_64\Scripts\python.exe -m virtualenv --python D:\Development\pemjh\.venv\py27_64\Scripts\python.exe py34_64 (see D:\Development\pemjh\.tox\py34_64\log\py34_64-0.log)
pypy inst-nodeps: D:\Development\pemjh\.tox\dist\pemjh-0.0.1.zip
pypy installed: apipkg==1.4,astroid==1.3.8,cffi==1.3.0,colorama==0.3.3,coverage==3.7.1,execnet==1.4.1,flake8==2.4.1,greenlet==0.4.7,logilab-common==1.0.2,mccabe==0.3.1,pemjh==0.0.1,pep8==1.5.7,py==1.4.30,pyflakes==0.8.1,pylint==1.4.4,pytest==2.7.2,pytest-cache==1.0,pytest-cov==2.1.0,pytest-flake8==0.1,pytest-pylint==0.3.0,readline==6.2.4.1,six==1.9.0,wheel==0.24.0
pypy runtests: PYTHONHASHSEED='631'
pypy runtests: commands[0] | py.test --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100
============================= test session starts =============================
platform win32 -- Python 2.7.10[pypy-2.6.1-final] -- py-1.4.30 -- pytest-2.7.2
rootdir: D:\Development\pemjh, inifile: 
plugins: cache, cov, flake8, pylint
collected 364 items / 65 errors

setup.py FF
pemjh\main.py FF
pemjh\challenge001\challenge001.py FF
pemjh\challenge002\challenge002.py FF
pemjh\challenge003\challenge003.py FF
pemjh\challenge004\challenge004.py FF
pemjh\challenge005\challenge005.py FF
pemjh\challenge006\challenge006.py FF
pemjh\challenge007\challenge007.py FF
pemjh\challenge008\challenge008.py FF
pemjh\challenge009\challenge009.py FF
pemjh\challenge010\challenge010.py FF
pemjh\challenge011\challenge011.py FF
pemjh\challenge012\challenge012.py FF
pemjh\challenge013\challenge013.py FF
pemjh\challenge014\challenge014.py FF
pemjh\challenge015\challenge015.py FF
pemjh\challenge016\challenge016.py FF
pemjh\challenge017\challenge017.py FF
pemjh\challenge018\challenge018.py FF
pemjh\challenge019\challenge019.py FF
pemjh\challenge020\challenge020.py FF
pemjh\challenge021\challenge021.py FF
pemjh\challenge022\challenge022.py FF
pemjh\challenge023\challenge023.py FF
pemjh\challenge024\challenge024.py FF
pemjh\challenge025\challenge025.py FF
pemjh\challenge026\challenge026.py FF
pemjh\challenge027\challenge027.py FF
pemjh\challenge028\challenge028.py FF
pemjh\challenge029\challenge029.py FF
pemjh\challenge030\challenge030.py FF
pemjh\challenge031\challenge031.py FF
pemjh\challenge032\challenge032.py FF
pemjh\challenge033\challenge033.py FF
pemjh\challenge034\challenge034.py FF
pemjh\challenge035\challenge035.py FF
pemjh\challenge036\challenge036.py FF
pemjh\challenge037\challenge037.py FF
pemjh\challenge038\challenge038.py FF
pemjh\challenge039\challenge039.py FF
pemjh\challenge040\challenge040.py FF
pemjh\challenge041\challenge041.py FF
pemjh\challenge042\challenge042.py FF
pemjh\challenge043\challenge043.py FF
pemjh\challenge044\challenge044.py FF
pemjh\challenge045\challenge045.py FF
pemjh\challenge046\challenge046.py FF
pemjh\challenge047\challenge047.py FF
pemjh\challenge048\challenge048.py FF
pemjh\challenge049\challenge049.py FF
pemjh\challenge050\challenge050.py FF
pemjh\challenge051\challenge051.py FF
pemjh\challenge052\challenge052.py FF
pemjh\challenge053\challenge053.py FF
pemjh\challenge054\challenge054.py FF
pemjh\challenge055\challenge055.py FF
pemjh\challenge056\challenge056.py FF
pemjh\challenge057\challenge057.py FF
pemjh\challenge058\challenge058.py FF
pemjh\challenge059\challenge059.py FF
pemjh\challenge060\challenge060.py FF
pemjh\challenge061\challenge061.py FF
pemjh\challenge062\challenge062.py FF
pemjh\challenge063\challenge063.py FF
pemjh\challenge064\challenge064.py FF
pemjh\challenge065\challenge065.py FF
pemjh\challenge066\challenge066.py FF
pemjh\challenge067\challenge067.py FF
pemjh\challenge068\challenge068.py FF
pemjh\challenge069\challenge069.py FF
pemjh\challenge070\challenge070.py FF
pemjh\challenge071\challenge071.py FF
pemjh\challenge072\challenge072.py FF
pemjh\challenge073\challenge073.py FF
pemjh\challenge074\challenge074.py FF
pemjh\challenge075\challenge075.py FF
pemjh\challenge076\challenge076.py FF
pemjh\challenge077\challenge077.py FF
pemjh\challenge078\challenge078.py FF
pemjh\challenge079\challenge079.py FF
pemjh\challenge080\challenge080.py FF
pemjh\challenge081\challenge081.py FF
pemjh\challenge082\challenge082.py FF
pemjh\challenge083\challenge083.py FF
pemjh\challenge084\challenge084.py FF
pemjh\challenge085\challenge085.py FF
pemjh\challenge086\challenge086.py FF
pemjh\challenge087\challenge087.py FF
pemjh\challenge088\challenge088.py FF
pemjh\challenge089\challenge089.py FF
pemjh\challenge090\challenge090.py FF
pemjh\challenge091\challenge091.py FF
pemjh\challenge092\challenge092.py FF
pemjh\challenge093\challenge093.py FF
pemjh\challenge094\challenge094.py FF
pemjh\challenge095\challenge095.py FF
pemjh\challenge096\challenge096.py FF
pemjh\challenge097\challenge097.py FF
pemjh\challenge098\challenge098.py FF
pemjh\challenge099\challenge099.py FF
pemjh\challenge100\challenge100.py F.
pemjh\challenge101\challenge101.py FF
pemjh\challenge102\challenge102.py FF
pemjh\challenge103\challenge103.py FF
pemjh\challenge104\challenge104.py FF
pemjh\challenge105\challenge105.py FF
pemjh\challenge106\challenge106.py FF
pemjh\challenge107\challenge107.py FF
pemjh\challenge108\challenge108.py FF
pemjh\challenge109\challenge109.py FF
pemjh\challenge110\challenge110.py FF
pemjh\challenge111\challenge111.py FF
pemjh\challenge112\challenge112.py FF
pemjh\challenge113\challenge113.py FF
pemjh\challenge114\challenge114.py FF
pemjh\challenge115\challenge115.py FF
pemjh\challenge116\challenge116.py FF
pemjh\challenge117\challenge117.py FF
pemjh\challenge118\challenge118.py FF
pemjh\challenge119\challenge119.py FF
pemjh\challenge120\challenge120.py FF
pemjh\challenge121\challenge121.py FF
pemjh\challenge122\challenge122.py FF
pemjh\challenge123\challenge123.py FF
pemjh\challenge124\challenge124.py FF
pemjh\challenge125\challenge125.py Fs
pemjh\challenge126\challenge126.py FF
pemjh\challenge127\challenge127.py FF
pemjh\challenge128\challenge128.py FF
pemjh\challenge129\challenge129.py FF
pemjh\challenge130\challenge130.py FF
pemjh\challenge131\challenge131.py FF
pemjh\challenge132\challenge132.py FF
pemjh\challenge133\challenge133.py FF
pemjh\challenge134\challenge134.py FF
pemjh\challenge135\challenge135.py FF
pemjh\challenge136\challenge136.py FF
pemjh\challenge137\challenge137.py FF
pemjh\challenge138\challenge138.py FF
pemjh\challenge139\challenge139.py FF
pemjh\challenge142\challenge142.py FF
pemjh\challenge144\challenge144.py FF
pemjh\challenge145\challenge145.py F.
pemjh\challenge146\challenge146.py FF
pemjh\challenge148\challenge148.py FF
pemjh\challenge149\challenge149.py FF
pemjh\challenge151\challenge151.py FF
pemjh\challenge162\challenge162.py FF
pemjh\challenge164\challenge164.py FF
pemjh\challenge166\challenge166.py FF
pemjh\challenge173\challenge173.py FF
pemjh\challenge174\challenge174.py FF
pemjh\challenge179\challenge179.py FF
pemjh\challenge183\challenge183.py FF
pemjh\challenge187\challenge187.py FF
pemjh\challenge188\challenge188.py FF
pemjh\challenge190\challenge190.py FF
pemjh\challenge191\challenge191.py FF
pemjh\challenge197\challenge197.py FF
pemjh\challenge203\challenge203.py FF
pemjh\challenge204\challenge204.py FF
pemjh\challenge205\challenge205.py FF
pemjh\challenge206\challenge206.py FF
pemjh\challenge207\challenge207.py F.
pemjh\challenge211\challenge211.py FF
pemjh\challenge214\challenge214.py FF
pemjh\challenge215\challenge215.py FF
pemjh\challenge216\challenge216.py FF
pemjh\challenge220\challenge220.py FF
pemjh\challenge225\challenge225.py FF
pemjh\challenge230\challenge230.py FF
pemjh\challenge231\challenge231.py FF
pemjh\challenge234\challenge234.py FF
pemjh\challenge235\challenge235.py FF
pemjh\challenge243\challenge243.py FF
pemjh\challenge250\challenge250.py FF
pemjh\challenge259\challenge259.py FF
pemjh\challenge265\challenge265.py FF
pemjh\utilities\__init__.py .s
pemjh\utilities\numbers.py FF
pemjh\utilities\strings.py Fs

=================================== ERRORS ====================================
__________________________ ERROR collecting setup.py __________________________

self = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
func = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'setup.py'>>
self       = <CallInfo when='memocollect' exception: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or...cmd1 cmd2 ...]
   or: py.test.EXE --help-commands
   or: py.test.EXE cmd --help

error: option --pylint not recognized>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>, attrname = '_collected'
function = <function <lambda> at 0x03d2be10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = None
function   = <function <lambda> at 0x03d2be10>
self       = <DoctestModule 'setup.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'setup.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'setup.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'setup.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\setup.py'), modname = 'setup'
ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'setup'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh')
self       = local('D:\\Development\\pemjh\\setup.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """ Setup file for install and test. Taken from:
    https://pythonhosted.org/an_example_pypi_project/setuptools.html
    for pytest:
    https://pytest.org/latest/goodpractises.html
    for tox:
    https://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands"""
    
    import os
    import sys
    from setuptools import setup
    from setuptools.command.test import test as TestCommand
    
    def read(fname):
        return open(os.path.join(os.path.dirname(__file__), fname)).read()
    
    class Tox(TestCommand):
        user_options = [('tox-args=', 'a', "Arguments to pass to tox")]
        def initialize_options(self):
            TestCommand.initialize_options(self)
            self.tox_args = None
        def finalize_options(self):
            TestCommand.finalize_options(self)
            self.test_args = []
            self.test_suite = True
        def run_tests(self):
            #import here, cause outside the eggs aren't loaded
            import tox
            import shlex
            args = self.tox_args
            if args:
                args = shlex.split(self.tox_args)
            errno = tox.cmdline(args=args)
            sys.exit(errno)
    
    setup(
        name = "pemjh",
        version = "0.0.1",
        author = "Matthew Hussey",
        author_email = "matthew.hussey@googlemail.com",
        description = ("Project euler (https://projecteuler.net/) challenge "
                       "code in Python."),
        license = "None, private use by myself only",
        keywords = "code challenge euler",
        url = "none.non",
        packages = ["pemjh"],
        long_description = read("README"),
        classifiers=[
            "Development Status :: 1 - Planning"],
        tests_require=['tox'],
>       cmdclass = {"test": Tox},
    )

TestCommand = <class setuptools.command.test.test at 0x03855268>
Tox        = <class setup.Tox at 0x03855238>
__builtins__ = <builtins>
__doc__    = ' Setup file for install and test. Taken from:\nhttps://pythonhosted.org/an_example_pypi_project/setuptools.html\nfor ...html\nfor tox:\nhttps://testrun.org/tox/latest/example/basic.html#integration-with-setuptools-distribute-test-commands'
__file__   = 'D:\\Development\\pemjh\\setup.py'
__name__   = 'setup'
__package__ = None
os         = <module 'os' from 'd:\\development\\pemjh\\.tox\\pypy\\lib-python\\2.7\\os.pyc'>
read       = <function read at 0x038e0c10>
setup      = <function setup at 0x031307d0>
sys        = <module 'sys' (built-in)>

setup.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

attrs = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x03855238>}, ...}
klass = <class setuptools.dist.Distribution at 0x03c30478>
dist = <setuptools.dist.Distribution instance at 0x03c81d1c>
msg = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

    def setup(**attrs):
        """The gateway to the Distutils: do everything your setup script needs
        to do, in a highly flexible and user-driven way.  Briefly: create a
        Distribution instance; find and parse config files; parse the command
        line; run each Distutils command found there, customized by the options
        supplied to 'setup()' (as keyword arguments), in config files, and on
        the command line.
    
        The Distribution instance might be an instance of a class supplied via
        the 'distclass' keyword argument to 'setup'; if no such class is
        supplied, then the Distribution class (in dist.py) is instantiated.
        All other arguments to 'setup' (except for 'cmdclass') are used to set
        attributes of the Distribution instance.
    
        The 'cmdclass' argument, if supplied, is a dictionary mapping command
        names to command classes.  Each command encountered on the command line
        will be turned into a command class, which is in turn instantiated; any
        class found in 'cmdclass' is used in place of the default, which is
        (for command 'foo_bar') class 'foo_bar' in module
        'distutils.command.foo_bar'.  The command class must provide a
        'user_options' attribute which is a list of option specifiers for
        'distutils.fancy_getopt'.  Any command-line options between the current
        and the next command are used to set attributes of the current command
        object.
    
        When the entire command-line has been successfully parsed, calls the
        'run()' method on each command object in turn.  This method will be
        driven entirely by the Distribution object (which each command object
        has a reference to, thanks to its constructor), and the
        command-specific options that became attributes of each command
        object.
        """
    
        global _setup_stop_after, _setup_distribution
    
        # Determine the distribution class -- either caller-supplied or
        # our Distribution (see below).
        klass = attrs.get('distclass')
        if klass:
            del attrs['distclass']
        else:
            klass = Distribution
    
        if 'script_name' not in attrs:
            attrs['script_name'] = os.path.basename(sys.argv[0])
        if 'script_args' not in attrs:
            attrs['script_args'] = sys.argv[1:]
    
        # Create the Distribution instance, using the remaining arguments
        # (ie. everything except distclass) to initialize it
        try:
            _setup_distribution = dist = klass(attrs)
        except DistutilsSetupError, msg:
            if 'name' in attrs:
                raise SystemExit, "error in %s setup command: %s" % \
                      (attrs['name'], msg)
            else:
                raise SystemExit, "error in setup command: %s" % msg
    
        if _setup_stop_after == "init":
            return dist
    
        # Find and parse the config file(s): they will override options from
        # the setup script, but be overridden by the command line.
        dist.parse_config_files()
    
        if DEBUG:
            print "options (after parsing config files):"
            dist.dump_option_dicts()
    
        if _setup_stop_after == "config":
            return dist
    
        # Parse the command line and override config files; any
        # command-line errors are the end user's fault, so turn them into
        # SystemExit to suppress tracebacks.
        try:
            ok = dist.parse_command_line()
        except DistutilsArgError, msg:
>           raise SystemExit, gen_usage(dist.script_name) + "\nerror: %s" % msg
E           SystemExit: usage: py.test.EXE [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
E              or: py.test.EXE --help [cmd1 cmd2 ...]
E              or: py.test.EXE --help-commands
E              or: py.test.EXE cmd --help
E           
E           error: option --pylint not recognized

attrs      = {'author': 'Matthew Hussey', 'author_email': 'matthew.hussey@googlemail.com', 'classifiers': ['Development Status :: 1 - Planning'], 'cmdclass': {'test': <class setup.Tox at 0x03855238>}, ...}
dist       = <setuptools.dist.Distribution instance at 0x03c81d1c>
klass      = <class setuptools.dist.Distribution at 0x03c30478>
msg        = DistutilsArgError(GetoptError('option --pylint not recognized', 'pylint'),)

E:\software_tools\python\pypy-2.6.1-win32\lib-python\2.7\distutils\core.py:139: SystemExit
_____________ ERROR collecting pemjh/challenge002/challenge002.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge002/challenge002.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>
attrname = '_collected', function = <function <lambda> at 0x03cc8290>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04179060>)
function   = <function <lambda> at 0x03cc8290>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge002/challenge002.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge002/challenge002.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')
modname = 'challenge002', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge002'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge002')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fibo
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge002\\challenge002.py'
__name__   = 'challenge002'
__package__ = None

pemjh\challenge002\challenge002.py:5: ImportError
_____________ ERROR collecting pemjh/challenge012/challenge012.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge012/challenge012.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>
attrname = '_collected', function = <function <lambda> at 0x0465d3d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03fec268>)
function   = <function <lambda> at 0x0465d3d0>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge012/challenge012.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge012/challenge012.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')
modname = 'challenge012', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge012'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge012')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    from math import sqrt
>   from utils.numbers import getNumDivisorsHelped
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge012\\challenge012.py'
__name__   = 'challenge012'
__package__ = None
sqrt       = <built-in function sqrt>

pemjh\challenge012\challenge012.py:6: ImportError
_____________ ERROR collecting pemjh/challenge015/challenge015.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge015/challenge015.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>
attrname = '_collected', function = <function <lambda> at 0x03ea4450>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04175984>)
function   = <function <lambda> at 0x03ea4450>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge015/challenge015.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge015/challenge015.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')
modname = 'challenge015', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge015'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge015')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge015\\challenge015.py'
__name__   = 'challenge015'
__package__ = None

pemjh\challenge015\challenge015.py:5: ImportError
_____________ ERROR collecting pemjh/challenge018/challenge018.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge018/challenge018.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>
attrname = '_collected', function = <function <lambda> at 0x033b7550>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0403c5b0>)
function   = <function <lambda> at 0x033b7550>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge018/challenge018.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge018/challenge018.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')
modname = 'challenge018', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge018'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge018')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge018\\challenge018.py'
__name__   = 'challenge018'
__package__ = None

pemjh\challenge018\challenge018.py:4: ImportError
_____________ ERROR collecting pemjh/challenge021/challenge021.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge021/challenge021.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>
attrname = '_collected', function = <function <lambda> at 0x03d2b7d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0464f7b8>)
function   = <function <lambda> at 0x03d2b7d0>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge021/challenge021.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge021/challenge021.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')
modname = 'challenge021', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge021'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge021')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import divisors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge021\\challenge021.py'
__name__   = 'challenge021'
__package__ = None

pemjh\challenge021\challenge021.py:5: ImportError
_____________ ERROR collecting pemjh/challenge024/challenge024.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge024/challenge024.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>
attrname = '_collected', function = <function <lambda> at 0x042a6c50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03999fd8>)
function   = <function <lambda> at 0x042a6c50>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge024/challenge024.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge024/challenge024.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')
modname = 'challenge024', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge024'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge024')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge024\\challenge024.py'
__name__   = 'challenge024'
__package__ = None

pemjh\challenge024\challenge024.py:5: ImportError
_____________ ERROR collecting pemjh/challenge025/challenge025.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge025/challenge025.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>
attrname = '_collected', function = <function <lambda> at 0x03e57a10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0428f448>)
function   = <function <lambda> at 0x03e57a10>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge025/challenge025.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge025/challenge025.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')
modname = 'challenge025', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge025'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge025')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fibo
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge025\\challenge025.py'
__name__   = 'challenge025'
__package__ = None

pemjh\challenge025\challenge025.py:4: ImportError
_____________ ERROR collecting pemjh/challenge027/challenge027.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge027/challenge027.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>
attrname = '_collected', function = <function <lambda> at 0x03ea4410>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0391ed80>)
function   = <function <lambda> at 0x03ea4410>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge027/challenge027.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge027/challenge027.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')
modname = 'challenge027', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge027'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge027')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge027\\challenge027.py'
__name__   = 'challenge027'
__package__ = None

pemjh\challenge027\challenge027.py:5: ImportError
_____________ ERROR collecting pemjh/challenge032/challenge032.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge032/challenge032.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>
attrname = '_collected', function = <function <lambda> at 0x03c4c090>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0465518c>)
function   = <function <lambda> at 0x03c4c090>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge032/challenge032.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge032/challenge032.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')
modname = 'challenge032', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge032'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge032')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.strings import permutate
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge032\\challenge032.py'
__name__   = 'challenge032'
__package__ = None

pemjh\challenge032\challenge032.py:5: ImportError
_____________ ERROR collecting pemjh/challenge033/challenge033.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge033/challenge033.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>
attrname = '_collected', function = <function <lambda> at 0x03e577d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03bcc010>)
function   = <function <lambda> at 0x03e577d0>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge033/challenge033.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge033/challenge033.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')
modname = 'challenge033', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge033'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge033')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import lowestCommonTerms
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge033\\challenge033.py'
__name__   = 'challenge033'
__package__ = None

pemjh\challenge033\challenge033.py:5: ImportError
_____________ ERROR collecting pemjh/challenge034/challenge034.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge034/challenge034.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>
attrname = '_collected', function = <function <lambda> at 0x041dfa10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03902e84>)
function   = <function <lambda> at 0x041dfa10>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge034/challenge034.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge034/challenge034.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')
modname = 'challenge034', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge034'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge034')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge034\\challenge034.py'
__name__   = 'challenge034'
__package__ = None

pemjh\challenge034\challenge034.py:5: ImportError
_____________ ERROR collecting pemjh/challenge035/challenge035.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge035/challenge035.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>
attrname = '_collected', function = <function <lambda> at 0x033b7a10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03bb7830>)
function   = <function <lambda> at 0x033b7a10>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge035/challenge035.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge035/challenge035.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')
modname = 'challenge035', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge035'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge035')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge035\\challenge035.py'
__name__   = 'challenge035'
__package__ = None

pemjh\challenge035\challenge035.py:5: ImportError
_____________ ERROR collecting pemjh/challenge037/challenge037.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge037/challenge037.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>
attrname = '_collected', function = <function <lambda> at 0x03d2ba90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x028a34c0>)
function   = <function <lambda> at 0x03d2ba90>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge037/challenge037.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge037/challenge037.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')
modname = 'challenge037', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge037'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge037')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge037\\challenge037.py'
__name__   = 'challenge037'
__package__ = None

pemjh\challenge037\challenge037.py:5: ImportError
_____________ ERROR collecting pemjh/challenge041/challenge041.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge041/challenge041.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>
attrname = '_collected', function = <function <lambda> at 0x0379d9d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04221f9c>)
function   = <function <lambda> at 0x0379d9d0>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge041/challenge041.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge041/challenge041.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')
modname = 'challenge041', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge041'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge041')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge041\\challenge041.py'
__name__   = 'challenge041'
__package__ = None

pemjh\challenge041\challenge041.py:5: ImportError
_____________ ERROR collecting pemjh/challenge043/challenge043.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge043/challenge043.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>
attrname = '_collected', function = <function <lambda> at 0x02ecaf10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02e4df10>)
function   = <function <lambda> at 0x02ecaf10>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge043/challenge043.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge043/challenge043.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')
modname = 'challenge043', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge043'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge043')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.strings import permutate
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge043\\challenge043.py'
__name__   = 'challenge043'
__package__ = None

pemjh\challenge043\challenge043.py:4: ImportError
_____________ ERROR collecting pemjh/challenge046/challenge046.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge046/challenge046.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>
attrname = '_collected', function = <function <lambda> at 0x0384f910>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03b66330>)
function   = <function <lambda> at 0x0384f910>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge046/challenge046.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge046/challenge046.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')
modname = 'challenge046', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge046'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge046')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import sqrt
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge046\\challenge046.py'
__name__   = 'challenge046'
__package__ = None
sqrt       = <built-in function sqrt>

pemjh\challenge046\challenge046.py:6: ImportError
_____________ ERROR collecting pemjh/challenge047/challenge047.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge047/challenge047.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>
attrname = '_collected', function = <function <lambda> at 0x0379df50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03993e84>)
function   = <function <lambda> at 0x0379df50>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge047/challenge047.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge047/challenge047.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')
modname = 'challenge047', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge047'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge047')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import count
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import primeFactors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge047\\challenge047.py'
__name__   = 'challenge047'
__package__ = None
count      = <type 'itertools.count'>

pemjh\challenge047\challenge047.py:6: ImportError
_____________ ERROR collecting pemjh/challenge049/challenge049.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge049/challenge049.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>
attrname = '_collected', function = <function <lambda> at 0x04ca8410>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x026acad8>)
function   = <function <lambda> at 0x04ca8410>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge049/challenge049.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge049/challenge049.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')
modname = 'challenge049', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge049'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge049')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    import string
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge049\\challenge049.py'
__name__   = 'challenge049'
__package__ = None
string     = <module 'string' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\string.pyc'>

pemjh\challenge049\challenge049.py:6: ImportError
_____________ ERROR collecting pemjh/challenge050/challenge050.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge050/challenge050.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>
attrname = '_collected', function = <function <lambda> at 0x03e23c90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0405e4ac>)
function   = <function <lambda> at 0x03e23c90>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge050/challenge050.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge050/challenge050.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')
modname = 'challenge050', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge050'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge050')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes, isPrime
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge050\\challenge050.py'
__name__   = 'challenge050'
__package__ = None

pemjh\challenge050\challenge050.py:4: ImportError
_____________ ERROR collecting pemjh/challenge051/challenge051.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge051/challenge051.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>
attrname = '_collected', function = <function <lambda> at 0x03af7d10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x045ba9c0>)
function   = <function <lambda> at 0x03af7d10>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge051/challenge051.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge051/challenge051.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')
modname = 'challenge051', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge051'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge051')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from itertools import cycle
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge051\\challenge051.py'
__name__   = 'challenge051'
__package__ = None
cycle      = <type 'itertools.cycle'>

pemjh\challenge051\challenge051.py:6: ImportError
_____________ ERROR collecting pemjh/challenge053/challenge053.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge053/challenge053.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>
attrname = '_collected', function = <function <lambda> at 0x0379da90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03c9e204>)
function   = <function <lambda> at 0x0379da90>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge053/challenge053.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge053/challenge053.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')
modname = 'challenge053', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge053'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge053')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge053\\challenge053.py'
__name__   = 'challenge053'
__package__ = None

pemjh\challenge053\challenge053.py:4: ImportError
_____________ ERROR collecting pemjh/challenge058/challenge058.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge058/challenge058.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>
attrname = '_collected', function = <function <lambda> at 0x03e57e10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0391f9fc>)
function   = <function <lambda> at 0x03e57e10>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge058/challenge058.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge058/challenge058.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')
modname = 'challenge058', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge058'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge058')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import isPrime, PrimeChecker
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge058\\challenge058.py'
__name__   = 'challenge058'
__package__ = None

pemjh\challenge058\challenge058.py:4: ImportError
_____________ ERROR collecting pemjh/challenge060/challenge060.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge060/challenge060.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>
attrname = '_collected', function = <function <lambda> at 0x0465dbd0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04649704>)
function   = <function <lambda> at 0x0465dbd0>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge060/challenge060.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge060/challenge060.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')
modname = 'challenge060', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge060'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge060')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import sievedPrimes, PrimeChecker
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge060\\challenge060.py'
__name__   = 'challenge060'
__package__ = None

pemjh\challenge060\challenge060.py:5: ImportError
_____________ ERROR collecting pemjh/challenge064/challenge064.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge064/challenge064.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>
attrname = '_collected', function = <function <lambda> at 0x042a6050>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x024d3074>)
function   = <function <lambda> at 0x042a6050>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge064/challenge064.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge064/challenge064.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')
modname = 'challenge064', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge064'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge064')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import continueGenerator
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge064\\challenge064.py'
__name__   = 'challenge064'
__package__ = None

pemjh\challenge064\challenge064.py:1: ImportError
_____________ ERROR collecting pemjh/challenge065/challenge065.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge065/challenge065.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>
attrname = '_collected', function = <function <lambda> at 0x04b8c8d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x037e0d44>)
function   = <function <lambda> at 0x04b8c8d0>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge065/challenge065.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge065/challenge065.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')
modname = 'challenge065', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge065'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge065')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge065\\challenge065.py'
__name__   = 'challenge065'
__package__ = None

pemjh\challenge065\challenge065.py:4: ImportError
_____________ ERROR collecting pemjh/challenge066/challenge066.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge066/challenge066.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>
attrname = '_collected', function = <function <lambda> at 0x044fe6d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03d1f7cc>)
function   = <function <lambda> at 0x044fe6d0>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge066/challenge066.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge066/challenge066.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')
modname = 'challenge066', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge066'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge066')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import rootConvergentGenerator
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge066\\challenge066.py'
__name__   = 'challenge066'
__package__ = None

pemjh\challenge066\challenge066.py:1: ImportError
_____________ ERROR collecting pemjh/challenge067/challenge067.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge067/challenge067.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>
attrname = '_collected', function = <function <lambda> at 0x0379db90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0391e7e0>)
function   = <function <lambda> at 0x0379db90>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge067/challenge067.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge067/challenge067.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')
modname = 'challenge067', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge067'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge067')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import with_statement
    from os.path import dirname, abspath
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
    
>   from utils.numbers import getTriangleRouteLength
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge067\\challenge067.py'
__name__   = 'challenge067'
__package__ = None
abspath    = <function abspath at 0x0206bd10>
dirname    = <function dirname at 0x0206bb50>
with_statement = _Feature((2, 5, 0, 'alpha', 1), (2, 6, 0, 'alpha', 0), 32768)

pemjh\challenge067\challenge067.py:9: ImportError
_____________ ERROR collecting pemjh/challenge069/challenge069.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge069/challenge069.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>
attrname = '_collected', function = <function <lambda> at 0x03e23bd0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0388b998>)
function   = <function <lambda> at 0x03e23bd0>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge069/challenge069.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge069/challenge069.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')
modname = 'challenge069', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge069'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge069')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge069\\challenge069.py'
__name__   = 'challenge069'
__package__ = None

pemjh\challenge069\challenge069.py:4: ImportError
_____________ ERROR collecting pemjh/challenge070/challenge070.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge070/challenge070.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>
attrname = '_collected', function = <function <lambda> at 0x033bf150>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04213718>)
function   = <function <lambda> at 0x033bf150>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge070/challenge070.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge070/challenge070.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')
modname = 'challenge070', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge070'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge070')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import phi
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge070\\challenge070.py'
__name__   = 'challenge070'
__package__ = None

pemjh\challenge070\challenge070.py:4: ImportError
_____________ ERROR collecting pemjh/challenge072/challenge072.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge072/challenge072.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>
attrname = '_collected', function = <function <lambda> at 0x04ca84d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03cfe6c8>)
function   = <function <lambda> at 0x04ca84d0>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge072/challenge072.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge072/challenge072.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')
modname = 'challenge072', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge072'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge072')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
    
>   from utils.numbers import phi
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge072\\challenge072.py'
__name__   = 'challenge072'
__package__ = None

pemjh\challenge072\challenge072.py:5: ImportError
_____________ ERROR collecting pemjh/challenge073/challenge073.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge073/challenge073.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>
attrname = '_collected', function = <function <lambda> at 0x03ea4050>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03c0127c>)
function   = <function <lambda> at 0x03ea4050>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge073/challenge073.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge073/challenge073.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')
modname = 'challenge073', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge073'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge073')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from math import ceil, floor
    
    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import divisors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge073\\challenge073.py'
__name__   = 'challenge073'
__package__ = None
ceil       = <built-in function ceil>
floor      = <built-in function floor>

pemjh\challenge073\challenge073.py:6: ImportError
_____________ ERROR collecting pemjh/challenge075/challenge075.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge075/challenge075.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>
attrname = '_collected', function = <function <lambda> at 0x04b8c1d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0420d560>)
function   = <function <lambda> at 0x04b8c1d0>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge075/challenge075.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge075/challenge075.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')
modname = 'challenge075', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge075'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge075')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge075\\challenge075.py'
__name__   = 'challenge075'
__package__ = None

pemjh\challenge075\challenge075.py:1: ImportError
_____________ ERROR collecting pemjh/challenge077/challenge077.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge077/challenge077.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>
attrname = '_collected', function = <function <lambda> at 0x03d2b990>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03d0272c>)
function   = <function <lambda> at 0x03d2b990>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge077/challenge077.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge077/challenge077.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')
modname = 'challenge077', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge077'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge077')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge077\\challenge077.py'
__name__   = 'challenge077'
__package__ = None

pemjh\challenge077\challenge077.py:1: ImportError
_____________ ERROR collecting pemjh/challenge087/challenge087.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge087/challenge087.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>
attrname = '_collected', function = <function <lambda> at 0x049a0290>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0329fe20>)
function   = <function <lambda> at 0x049a0290>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge087/challenge087.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge087/challenge087.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')
modname = 'challenge087', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge087'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge087')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge087\\challenge087.py'
__name__   = 'challenge087'
__package__ = None

pemjh\challenge087\challenge087.py:4: ImportError
_____________ ERROR collecting pemjh/challenge092/challenge092.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge092/challenge092.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>
attrname = '_collected', function = <function <lambda> at 0x02ecacd0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0370e218>)
function   = <function <lambda> at 0x02ecacd0>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge092/challenge092.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge092/challenge092.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')
modname = 'challenge092', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge092'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge092')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge092\\challenge092.py'
__name__   = 'challenge092'
__package__ = None

pemjh\challenge092\challenge092.py:4: ImportError
_____________ ERROR collecting pemjh/challenge104/challenge104.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge104/challenge104.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>
attrname = '_collected', function = <function <lambda> at 0x033d62d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04092c2c>)
function   = <function <lambda> at 0x033d62d0>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge104/challenge104.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge104/challenge104.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')
modname = 'challenge104', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge104'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge104')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge104\\challenge104.py'
__name__   = 'challenge104'
__package__ = None

pemjh\challenge104\challenge104.py:1: ImportError
_____________ ERROR collecting pemjh/challenge108/challenge108.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge108/challenge108.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>
attrname = '_collected', function = <function <lambda> at 0x02831ed0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x040d3b00>)
function   = <function <lambda> at 0x02831ed0>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge108/challenge108.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge108/challenge108.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')
modname = 'challenge108', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge108'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge108')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge108\\challenge108.py'
__name__   = 'challenge108'
__package__ = None

pemjh\challenge108\challenge108.py:1: ImportError
_____________ ERROR collecting pemjh/challenge110/challenge110.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge110/challenge110.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>
attrname = '_collected', function = <function <lambda> at 0x04323e50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03cff574>)
function   = <function <lambda> at 0x04323e50>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge110/challenge110.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge110/challenge110.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')
modname = 'challenge110', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge110'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge110')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge110\\challenge110.py'
__name__   = 'challenge110'
__package__ = None

pemjh\challenge110\challenge110.py:1: ImportError
_____________ ERROR collecting pemjh/challenge111/challenge111.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge111/challenge111.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>
attrname = '_collected', function = <function <lambda> at 0x03e23b50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03853df8>)
function   = <function <lambda> at 0x03e23b50>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge111/challenge111.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge111/challenge111.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')
modname = 'challenge111', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge111'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge111')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, roughPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge111\\challenge111.py'
__name__   = 'challenge111'
__package__ = None

pemjh\challenge111\challenge111.py:1: ImportError
_____________ ERROR collecting pemjh/challenge113/challenge113.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge113/challenge113.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>
attrname = '_collected', function = <function <lambda> at 0x049a0a90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03719bf0>)
function   = <function <lambda> at 0x049a0a90>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge113/challenge113.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge113/challenge113.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')
modname = 'challenge113', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge113'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge113')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    if __name__ == "__main__":
        import sys
        sys.path.append("..")
>   from utils.numbers import polytopicNumbers
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge113\\challenge113.py'
__name__   = 'challenge113'
__package__ = None

pemjh\challenge113\challenge113.py:4: ImportError
_____________ ERROR collecting pemjh/challenge118/challenge118.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge118/challenge118.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>
attrname = '_collected', function = <function <lambda> at 0x04ca8710>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03b7e7f4>)
function   = <function <lambda> at 0x04ca8710>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge118/challenge118.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge118/challenge118.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')
modname = 'challenge118', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge118'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge118')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import PrimeChecker, sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge118\\challenge118.py'
__name__   = 'challenge118'
__package__ = None

pemjh\challenge118\challenge118.py:1: ImportError
_____________ ERROR collecting pemjh/challenge121/challenge121.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge121/challenge121.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>
attrname = '_collected', function = <function <lambda> at 0x03480f10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x033bcbc8>)
function   = <function <lambda> at 0x03480f10>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge121/challenge121.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge121/challenge121.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')
modname = 'challenge121', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge121'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge121')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fact
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge121\\challenge121.py'
__name__   = 'challenge121'
__package__ = None

pemjh\challenge121\challenge121.py:1: ImportError
_____________ ERROR collecting pemjh/challenge123/challenge123.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge123/challenge123.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>
attrname = '_collected', function = <function <lambda> at 0x0470c110>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04174c2c>)
function   = <function <lambda> at 0x0470c110>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge123/challenge123.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge123/challenge123.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')
modname = 'challenge123', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge123'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge123')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge123\\challenge123.py'
__name__   = 'challenge123'
__package__ = None

pemjh\challenge123\challenge123.py:1: ImportError
_____________ ERROR collecting pemjh/challenge124/challenge124.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge124/challenge124.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>
attrname = '_collected', function = <function <lambda> at 0x0465d010>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03bd3600>)
function   = <function <lambda> at 0x0465d010>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge124/challenge124.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge124/challenge124.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')
modname = 'challenge124', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge124'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge124')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge124\\challenge124.py'
__name__   = 'challenge124'
__package__ = None

pemjh\challenge124\challenge124.py:1: ImportError
_____________ ERROR collecting pemjh/challenge127/challenge127.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge127/challenge127.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>
attrname = '_collected', function = <function <lambda> at 0x04b86b50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04076c2c>)
function   = <function <lambda> at 0x04b86b50>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge127/challenge127.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge127/challenge127.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')
modname = 'challenge127', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge127'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge127')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import gcd, sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge127\\challenge127.py'
__name__   = 'challenge127'
__package__ = None

pemjh\challenge127\challenge127.py:1: ImportError
_____________ ERROR collecting pemjh/challenge128/challenge128.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge128/challenge128.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>
attrname = '_collected', function = <function <lambda> at 0x05096590>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03389efc>)
function   = <function <lambda> at 0x05096590>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge128/challenge128.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge128/challenge128.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')
modname = 'challenge128', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge128'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge128')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge128\\challenge128.py'
__name__   = 'challenge128'
__package__ = None

pemjh\challenge128\challenge128.py:1: ImportError
_____________ ERROR collecting pemjh/challenge130/challenge130.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge130/challenge130.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>
attrname = '_collected', function = <function <lambda> at 0x03c4c790>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x04652650>)
function   = <function <lambda> at 0x03c4c790>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge130/challenge130.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge130/challenge130.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')
modname = 'challenge130', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge130'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge130')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge130\\challenge130.py'
__name__   = 'challenge130'
__package__ = None

pemjh\challenge130\challenge130.py:1: ImportError
_____________ ERROR collecting pemjh/challenge131/challenge131.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge131/challenge131.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>
attrname = '_collected', function = <function <lambda> at 0x0470cf90>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x034d727c>)
function   = <function <lambda> at 0x0470cf90>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge131/challenge131.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge131/challenge131.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')
modname = 'challenge131', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge131'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge131')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge131\\challenge131.py'
__name__   = 'challenge131'
__package__ = None

pemjh\challenge131\challenge131.py:1: ImportError
_____________ ERROR collecting pemjh/challenge132/challenge132.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge132/challenge132.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>
attrname = '_collected', function = <function <lambda> at 0x04ca8850>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03bfd4c0>)
function   = <function <lambda> at 0x04ca8850>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge132/challenge132.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge132/challenge132.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')
modname = 'challenge132', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge132'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge132')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge132\\challenge132.py'
__name__   = 'challenge132'
__package__ = None

pemjh\challenge132\challenge132.py:1: ImportError
_____________ ERROR collecting pemjh/challenge133/challenge133.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge133/challenge133.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>
attrname = '_collected', function = <function <lambda> at 0x04323a50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0314d934>)
function   = <function <lambda> at 0x04323a50>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge133/challenge133.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge133/challenge133.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')
modname = 'challenge133', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge133'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge133')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge133\\challenge133.py'
__name__   = 'challenge133'
__package__ = None

pemjh\challenge133\challenge133.py:1: ImportError
_____________ ERROR collecting pemjh/challenge134/challenge134.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge134/challenge134.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>
attrname = '_collected', function = <function <lambda> at 0x0465d490>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02f58448>)
function   = <function <lambda> at 0x0465d490>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge134/challenge134.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge134/challenge134.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')
modname = 'challenge134', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge134'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge134')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge134\\challenge134.py'
__name__   = 'challenge134'
__package__ = None

pemjh\challenge134\challenge134.py:1: ImportError
_____________ ERROR collecting pemjh/challenge136/challenge136.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge136/challenge136.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>
attrname = '_collected', function = <function <lambda> at 0x04cdd350>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03b74920>)
function   = <function <lambda> at 0x04cdd350>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge136/challenge136.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge136/challenge136.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')
modname = 'challenge136', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge136'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge136')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge136\\challenge136.py'
__name__   = 'challenge136'
__package__ = None

pemjh\challenge136\challenge136.py:1: ImportError
_____________ ERROR collecting pemjh/challenge138/challenge138.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge138/challenge138.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>
attrname = '_collected', function = <function <lambda> at 0x038e0e10>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03bfcb28>)
function   = <function <lambda> at 0x038e0e10>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge138/challenge138.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge138/challenge138.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')
modname = 'challenge138', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge138'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge138')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import fibo
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge138\\challenge138.py'
__name__   = 'challenge138'
__package__ = None

pemjh\challenge138\challenge138.py:1: ImportError
_____________ ERROR collecting pemjh/challenge139/challenge139.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge139/challenge139.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>
attrname = '_collected', function = <function <lambda> at 0x04e4f990>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x02f761b4>)
function   = <function <lambda> at 0x04e4f990>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge139/challenge139.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge139/challenge139.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')
modname = 'challenge139', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge139'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge139')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import getPrimitiveTriples
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge139\\challenge139.py'
__name__   = 'challenge139'
__package__ = None

pemjh\challenge139\challenge139.py:1: ImportError
_____________ ERROR collecting pemjh/challenge174/challenge174.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge174/challenge174.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>
attrname = '_collected', function = <function <lambda> at 0x0470c7d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x040a5740>)
function   = <function <lambda> at 0x0470c7d0>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge174/challenge174.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge174/challenge174.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')
modname = 'challenge174', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge174'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge174')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge174\\challenge174.py'
__name__   = 'challenge174'
__package__ = None

pemjh\challenge174\challenge174.py:1: ImportError
_____________ ERROR collecting pemjh/challenge183/challenge183.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge183/challenge183.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>
attrname = '_collected', function = <function <lambda> at 0x04b8c3d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0339c128>)
function   = <function <lambda> at 0x04b8c3d0>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge183/challenge183.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge183/challenge183.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')
modname = 'challenge183', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge183'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge183')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import primeFactors
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge183\\challenge183.py'
__name__   = 'challenge183'
__package__ = None

pemjh\challenge183\challenge183.py:1: ImportError
_____________ ERROR collecting pemjh/challenge187/challenge187.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge187/challenge187.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>
attrname = '_collected', function = <function <lambda> at 0x04323790>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x034826f0>)
function   = <function <lambda> at 0x04323790>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge187/challenge187.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge187/challenge187.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')
modname = 'challenge187', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge187'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge187')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge187\\challenge187.py'
__name__   = 'challenge187'
__package__ = None

pemjh\challenge187\challenge187.py:1: ImportError
_____________ ERROR collecting pemjh/challenge203/challenge203.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge203/challenge203.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>
attrname = '_collected', function = <function <lambda> at 0x047d45d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x03baeee8>)
function   = <function <lambda> at 0x047d45d0>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge203/challenge203.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge203/challenge203.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')
modname = 'challenge203', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge203'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge203')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge203\\challenge203.py'
__name__   = 'challenge203'
__package__ = None

pemjh\challenge203\challenge203.py:1: ImportError
_____________ ERROR collecting pemjh/challenge204/challenge204.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge204/challenge204.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>
attrname = '_collected', function = <function <lambda> at 0x04b4dc50>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x034e7fb0>)
function   = <function <lambda> at 0x04b4dc50>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge204/challenge204.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge204/challenge204.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')
modname = 'challenge204', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge204'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge204')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge204\\challenge204.py'
__name__   = 'challenge204'
__package__ = None

pemjh\challenge204\challenge204.py:1: ImportError
_____________ ERROR collecting pemjh/challenge211/challenge211.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge211/challenge211.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>
attrname = '_collected', function = <function <lambda> at 0x0470c1d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0387c6f0>)
function   = <function <lambda> at 0x0470c1d0>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge211/challenge211.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge211/challenge211.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')
modname = 'challenge211', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge211'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge211')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import divisors, sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge211\\challenge211.py'
__name__   = 'challenge211'
__package__ = None

pemjh\challenge211\challenge211.py:1: ImportError
_____________ ERROR collecting pemjh/challenge214/challenge214.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge214/challenge214.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>
attrname = '_collected', function = <function <lambda> at 0x033b7690>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0273c22c>)
function   = <function <lambda> at 0x033b7690>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge214/challenge214.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge214/challenge214.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')
modname = 'challenge214', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge214'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge214')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes, primeFactors, phi
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge214\\challenge214.py'
__name__   = 'challenge214'
__package__ = None

pemjh\challenge214\challenge214.py:1: ImportError
_____________ ERROR collecting pemjh/challenge231/challenge231.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge231/challenge231.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>
attrname = '_collected', function = <function <lambda> at 0x0445f1d0>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x046bd40c>)
function   = <function <lambda> at 0x0445f1d0>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge231/challenge231.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge231/challenge231.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')
modname = 'challenge231', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge231'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge231')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge231\\challenge231.py'
__name__   = 'challenge231'
__package__ = None

pemjh\challenge231\challenge231.py:1: ImportError
_____________ ERROR collecting pemjh/challenge234/challenge234.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge234/challenge234.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>
attrname = '_collected', function = <function <lambda> at 0x03cc8350>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x034ec9d4>)
function   = <function <lambda> at 0x03cc8350>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge234/challenge234.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge234/challenge234.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')
modname = 'challenge234', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge234'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge234')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge234\\challenge234.py'
__name__   = 'challenge234'
__package__ = None

pemjh\challenge234\challenge234.py:1: ImportError
_____________ ERROR collecting pemjh/challenge243/challenge243.py _____________

self = <CallInfo when='memocollect' exception: No module named utils>
func = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
when = 'memocollect'

    def __init__(self, func, when):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        self.when = when
        self.start = time()
        try:
>           self.result = func()

func       = <bound method DoctestModule._memocollect of <DoctestModule 'pemjh/challenge243/challenge243.py'>>
self       = <CallInfo when='memocollect' exception: No module named utils>
when       = 'memocollect'

.tox\pypy\site-packages\_pytest\runner.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def _memocollect(self):
        """ internal helper method to cache results of calling collect(). """
>       return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>
attrname = '_collected', function = <function <lambda> at 0x0379d610>

    def _memoizedcall(self, attrname, function):
        exattrname = "_ex_" + attrname
        failure = getattr(self, exattrname, None)
        if failure is not None:
            py.builtin._reraise(failure[0], failure[1], failure[2])
        if hasattr(self, attrname):
            return getattr(self, attrname)
        try:
>           res = function()

attrname   = '_collected'
exattrname = '_ex__collected'
failure    = (<type 'exceptions.ImportError'>, ImportError('No module named utils',), <traceback object at 0x0461f9fc>)
function   = <function <lambda> at 0x0379d610>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\pypy\site-packages\_pytest\main.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   return self._memoizedcall('_collected', lambda: list(self.collect()))

self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\pypy\site-packages\_pytest\main.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DoctestModule 'pemjh/challenge243/challenge243.py'>

    def collect(self):
        import doctest
        if self.fspath.basename == "conftest.py":
            module = self.config._conftest.importconftest(self.fspath)
        else:
            try:
>               module = self.fspath.pyimport()

doctest    = <module 'doctest' from 'E:\\software_tools\\python\\pypy-2.6.1-win32\\lib-python\\2.7\\doctest.pyc'>
self       = <DoctestModule 'pemjh/challenge243/challenge243.py'>

.tox\pypy\site-packages\_pytest\doctest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')
modname = 'challenge243', ensuresyspath = True

    def pyimport(self, modname=None, ensuresyspath=True):
        """ return path as an imported python module.
    
            If modname is None, look for the containing package
            and construct an according module name.
            The module will be put/looked up in sys.modules.
            if ensuresyspath is True then the root dir for importing
            the file (taking __init__.py files into account) will
            be prepended to sys.path if it isn't there already.
            If ensuresyspath=="append" the root dir will be appended
            if it isn't already contained in sys.path.
            if ensuresyspath is False no modification of syspath happens.
            """
        if not self.check():
            raise py.error.ENOENT(self)
    
        pkgpath = None
        if modname is None:
            pkgpath = self.pypkgpath()
            if pkgpath is not None:
                pkgroot = pkgpath.dirpath()
                names = self.new(ext="").relto(pkgroot).split(self.sep)
                if names[-1] == "__init__":
                    names.pop()
                modname = ".".join(names)
            else:
                pkgroot = self.dirpath()
                modname = self.purebasename
    
            self._ensuresyspath(ensuresyspath, pkgroot)
>           __import__(modname)

ensuresyspath = True
modname    = 'challenge243'
pkgpath    = None
pkgroot    = local('D:\\Development\\pemjh\\pemjh\\challenge243')
self       = local('D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py')

.tox\pypy\site-packages\py\_path\local.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from utils.numbers import sievedPrimes
E   ImportError: No module named utils

__builtins__ = <builtins>
__doc__    = None
__file__   = 'D:\\Development\\pemjh\\pemjh\\challenge243\\challenge243.py'
__name__   = 'challenge243'
__package__ = None

pemjh\challenge243\challenge243.py:1: ImportError
================================== FAILURES ===================================
______________________________ [pylint] setup.py ______________________________
C: 36, 0: No space allowed around keyword argument assignment
    name = "pemjh",
         ^ (bad-whitespace)
C: 37, 0: No space allowed around keyword argument assignment
    version = "0.0.1",
            ^ (bad-whitespace)
C: 38, 0: No space allowed around keyword argument assignment
    author = "Matthew Hussey",
           ^ (bad-whitespace)
C: 39, 0: No space allowed around keyword argument assignment
    author_email = "matthew.hussey@googlemail.com",
                 ^ (bad-whitespace)
C: 40, 0: No space allowed around keyword argument assignment
    description = ("Project euler (https://projecteuler.net/) challenge "
                ^ (bad-whitespace)
C: 42, 0: No space allowed around keyword argument assignment
    license = "None, private use by myself only",
            ^ (bad-whitespace)
C: 43, 0: No space allowed around keyword argument assignment
    keywords = "code challenge euler",
             ^ (bad-whitespace)
C: 44, 0: No space allowed around keyword argument assignment
    url = "none.non",
        ^ (bad-whitespace)
C: 45, 0: No space allowed around keyword argument assignment
    packages = ["pemjh"],
             ^ (bad-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
    long_description = read("README"),
                     ^ (bad-whitespace)
C: 50, 0: No space allowed around keyword argument assignment
    cmdclass = {"test": Tox},
             ^ (bad-whitespace)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing class docstring (missing-docstring)
F: 27, 8: Unable to import 'tox' (import-error)
W: 20, 8: Attribute 'tox_args' defined outside __init__ (attribute-defined-outside-init)
W: 23, 8: Attribute 'test_args' defined outside __init__ (attribute-defined-outside-init)
W: 24, 8: Attribute 'test_suite' defined outside __init__ (attribute-defined-outside-init)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\setup.py:6:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\setup.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\setup.py:18:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:21:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:25:5: E301 expected 1 blank line, found 0
D:\Development\pemjh\setup.py:26:9: E265 block comment should start with '# '
D:\Development\pemjh\setup.py:36:9: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:36:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:12: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:37:14: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:11: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:38:13: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:39:19: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\setup.py:40:18: E251 unexpected spaces around keyword / parameter equals

___________________________ [pylint] pemjh/main.py ____________________________
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 58, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  9, 0: No exception type(s) specified (bare-except)
F:  6, 4: Unable to import 'psyco' (import-error)
C: 12, 0: Invalid function name "testFunction" (invalid-name)
C: 12, 0: Invalid argument name "id" (invalid-name)
C: 12, 0: Invalid argument name "knownAnswer" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
W: 12,17: Redefining built-in 'id' (redefined-builtin)
W: 12,21: Redefining name 'func' from outer scope (line 43) (redefined-outer-name)
W: 12,27: Redefining name 'knownAnswer' from outer scope (line 46) (redefined-outer-name)
C: 30, 0: Invalid constant name "wholeTime" (invalid-name)
C: 32, 0: Invalid constant name "failures" (invalid-name)
C: 34, 0: Invalid constant name "nChallenges" (invalid-name)
C: 60, 0: Invalid constant name "wholeTime" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\main.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\main.py:13:15: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\main.py:18:24: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\main.py:32:18: W291 trailing whitespace
D:\Development\pemjh\pemjh\main.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\main.py:58:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge001/challenge001.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid constant name "upper" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  4,15: Used builtin function 'filter' (bad-builtin)
W:  4,15: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C:  6, 0: Invalid constant name "answer" (invalid-name)
W:  9, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge001\challenge001.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge001\challenge001.py:4:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge001\challenge001.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge001\challenge001.py:9:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge002/challenge002.py _________________
C: 10, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "numRange" (invalid-name)
C: 10, 4: Invalid variable name "evenNums" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge002\challenge002.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge003/challenge003.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 19,26: More than one statement on a single line (multiple-statements)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import math (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge003\challenge003.py:1:1: F401 'math' imported but unused
D:\Development\pemjh\pemjh\challenge003\challenge003.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge003\challenge003.py:4:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:8:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:10:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge003\challenge003.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge003\challenge003.py:19:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge003\challenge003.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge004/challenge004.py _________________
C:  8, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 18, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 26, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 18,61: More than one statement on a single line (multiple-statements)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W: 36, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge004\challenge004.py:18:60: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge004\challenge004.py:20:13: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge004\challenge004.py:26:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge004\challenge004.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge005/challenge005.py _________________
C: 12, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  3, 4: Redefining built-in 'max' (redefined-builtin)
C:  6, 8: Invalid variable name "n" (invalid-name)
C: 14,16: Invalid variable name "n" (invalid-name)
C: 28,23: More than one statement on a single line (multiple-statements)
C: 31, 8: Invalid variable name "n" (invalid-name)
C: 31,11: Invalid variable name "p" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge005\challenge005.py:28:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge005\challenge005.py:33:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge005\challenge005.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge006/challenge006.py _________________
C: 11, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'max' (redefined-builtin)
W: 10, 4: Redefining built-in 'sum' (redefined-builtin)
C:  4, 4: Invalid variable name "sumOfSquares" (invalid-name)
C:  7, 8: Invalid variable name "sumOfSquares" (invalid-name)
C: 13, 4: Invalid variable name "squareOfSums" (invalid-name)
C: 20, 0: Invalid constant name "answer" (invalid-name)
W: 23, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge006\challenge006.py:11:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge006\challenge006.py:23:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge007/challenge007.py _________________
C: 14, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'max' (redefined-builtin)
C: 13, 8: Invalid variable name "primeRange" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
W: 24, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge007\challenge007.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge007\challenge007.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge008/challenge008.py _________________
C: 29, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining built-in 'input' (redefined-builtin)
C: 26, 8: Invalid variable name "testPart" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
W: 44, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge008\challenge008.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge008\challenge008.py:44:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge009/challenge009.py _________________
C:  8, 0: Exactly one space required after comma
    for a in range(1,(max / 3)):
                    ^ (bad-whitespace)
C: 11, 0: Exactly one space required after comma
        for b in range((a + 1),(a + 1 + (remainder / 2))):
                              ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W:  4, 4: Redefining built-in 'max' (redefined-builtin)
W:  5, 4: Redefining name 'answer' from outer scope (line 18) (redefined-outer-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C: 11,12: Invalid variable name "b" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge009\challenge009.py:8:21: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:11:31: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge009\challenge009.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge010/challenge010.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
W:  6, 4: Redefining built-in 'max' (redefined-builtin)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ifilter imported from itertools (unused-import)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge010\challenge010.py:1:1: F401 'ifilter' imported but unused
D:\Development\pemjh\pemjh\challenge010\challenge010.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge010\challenge010.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge011/challenge011.py _________________
C:  2, 0: Line too long (1212/100) (line-too-long)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCols" (invalid-name)
C: 10, 8: Invalid variable name "currentRow" (invalid-name)
C: 12,12: Invalid variable name "nextChunk" (invalid-name)
C: 31,36: More than one statement on a single line (multiple-statements)
C: 38,40: More than one statement on a single line (multiple-statements)
C: 45,40: More than one statement on a single line (multiple-statements)
C: 52,36: More than one statement on a single line (multiple-statements)
W: 11,12: Unused variable 'index' (unused-variable)
R:  1, 0: Too many branches (16/12) (too-many-branches)
C: 58, 0: Invalid constant name "answer" (invalid-name)
W: 61, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge011\challenge011.py:2:80: E501 line too long (1212 > 79 characters)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:31:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:34:38: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge011\challenge011.py:38:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:45:39: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:52:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge011\challenge011.py:56:5: E303 too many blank lines (3)
D:\Development\pemjh\pemjh\challenge011\challenge011.py:61:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge012/challenge012.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 15, 0: Invalid function name "triangleDivisors" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 16, 4: Invalid variable name "n" (invalid-name)
C: 17, 4: Invalid variable name "nOdd" (invalid-name)
C: 18, 4: Invalid variable name "nEven" (invalid-name)
C: 19, 4: Invalid variable name "knownDivisors" (invalid-name)
C: 24,12: Invalid variable name "nOdd" (invalid-name)
C: 27,12: Invalid variable name "nEven" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36,22: More than one statement on a single line (multiple-statements)
W: 38,12: Using possibly undefined loop variable 'n' (undefined-loop-variable)
W: 38,17: Using possibly undefined loop variable 'n' (undefined-loop-variable)
C: 40, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge012\challenge012.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge012\challenge012.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge012\challenge012.py:36:21: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge013/challenge013.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:111, 0: Invalid constant name "answer" (invalid-name)
W:114, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge013\challenge013.py:2:68: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:3:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:4:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:5:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:6:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:7:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:8:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:9:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:10:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:11:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:12:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:13:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:14:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:15:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:16:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:17:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:18:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:19:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:20:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:21:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:22:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:23:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:24:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:25:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:26:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:27:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:28:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:29:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:30:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:31:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:32:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:33:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:34:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:35:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:36:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:37:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:38:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:39:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:40:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:41:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:42:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:43:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:44:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:45:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:46:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:47:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:48:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:49:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:50:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:51:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:52:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:53:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:54:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:55:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:56:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:57:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:58:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:59:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:60:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:61:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:62:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:63:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:64:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:65:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:66:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:67:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:68:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:69:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:70:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:71:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:72:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:73:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:74:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:75:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:76:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:77:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:78:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:79:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:80:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:81:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:82:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:83:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:84:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:85:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:86:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:87:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:88:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:89:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:90:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:91:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:92:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:93:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:94:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:95:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:96:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:97:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:98:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:99:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:100:72: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge013\challenge013.py:101:20: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge013\challenge013.py:114:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge014/challenge014.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getChainSize" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "knownChains" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "knownChains" (invalid-name)
C: 31, 8: Invalid variable name "newChain" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge014\challenge014.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge014\challenge014.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge015/challenge015.py _________________
C:  7, 0: No space allowed around keyword argument assignment
def multiplierGen(n = 0):
                    ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "multiplierGen" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid function name "getRoutes" (invalid-name)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:7:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge015\challenge015.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge015\challenge015.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge016/challenge016.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge016\challenge016.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge017/challenge017.py _________________
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 37, 0: Trailing whitespace (trailing-whitespace)
C:103, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumberLength" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Invalid argument name "hundredRep" (invalid-name)
C:  1, 0: Invalid argument name "andRep" (invalid-name)
C:  1, 0: Invalid argument name "thousandRep" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "tempN" (invalid-name)
C:  7, 8: Invalid variable name "numberRepresentation" (invalid-name)
C: 13,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 16,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 18,12: Invalid variable name "tempN" (invalid-name)
C: 22,12: Invalid variable name "numberRepresentation" (invalid-name)
C: 29,16: Invalid variable name "tempN" (invalid-name)
C: 31,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 35,16: Invalid variable name "numberRepresentation" (invalid-name)
C: 41, 0: Missing function docstring (missing-docstring)
C: 70, 4: Invalid variable name "knownInts" (invalid-name)
C:100, 4: Invalid variable name "endLine" (invalid-name)
W: 70, 4: Unused variable 'knownInts' (unused-variable)
W:100, 4: Unused variable 'endLine' (unused-variable)
C:106, 0: Invalid constant name "answer" (invalid-name)
W:109, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge017\challenge017.py:21:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge017\challenge017.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:37:36: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:41:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge017\challenge017.py:42:21: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:43:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:44:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:45:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:46:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:47:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:48:28: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:49:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:50:30: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:51:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:52:29: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:53:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:54:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:55:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:56:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:57:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:58:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:59:35: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:60:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:61:34: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:62:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:63:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:64:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:65:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:66:31: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:67:33: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:68:32: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:69:18: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:5: F841 local variable 'knownInts' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:70:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:71:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:72:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:73:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:74:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:75:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:76:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:77:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:78:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:79:24: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:80:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:81:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:82:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:83:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:84:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:85:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:86:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:87:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:88:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:89:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:90:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:91:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:92:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:93:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:94:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:95:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:96:25: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge017\challenge017.py:100:5: F841 local variable 'endLine' is assigned to but never used
D:\Development\pemjh\pemjh\challenge017\challenge017.py:103:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge017\challenge017.py:109:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge018/challenge018.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge018\challenge018.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge018\challenge018.py:30:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge019/challenge019.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isLeapYear" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "getYearDays" (invalid-name)
C:  5, 0: Invalid argument name "y" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "getFirstJan" (invalid-name)
C: 11, 0: Invalid argument name "y" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "totalDays" (invalid-name)
C: 14, 8: Invalid variable name "totalDays" (invalid-name)
C: 17, 0: Invalid function name "monthStartDays" (invalid-name)
C: 17, 0: Invalid argument name "y" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "monthLengths" (invalid-name)
C: 25, 8: Invalid variable name "m" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "totalDays" (invalid-name)
C: 34, 8: Invalid variable name "y" (invalid-name)
C: 36,12: Invalid variable name "d" (invalid-name)
C: 38,16: Invalid variable name "totalDays" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
W: 45, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge019\challenge019.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge019\challenge019.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge020/challenge020.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "c" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge020\challenge020.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge020\challenge020.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge021/challenge021.py _________________
C: 18, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
W: 11, 4: Redefining built-in 'dict' (redefined-builtin)
C: 12, 8: Invalid variable name "a" (invalid-name)
C: 14, 8: Invalid variable name "b" (invalid-name)
C: 15,12: Invalid variable name "d" (invalid-name)
C: 16,12: Invalid variable name "b" (invalid-name)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge021\challenge021.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge021\challenge021.py:18:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge021\challenge021.py:20:20: W601 .has_key() is deprecated, use 'in'

_________________ [pylint] pemjh/challenge022/challenge022.py _________________
C: 25, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getNames" (invalid-name)
C:  4, 0: Invalid argument name "fp" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7,21: Invalid variable name "f" (invalid-name)
C: 16, 0: Invalid function name "scoredNames" (invalid-name)
C: 16, 0: Invalid argument name "f" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 21,12: Invalid variable name "c" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 29, 8: Invalid variable name "s" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W: 37, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge022\challenge022.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge022\challenge022.py:25:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:31:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge022\challenge022.py:37:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge023/challenge023.py _________________
C: 10, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "sumOfDivisors" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "p" (invalid-name)
C: 13,12: Invalid variable name "p" (invalid-name)
C: 23, 0: Invalid function name "isSum" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 0: Missing function docstring (missing-docstring)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge023\challenge023.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge023\challenge023.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge024/challenge024.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge024\challenge024.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge024\challenge024.py:11:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge024\challenge024.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge025/challenge025.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8,11: Invalid variable name "c" (invalid-name)
C:  9, 8: Invalid variable name "l" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge025\challenge025.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge026/challenge026.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "biggestD" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C: 14,12: Invalid variable name "newSize" (invalid-name)
C: 18,16: Invalid variable name "biggestD" (invalid-name)
C: 20,12: Invalid variable name "newSize" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused import string (unused-import)
W: 28, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge026\challenge026.py:1:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge026\challenge026.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge026\challenge026.py:15:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:23:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge026\challenge026.py:28:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge027/challenge027.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "aMax" (invalid-name)
C: 13, 4: Invalid variable name "bMax" (invalid-name)
C: 16, 4: Invalid variable name "bS" (invalid-name)
C: 17, 8: Invalid variable name "b" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "n" (invalid-name)
C: 21,16: Invalid variable name "f" (invalid-name)
C: 22,35: More than one statement on a single line (multiple-statements)
C: 23,16: Invalid variable name "n" (invalid-name)
C: 27,16: Invalid variable name "aMax" (invalid-name)
C: 28,16: Invalid variable name "bMax" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge027\challenge027.py:6:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge027\challenge027.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge027\challenge027.py:22:34: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge027\challenge027.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge027\challenge027.py:35:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge028/challenge028.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge028\challenge028.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge028\challenge028.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge029/challenge029.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "aLower" (invalid-name)
C:  3, 4: Invalid variable name "aUpper" (invalid-name)
C:  4, 4: Invalid variable name "bLower" (invalid-name)
C:  5, 4: Invalid variable name "bUpper" (invalid-name)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  9,12: Invalid variable name "b" (invalid-name)
C: 14, 0: Invalid constant name "answer" (invalid-name)
W: 17, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge029\challenge029.py:17:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge030/challenge030.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "perDigit" (invalid-name)
C:  7, 4: Invalid variable name "grandTotal" (invalid-name)
C: 11,12: Invalid variable name "c" (invalid-name)
C: 12,12: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "grandTotal" (invalid-name)
C: 18, 0: Invalid constant name "answer" (invalid-name)
W: 21, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge030\challenge030.py:21:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge031/challenge031.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPatternCount" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid constant name "answer" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
W: 22, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge031\challenge031.py:16:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge031\challenge031.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge031\challenge031.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge032/challenge032.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.strings' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge032\challenge032.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge032\challenge032.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge033/challenge033.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "totalNum" (invalid-name)
C:  9, 4: Invalid variable name "totalDen" (invalid-name)
C: 20,16: Invalid variable name "n1" (invalid-name)
C: 21,16: Invalid variable name "n2" (invalid-name)
C: 22,16: Invalid variable name "d3" (invalid-name)
C: 23,16: Invalid variable name "d4" (invalid-name)
C: 29,24: Invalid variable name "totalNum" (invalid-name)
C: 30,24: Invalid variable name "totalDen" (invalid-name)
C: 37,24: Invalid variable name "totalNum" (invalid-name)
C: 38,24: Invalid variable name "totalDen" (invalid-name)
C: 40, 4: Invalid variable name "totalNum" (invalid-name)
C: 40,14: Invalid variable name "totalDen" (invalid-name)
C: 44, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge033\challenge033.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:28:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge033\challenge033.py:36:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge033\challenge033.py:47:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge034/challenge034.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "getLimit" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "factSum" (invalid-name)
C:  9, 4: Invalid variable name "factNine" (invalid-name)
C: 13, 8: Invalid variable name "factSum" (invalid-name)
C: 15,29: More than one statement on a single line (multiple-statements)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 8: Invalid variable name "iStr" (invalid-name)
C: 35, 8: Invalid variable name "iTotal" (invalid-name)
C: 36,12: Invalid variable name "c" (invalid-name)
C: 37,12: Invalid variable name "iTotal" (invalid-name)
C: 42, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge034\challenge034.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:15:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge034\challenge034.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge034\challenge034.py:45:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge035/challenge035.py _________________
C: 32, 0: Wrong continued indentation.
              if b == True and
              ^   | (bad-continuation)
C: 33, 0: Wrong continued indentation.
              ((p < 10) or not any(c in str(p) for c in disallowedChars))])
              ^   | (bad-continuation)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "nStr" (invalid-name)
C: 15, 8: Invalid variable name "nextString" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "disallowedChars" (invalid-name)
C: 35, 4: Invalid variable name "circularCount" (invalid-name)
C: 39, 8: Invalid variable name "circularList" (invalid-name)
C: 42, 8: Invalid variable name "allFound" (invalid-name)
C: 48,16: Invalid variable name "allFound" (invalid-name)
C: 51,12: Invalid variable name "circularCount" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sievedPrimes imported from utils.numbers (unused-import)
W:  5, 0: Unused fact imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'fact' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:5:1: F401 'sievedPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge035\challenge035.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:32:20: E712 comparison to True should be 'if cond is True:' or 'if cond:'
D:\Development\pemjh\pemjh\challenge035\challenge035.py:33:15: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge035\challenge035.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge035\challenge035.py:58:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge036/challenge036.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getBinaryString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "binStr" (invalid-name)
C:  5, 8: Invalid variable name "binStr" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 18, 8: Invalid variable name "decStr" (invalid-name)
C: 21,12: Invalid variable name "binStr" (invalid-name)
W: 11, 4: Unused variable 'limit' (unused-variable)
W: 14, 4: Unused variable 'binary' (unused-variable)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W: 29, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge036\challenge036.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge036\challenge036.py:11:5: F841 local variable 'limit' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:14:5: F841 local variable 'binary' is assigned to but never used
D:\Development\pemjh\pemjh\challenge036\challenge036.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge037/challenge037.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid function name "isTruncPrime" (invalid-name)
C:  7, 0: Invalid argument name "n" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 12,23: More than one statement on a single line (multiple-statements)
C: 13,45: More than one statement on a single line (multiple-statements)
C: 18,51: More than one statement on a single line (multiple-statements)
C: 23, 0: Missing function docstring (missing-docstring)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge037\challenge037.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:12:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:13:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:18:50: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge037\challenge037.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge037\challenge037.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge038/challenge038.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "isPandigital" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "m" (invalid-name)
C: 12,11: Invalid variable name "l" (invalid-name)
C: 12,14: Invalid variable name "u" (invalid-name)
C: 13,12: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge038\challenge038.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge038\challenge038.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge038\challenge038.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge039/challenge039.py _________________
W: 18, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
W: 19, 0: Bad indentation. Found 11 spaces, expected 12 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numPerimeters" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "a" (invalid-name)
C: 16, 8: Invalid variable name "bLimit" (invalid-name)
C: 17,12: Invalid variable name "b" (invalid-name)
C: 18,11: Invalid variable name "c" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "highestVal" (invalid-name)
C: 30, 8: Invalid variable name "iCount" (invalid-name)
C: 33,12: Invalid variable name "highestVal" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
W: 39, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge039\challenge039.py:18:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:19:12: E111 indentation is not a multiple of four
D:\Development\pemjh\pemjh\challenge039\challenge039.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge039\challenge039.py:39:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge040/challenge040.py _________________
C: 11, 0: No space allowed before bracket
        total *= int (str(currentValue)[index - currentN - 1])
                     ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "currentN" (invalid-name)
C:  5, 4: Invalid variable name "currentValue" (invalid-name)
C:  9,12: Invalid variable name "currentValue" (invalid-name)
C: 10,12: Invalid variable name "currentN" (invalid-name)
C: 15, 0: Invalid constant name "answer" (invalid-name)
W: 18, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge040\challenge040.py:11:21: E211 whitespace before '('
D:\Development\pemjh\pemjh\challenge040\challenge040.py:18:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge041/challenge041.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
F:  6, 0: Unable to import 'utils.strings' (import-error)
C:  9, 0: Missing function docstring (missing-docstring)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 15,36: More than one statement on a single line (multiple-statements)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge041\challenge041.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge041\challenge041.py:15:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge041\challenge041.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge041\challenge041.py:22:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge042/challenge042.py _________________
C: 35, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "scoreWord" (invalid-name)
C:  4, 0: Invalid argument name "w" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "x" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 12,62: Invalid variable name "f" (invalid-name)
C: 23, 8: Invalid variable name "nTriangleWords" (invalid-name)
C: 30,16: Invalid variable name "nTriangleWords" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
W: 41, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge042\challenge042.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge042\challenge042.py:35:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge042\challenge042.py:41:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge043/challenge043.py _________________
C:  8, 0: Trailing whitespace (trailing-whitespace)
W: 19, 0: Bad indentation. Found 12 spaces, expected 8 (bad-indentation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.strings' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge043\challenge043.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge043\challenge043.py:8:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge043\challenge043.py:10:49: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:11:47: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:12:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:13:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:14:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:15:44: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:16:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:17:45: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge043\challenge043.py:18:19: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge043\challenge043.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge044/challenge044.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "isPent" (invalid-name)
C:  6, 0: Invalid argument name "p" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "n" (invalid-name)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "pk" (invalid-name)
C: 19, 8: Invalid variable name "performedOneStep" (invalid-name)
C: 20,12: Invalid variable name "pj" (invalid-name)
C: 21,12: Invalid variable name "diffPkPj" (invalid-name)
C: 22,45: More than one statement on a single line (multiple-statements)
C: 25,12: Invalid variable name "performedOneStep" (invalid-name)
C: 27,33: More than one statement on a single line (multiple-statements)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge044\challenge044.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge044\challenge044.py:22:44: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:27:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge044\challenge044.py:28:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge044\challenge044.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge045/challenge045.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
W:  4, 0: Redefining built-in 'hex' (redefined-builtin)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "pentAndHex" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "p" (invalid-name)
C: 10, 4: Invalid variable name "h" (invalid-name)
C: 12, 8: Invalid variable name "pVal" (invalid-name)
C: 13, 8: Invalid variable name "hVal" (invalid-name)
C: 19,12: Invalid variable name "p" (invalid-name)
C: 21,12: Invalid variable name "h" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 26, 8: Redefining built-in 'next' (redefined-builtin)
C: 31, 0: Invalid constant name "answer" (invalid-name)
W: 34, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge045\challenge045.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge045\challenge045.py:34:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge046/challenge046.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "hasCriteria" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "dSq" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "n" (invalid-name)
C: 25, 8: Invalid variable name "n" (invalid-name)
C: 26,36: More than one statement on a single line (multiple-statements)
C: 26,36: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge046\challenge046.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:15:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge046\challenge046.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge046\challenge046.py:26:35: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge046\challenge046.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge047/challenge047.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "numPrimeFactors" (invalid-name)
C:  8, 0: Invalid argument name "nPrimes" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "n" (invalid-name)
C: 11, 8: Invalid variable name "pf" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Invalid function name "hasNumPrimes" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 20,30: More than one statement on a single line (multiple-statements)
C: 24, 0: Missing function docstring (missing-docstring)
W: 30, 4: Redefining name 'count' from outer scope (line 1) (redefined-outer-name)
C: 31, 8: Invalid variable name "p" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused count imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge047\challenge047.py:1:1: F401 'count' imported but unused
D:\Development\pemjh\pemjh\challenge047\challenge047.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:14:15: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:20:29: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge047\challenge047.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:27:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:30:5: F811 redefinition of unused 'count' from line 1
D:\Development\pemjh\pemjh\challenge047\challenge047.py:46:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge047\challenge047.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge048/challenge048.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid constant name "answer" (invalid-name)
W:  8, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge048\challenge048.py:8:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge049/challenge049.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 18, 4: Invalid variable name "permutationPrimes" (invalid-name)
C: 21,12: Invalid variable name "p1" (invalid-name)
C: 22,16: Invalid variable name "p2" (invalid-name)
C: 24,16: Invalid variable name "p3" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge049\challenge049.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge049\challenge049.py:12:29: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge049\challenge049.py:18:80: E501 line too long (94 > 79 characters)
D:\Development\pemjh\pemjh\challenge049\challenge049.py:29:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge049\challenge049.py:31:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge050/challenge050.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
W: 13, 4: Redefining name 'answer' from outer scope (line 26) (redefined-outer-name)
C:  9, 4: Invalid variable name "knownPrimes" (invalid-name)
C: 11, 4: Invalid variable name "nPrimes" (invalid-name)
C: 18,31: More than one statement on a single line (multiple-statements)
C: 26, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge050\challenge050.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge050\challenge050.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge050\challenge050.py:18:30: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge050\challenge050.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge050\challenge050.py:29:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge051/challenge051.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "substitutePrimes" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid function name "has3SameDigits" (invalid-name)
C: 24, 0: Invalid argument name "n" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "w" (invalid-name)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
C: 39,12: Invalid variable name "w" (invalid-name)
C: 41,16: Invalid variable name "nPrimes" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge051\challenge051.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge051\challenge051.py:29:17: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge051\challenge051.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge052/challenge052.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getSortedString" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "x" (invalid-name)
C:  9, 8: Invalid variable name "x" (invalid-name)
C: 10, 8: Invalid variable name "xStr" (invalid-name)
C: 15,12: Invalid variable name "ix" (invalid-name)
C: 16,12: Invalid variable name "ixStr" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge052\challenge052.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge052\challenge052.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:24:16: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge052\challenge052.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge053/challenge053.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge053\challenge053.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge053\challenge053.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge054/challenge054.py _________________
C:122, 0: Trailing whitespace (trailing-whitespace)
C:131, 0: Trailing whitespace (trailing-whitespace)
C:133, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getDuplicateCounts" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "valCounts" (invalid-name)
C: 14, 0: Invalid function name "isStraight" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid function name "isFlush" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid function name "scoreHand" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 52, 8: Invalid variable name "c1" (invalid-name)
C: 52,12: Invalid variable name "c2" (invalid-name)
C: 53, 8: Invalid variable name "v1" (invalid-name)
C: 53,12: Invalid variable name "v2" (invalid-name)
R: 26, 0: Too many return statements (11/6) (too-many-return-statements)
R: 26, 0: Too many branches (15/12) (too-many-branches)
C: 96, 0: Invalid function name "compareHands" (invalid-name)
C: 96, 0: Invalid argument name "handOne" (invalid-name)
C: 96, 0: Invalid argument name "handTwo" (invalid-name)
C: 96, 0: Missing function docstring (missing-docstring)
C:100, 4: Invalid variable name "handOneScore" (invalid-name)
C:100,18: Invalid variable name "handTwoScore" (invalid-name)
C:106,12: Invalid variable name "c1" (invalid-name)
C:106,16: Invalid variable name "c2" (invalid-name)
C:114, 0: Missing function docstring (missing-docstring)
C:115, 4: Invalid variable name "faceConvert" (invalid-name)
C:118, 4: Invalid variable name "nHandOneWins" (invalid-name)
C:119,62: Invalid variable name "f" (invalid-name)
C:120,12: Invalid variable name "l" (invalid-name)
C:129,16: Invalid variable name "nHandOneWins" (invalid-name)
C:133, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge054\challenge054.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:7:21: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge054\challenge054.py:12:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:96:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge054\challenge054.py:106:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:115:64: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:24: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge054\challenge054.py:116:79: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge054\challenge054.py:121:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge054\challenge054.py:122:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:131:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge054\challenge054.py:133:13: W291 trailing whitespace

_________________ [pylint] pemjh/challenge055/challenge055.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "becomesPalindrome" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "workingN" (invalid-name)
C:  6, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 23, 0: Invalid constant name "answer" (invalid-name)
W: 26, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge055\challenge055.py:2:16: W604 backticks are deprecated, use 'repr()'
D:\Development\pemjh\pemjh\challenge055\challenge055.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge055\challenge055.py:26:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge056/challenge056.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "a" (invalid-name)
C:  4,12: Invalid variable name "b" (invalid-name)
C: 13, 0: Invalid constant name "answer" (invalid-name)
W: 16, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge056\challenge056.py:16:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge057/challenge057.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTopHeavy" (invalid-name)
C:  5, 8: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  8,15: Invalid variable name "d" (invalid-name)
C: 10, 8: Invalid variable name "n" (invalid-name)
C: 10,11: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nTopHeavy" (invalid-name)
W:  7,12: Unused variable 'i' (unused-variable)
C: 17, 0: Invalid constant name "answer" (invalid-name)
W: 20, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge057\challenge057.py:20:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge058/challenge058.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nPrimes" (invalid-name)
C: 13, 4: Invalid variable name "primeChecker" (invalid-name)
C: 22,16: Invalid variable name "nPrimes" (invalid-name)
W:  9, 4: Unused variable 'total' (unused-variable)
W: 18,12: Unused variable 'j' (unused-variable)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused isPrime imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge058\challenge058.py:4:1: F401 'isPrime' imported but unused
D:\Development\pemjh\pemjh\challenge058\challenge058.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge058\challenge058.py:9:5: F841 local variable 'total' is assigned to but never used
D:\Development\pemjh\pemjh\challenge058\challenge058.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge058\challenge058.py:36:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge059/challenge059.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 27,64: Invalid variable name "f" (invalid-name)
C: 29,12: Invalid variable name "l" (invalid-name)
W: 48, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge059\challenge059.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge059\challenge059.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge059\challenge059.py:48:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge060/challenge060.py _________________
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 64, 0: Line too long (118/100) (line-too-long)
C: 69, 0: Trailing whitespace (trailing-whitespace)
C: 85, 0: Line too long (141/100) (line-too-long)
C: 94, 0: Trailing whitespace (trailing-whitespace)
C: 95, 0: Trailing whitespace (trailing-whitespace)
C: 97, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Trailing whitespace (trailing-whitespace)
C: 99, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Invalid constant name "primeSet" (invalid-name)
C:  8, 0: Invalid constant name "maxPrime" (invalid-name)
C: 10, 0: Invalid function name "getNumLength" (invalid-name)
C: 10, 0: Invalid argument name "n" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 14, 8: Invalid variable name "l" (invalid-name)
C: 17, 0: Invalid argument name "m" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "isConcatPrime" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "newFirst" (invalid-name)
C: 25, 4: Invalid variable name "newLast" (invalid-name)
C: 29, 0: Invalid function name "getPrimePairs" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "nPrimes" (invalid-name)
C: 33, 8: Invalid variable name "m" (invalid-name)
C: 34, 8: Invalid variable name "p" (invalid-name)
C: 38,12: Invalid variable name "n" (invalid-name)
C: 39,12: Invalid variable name "q" (invalid-name)
C: 47, 0: Invalid function name "nextDigits" (invalid-name)
C: 47, 0: Invalid argument name "nToFind" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "currentSum" (invalid-name)
C: 49, 4: Invalid variable name "currentSolution" (invalid-name)
C: 50, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 61,16: Invalid variable name "foundSolution" (invalid-name)
C: 64,16: Invalid variable name "foundSolution" (invalid-name)
C: 67,16: Invalid variable name "currentSolution" (invalid-name)
C: 68,16: Invalid variable name "currentSolutionSum" (invalid-name)
C: 71, 0: Invalid function name "nextDigitsDict" (invalid-name)
C: 71, 0: Invalid argument name "nToFind" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 72, 4: Invalid variable name "currentSum" (invalid-name)
C: 73, 4: Invalid variable name "currentSolution" (invalid-name)
C: 74, 4: Invalid variable name "currentSolutionSum" (invalid-name)
C: 77, 8: Invalid variable name "p" (invalid-name)
C: 83,12: Invalid variable name "foundSolution" (invalid-name)
C: 86,12: Invalid variable name "newPotential" (invalid-name)
C: 87,12: Invalid variable name "foundSolution" (invalid-name)
C: 92,12: Invalid variable name "currentSolution" (invalid-name)
C: 93,12: Invalid variable name "currentSolutionSum" (invalid-name)
C: 98, 0: Missing function docstring (missing-docstring)
W:109, 4: Redefining name 'answer' from outer scope (line 116) (redefined-outer-name)
C:116, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge060\challenge060.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:21:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:24:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:56:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:64:80: E501 line too long (118 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:69:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:80:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge060\challenge060.py:85:80: E501 line too long (141 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:94:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:95:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:96:5: E303 too many blank lines (2)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:97:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge060\challenge060.py:98:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge060\challenge060.py:99:106: W291 trailing whitespace

_________________ [pylint] pemjh/challenge061/challenge061.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "hasDuplicates" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid function name "eachInList" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "l" (invalid-name)
C: 13, 8: Invalid variable name "n" (invalid-name)
C: 17,12: Invalid variable name "newNums" (invalid-name)
C: 18,12: Invalid variable name "newLists" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
W: 43, 4: Redefining built-in 'hex' (redefined-builtin)
W: 51, 4: Redefining built-in 'oct' (redefined-builtin)
W: 55, 4: Redefining built-in 'all' (redefined-builtin)
R: 24, 0: Too many local variables (27/15) (too-many-locals)
C: 28, 4: Invalid variable name "allLists" (invalid-name)
C: 35, 4: Invalid variable name "sq" (invalid-name)
C: 56, 4: Invalid variable name "d" (invalid-name)
C: 57, 8: Invalid variable name "n" (invalid-name)
C: 64, 8: Invalid variable name "n" (invalid-name)
C: 70,16: Invalid variable name "l" (invalid-name)
C: 76, 8: Invalid variable name "n1" (invalid-name)
C: 79,12: Invalid variable name "n2" (invalid-name)
C: 82,16: Invalid variable name "n3" (invalid-name)
C: 85,20: Invalid variable name "n4" (invalid-name)
C: 88,24: Invalid variable name "n5" (invalid-name)
C: 91,28: Invalid variable name "n6" (invalid-name)
C: 94,32: Invalid variable name "n7" (invalid-name)
R: 24, 0: Too many branches (17/12) (too-many-branches)
C:101, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge061\challenge061.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge061\challenge061.py:67:13: E713 test for membership should be 'not in'

_________________ [pylint] pemjh/challenge062/challenge062.py _________________
C: 28, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "n" (invalid-name)
C:  8, 8: Invalid variable name "potentialAnswer" (invalid-name)
C: 19,20: Invalid variable name "nCubes" (invalid-name)
C: 21,12: Invalid variable name "nCubes" (invalid-name)
C: 29, 8: Invalid variable name "n" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge062\challenge062.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge062\challenge062.py:18:17: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge062\challenge062.py:28:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge063/challenge063.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14,26: More than one statement on a single line (multiple-statements)
C: 20,29: More than one statement on a single line (multiple-statements)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W: 27, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge063\challenge063.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge063\challenge063.py:14:25: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:20:28: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge063\challenge063.py:27:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge064/challenge064.py _________________
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 31, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getPeriodLength" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "pathGen" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
C: 26, 4: Invalid variable name "nOdd" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 32,12: Invalid variable name "nOdd" (invalid-name)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge064\challenge064.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge064\challenge064.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:53: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge064\challenge064.py:29:54: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge065/challenge065.py _________________
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "nextDen" (invalid-name)
C: 34, 0: Invalid constant name "answer" (invalid-name)
W:  4, 0: Unused divisors imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge065\challenge065.py:4:1: F401 'divisors' imported but unused
D:\Development\pemjh\pemjh\challenge065\challenge065.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge065\challenge065.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge066/challenge066.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "diophantineX" (invalid-name)
C:  8, 0: Invalid argument name "d" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "x" (invalid-name)
C: 10,11: Invalid variable name "y" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge066\challenge066.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge066\challenge066.py:17:80: E501 line too long (87 > 79 characters)

_________________ [pylint] pemjh/challenge067/challenge067.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  9, 0: Unable to import 'utils.numbers' (import-error)
C: 11, 0: Missing function docstring (missing-docstring)
W: 14,65: Redefining built-in 'file' (redefined-builtin)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge067\challenge067.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge067\challenge067.py:24:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge068/challenge068.py _________________
C:  6, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getPairs" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "getSpokes" (invalid-name)
C:  7, 0: Invalid argument name "startIndex" (invalid-name)
C:  7, 0: Invalid argument name "nSpokes" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 18,16: Invalid variable name "nextSpokes" (invalid-name)
C: 19,16: Invalid variable name "y" (invalid-name)
C: 23, 0: Missing function docstring (missing-docstring)
W: 54,20: Unused variable 'move' (unused-variable)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge068\challenge068.py:6:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge068\challenge068.py:40:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge068\challenge068.py:44:80: E501 line too long (84 > 79 characters)

_________________ [pylint] pemjh/challenge069/challenge069.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C:  8, 4: Invalid variable name "sp" (invalid-name)
C: 11, 4: Invalid variable name "nPhi" (invalid-name)
C: 12,11: Invalid variable name "n" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge069\challenge069.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge070/challenge070.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "isPermutation" (invalid-name)
C:  8, 0: Invalid argument name "a" (invalid-name)
C:  8, 0: Invalid argument name "b" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "n" (invalid-name)
C: 17,11: Invalid variable name "p" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
W:  6, 0: Unused import string (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge070\challenge070.py:6:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge070\challenge070.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge070\challenge070.py:14:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge071/challenge071.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "targetNum" (invalid-name)
C:  5, 4: Invalid variable name "targetDen" (invalid-name)
C:  8, 4: Invalid variable name "bestNum" (invalid-name)
C:  9, 4: Invalid variable name "bestDen" (invalid-name)
C: 13, 8: Invalid variable name "highNum" (invalid-name)
C: 14, 8: Invalid variable name "lowNum" (invalid-name)
C: 18,55: More than one statement on a single line (multiple-statements)
C: 20,12: Invalid variable name "leftSide" (invalid-name)
C: 21,12: Invalid variable name "rightSide" (invalid-name)
C: 23,16: Invalid variable name "bestNum" (invalid-name)
C: 23,25: Invalid variable name "bestDen" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge071\challenge071.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge071\challenge071.py:18:54: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge072/challenge072.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  5, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge072\challenge072.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge073/challenge073.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  6, 0: Unable to import 'utils.numbers' (import-error)
C:  8, 0: Invalid function name "shareDivisors" (invalid-name)
C:  8, 0: Invalid argument name "n1" (invalid-name)
C:  8, 0: Invalid argument name "n2" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 8: Invalid variable name "d" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "upperNum" (invalid-name)
C: 19, 4: Invalid variable name "upperDen" (invalid-name)
C: 20, 4: Invalid variable name "lowerNum" (invalid-name)
C: 21, 4: Invalid variable name "lowerDen" (invalid-name)
C: 25, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 26, 8: Invalid variable name "lowerLimit" (invalid-name)
C: 28, 8: Invalid variable name "upperLimit" (invalid-name)
C: 29, 8: Invalid variable name "upperLimit" (invalid-name)
C: 31, 8: Invalid variable name "rangeLimits" (invalid-name)
W: 31, 8: Unused variable 'rangeLimits' (unused-variable)
C: 39, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge073\challenge073.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge073\challenge073.py:26:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:27:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:29:69: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge073\challenge073.py:30:30: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge073\challenge073.py:31:9: F841 local variable 'rangeLimits' is assigned to but never used

_________________ [pylint] pemjh/challenge074/challenge074.py _________________
C:  2, 0: Line too long (109/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "factSum" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Invalid function name "chainSize" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "w" (invalid-name)
C:  8, 4: Invalid variable name "firstW" (invalid-name)
C:  9, 4: Invalid variable name "routeLen" (invalid-name)
C: 17,12: Invalid variable name "routeLen" (invalid-name)
C: 19,12: Invalid variable name "w" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 27, 4: Unused variable 'target' (unused-variable)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge074\challenge074.py:2:80: E501 line too long (109 > 79 characters)
D:\Development\pemjh\pemjh\challenge074\challenge074.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:10:11: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge074\challenge074.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge074\challenge074.py:27:5: F841 local variable 'target' is assigned to but never used

_________________ [pylint] pemjh/challenge075/challenge075.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "l" (invalid-name)
C:  8,15: Invalid variable name "a" (invalid-name)
C:  8,18: Invalid variable name "b" (invalid-name)
C:  8,21: Invalid variable name "c" (invalid-name)
C: 21, 4: Invalid variable name "l" (invalid-name)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge075\challenge075.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge075\challenge075.py:8:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge075\challenge075.py:9:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge076/challenge076.py _________________
C: 29, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numBreakDowns" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  9, 8: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nBreakDowns" (invalid-name)
C: 12,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 14,12: Invalid variable name "nBreakDowns" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge076\challenge076.py:2:13: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:3:20: W601 .has_key() is deprecated, use 'in'
D:\Development\pemjh\pemjh\challenge076\challenge076.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge076\challenge076.py:29:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge077/challenge077.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "pc" (invalid-name)
C: 17,12: Invalid variable name "a" (invalid-name)
C: 18,12: Invalid variable name "b" (invalid-name)
C: 21,16: Invalid variable name "abSums" (invalid-name)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge077\challenge077.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge077\challenge077.py:21:80: E501 line too long (88 > 79 characters)

_________________ [pylint] pemjh/challenge078/challenge078.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
W:  6, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W:  7, 0: Found indentation with tabs instead of spaces (mixed-indentation)
W: 15, 0: Found indentation with tabs instead of spaces (mixed-indentation)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "n" (invalid-name)
C:  3, 4: Invalid variable name "p" (invalid-name)
C:  6, 7: Invalid variable name "s" (invalid-name)
C: 10,16: Invalid variable name "s" (invalid-name)
C: 13,16: Invalid variable name "s" (invalid-name)
C: 17, 8: Invalid variable name "m" (invalid-name)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge078\challenge078.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:6:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:7:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:8:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:15:1: W191 indentation contains tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: E101 indentation contains mixed spaces and tabs
D:\Development\pemjh\pemjh\challenge078\challenge078.py:16:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge079/challenge079.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid constant name "answer" (invalid-name)
W:  2, 0: Unused import string (unused-import)
W: 14, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge079\challenge079.py:2:1: F401 'string' imported but unused
D:\Development\pemjh\pemjh\challenge079\challenge079.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge079\challenge079.py:7:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge079\challenge079.py:14:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge080/challenge080.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "buildRoot" (invalid-name)
C:  3, 0: Invalid argument name "sq" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W: 14, 4: Redefining name 'answer' from outer scope (line 36) (redefined-outer-name)
W: 18, 8: Redefining built-in 'next' (redefined-builtin)
C:  5, 4: Invalid function name "getNextNum" (invalid-name)
C:  5, 4: Missing function docstring (missing-docstring)
W:  5,19: Unused argument 'target' (unused-argument)
C: 13, 4: Invalid variable name "prevNum" (invalid-name)
C: 24, 8: Invalid variable name "prevNum" (invalid-name)
W: 16, 8: Unused variable 'i' (unused-variable)
C: 28, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge080\challenge080.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:16:24: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge080\challenge080.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge080\challenge080.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge081/challenge081.py _________________
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "addRows" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "r1" (invalid-name)
C:  7, 8: Invalid variable name "r2" (invalid-name)
C: 10,12: Invalid variable name "i1" (invalid-name)
C: 11,12: Invalid variable name "i2" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 21,63: Invalid variable name "f" (invalid-name)
C: 22, 8: Invalid variable name "tr" (invalid-name)
C: 26,12: Invalid variable name "n" (invalid-name)
C: 26,15: Invalid variable name "l" (invalid-name)
W: 28,26: Using possibly undefined loop variable 'i' (undefined-loop-variable)
C: 39, 4: Invalid variable name "tr" (invalid-name)
C: 43, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge081\challenge081.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge081\challenge081.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge081\challenge081.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge082/challenge082.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Invalid function name "combineColumns" (invalid-name)
C:  5, 0: Invalid argument name "c1" (invalid-name)
C:  5, 0: Invalid argument name "c2" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "downRow" (invalid-name)
C: 11, 8: Invalid variable name "v1" (invalid-name)
C: 11,12: Invalid variable name "v2" (invalid-name)
C: 23, 4: Invalid variable name "newRow" (invalid-name)
C: 26, 8: Invalid variable name "v1" (invalid-name)
C: 26,12: Invalid variable name "v2" (invalid-name)
C: 39, 0: Missing function docstring (missing-docstring)
C: 42,23: Invalid variable name "f" (invalid-name)
W: 44,16: Used builtin function 'map' (bad-builtin)
W: 48,26: Lambda may not be necessary (unnecessary-lambda)
C: 50, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused izip imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge082\challenge082.py:3:1: F401 'izip' imported but unused
D:\Development\pemjh\pemjh\challenge082\challenge082.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge082\challenge082.py:13:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:24:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge082\challenge082.py:28:21: E711 comparison to None should be 'if cond is not None:'
D:\Development\pemjh\pemjh\challenge082\challenge082.py:39:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge083/challenge083.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getGrid" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6,63: Invalid variable name "f" (invalid-name)
C:  9,12: Invalid variable name "nextLine" (invalid-name)
C: 16, 0: Invalid function name "compareToProcess" (invalid-name)
C: 16, 0: Invalid argument name "m" (invalid-name)
C: 16, 0: Invalid argument name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 27, 0: Missing function docstring (missing-docstring)
W: 35,11: Used builtin function 'map' (bad-builtin)
W: 35,11: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 35,27: Used builtin function 'map' (bad-builtin)
W: 35,27: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
C: 38, 4: Invalid variable name "toProcess" (invalid-name)
C: 45, 8: Invalid variable name "x" (invalid-name)
C: 45,11: Invalid variable name "y" (invalid-name)
C: 55,12: Invalid variable name "nx" (invalid-name)
C: 55,16: Invalid variable name "ny" (invalid-name)
C: 56,12: Invalid variable name "newSquare" (invalid-name)
C: 59,12: Invalid variable name "newLength" (invalid-name)
W: 40, 4: Unused variable 'processed' (unused-variable)
C: 77, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge083\challenge083.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge083\challenge083.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge083\challenge083.py:35:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge083\challenge083.py:40:5: F841 local variable 'processed' is assigned to but never used
D:\Development\pemjh\pemjh\challenge083\challenge083.py:51:53: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:52:55: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:27: E127 continuation line over-indented for visual indent
D:\Development\pemjh\pemjh\challenge083\challenge083.py:53:43: E712 comparison to False should be 'if cond is False:' or 'if not cond:'

_________________ [pylint] pemjh/challenge084/challenge084.py _________________
C:  8, 0: No space allowed around keyword argument assignment
def chanceCardMove(current, prev = [0]):
                                 ^ (bad-whitespace)
C: 52, 0: No space allowed around keyword argument assignment
def communityChestCardMove(current, prev = [0]):
                                         ^ (bad-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C: 77, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:100, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "rollDice" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  8, 0: Dangerous default value [] as argument (dangerous-default-value)
C:  8, 0: Invalid function name "chanceCardMove" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
R:  8, 0: Too many return statements (13/6) (too-many-return-statements)
R:  8, 0: Too many branches (14/12) (too-many-branches)
W: 52, 0: Dangerous default value [] as argument (dangerous-default-value)
C: 52, 0: Invalid function name "communityChestCardMove" (invalid-name)
C: 52, 0: Missing function docstring (missing-docstring)
C: 68, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "doubleCount" (invalid-name)
C: 85,12: Invalid variable name "doubleCount" (invalid-name)
C: 87,12: Invalid variable name "doubleCount" (invalid-name)
C: 94,12: Invalid variable name "doubleCount" (invalid-name)
C:111, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge084\challenge084.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:8:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:41: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:52:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge084\challenge084.py:68:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge084\challenge084.py:75:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge084\challenge084.py:93:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge084\challenge084.py:100:46: W291 trailing whitespace

_________________ [pylint] pemjh/challenge085/challenge085.py _________________
C: 30, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numRects" (invalid-name)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Invalid argument name "w" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "rh" (invalid-name)
C:  5,12: Invalid variable name "rw" (invalid-name)
C:  6,12: Invalid variable name "numAcross" (invalid-name)
C:  7,12: Invalid variable name "numDown" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 32,16: Invalid variable name "areaRectangles" (invalid-name)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge085\challenge085.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge085\challenge085.py:15:21: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge085\challenge085.py:30:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge085\challenge085.py:40:26: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge086/challenge086.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def isInt(a, msq, sqLib, found = list()):
                               ^ (bad-whitespace)
C:  2, 0: Unnecessary parens after 'return' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value list() (__builtin__.list) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "isInt" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "sqLib" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  1,25: Unused argument 'found' (unused-argument)
C:  4, 0: Invalid function name "getNumPairs" (invalid-name)
C:  4, 0: Invalid argument name "pairSum" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nPairs" (invalid-name)
C:  8, 4: Invalid variable name "a" (invalid-name)
C:  9, 4: Invalid variable name "b" (invalid-name)
C: 11, 8: Invalid variable name "a" (invalid-name)
C: 12, 8: Invalid variable name "b" (invalid-name)
C: 16,12: Invalid variable name "nPairs" (invalid-name)
C: 19, 0: Invalid function name "getStepSize" (invalid-name)
C: 19, 0: Invalid argument name "m" (invalid-name)
C: 19, 0: Invalid argument name "sqLib" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "nStep" (invalid-name)
W: 25, 4: Unreachable code (unreachable)
C: 27, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "sqLimit" (invalid-name)
C: 33, 4: Invalid variable name "m" (invalid-name)
C: 36, 8: Invalid variable name "m" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:1:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge086\challenge086.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge086\challenge086.py:23:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge086\challenge086.py:27:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge087/challenge087.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sqLimit" (invalid-name)
C: 13, 4: Invalid variable name "sqPrimes" (invalid-name)
C: 16, 4: Invalid variable name "cuLimit" (invalid-name)
C: 17, 4: Invalid variable name "cuPrimes" (invalid-name)
C: 20, 4: Invalid variable name "foLimit" (invalid-name)
C: 21, 4: Invalid variable name "foPrimes" (invalid-name)
C: 23, 4: Invalid variable name "nAnswers" (invalid-name)
C: 24, 8: Invalid variable name "s" (invalid-name)
C: 25,12: Invalid variable name "c" (invalid-name)
C: 26,12: Invalid variable name "sc" (invalid-name)
C: 29,16: Invalid variable name "f" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
W:  5, 0: Unused sqrt imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge087\challenge087.py:5:1: F401 'sqrt' imported but unused
D:\Development\pemjh\pemjh\challenge087\challenge087.py:7:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge088/challenge088.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def findPossibleProducts(limit, known = dict()):
                                      ^ (bad-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "findPossibleProducts" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12,20: Invalid variable name "s" (invalid-name)
C: 12,23: Invalid variable name "d" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 25, 8: Invalid variable name "pr" (invalid-name)
C: 25,12: Invalid variable name "s" (invalid-name)
C: 25,15: Invalid variable name "d" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused ceil imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge088\challenge088.py:1:1: F401 'ceil' imported but unused
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:3:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge088\challenge088.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge088\challenge088.py:23:47: W291 trailing whitespace

_________________ [pylint] pemjh/challenge089/challenge089.py _________________
C: 56, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C: 17, 0: Invalid function name "convertChar" (invalid-name)
C: 17, 0: Invalid argument name "c" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
R: 17, 0: Too many return statements (7/6) (too-many-return-statements)
C: 33, 0: Invalid function name "decypherNumeral" (invalid-name)
C: 33, 0: Invalid argument name "s" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "currentTotal" (invalid-name)
C: 38, 8: Invalid variable name "v" (invalid-name)
C: 41,12: Invalid variable name "currentTotal" (invalid-name)
C: 43,12: Invalid variable name "currentTotal" (invalid-name)
C: 46,12: Invalid variable name "currentTotal" (invalid-name)
C: 53, 0: Invalid function name "getNumeral" (invalid-name)
C: 53, 0: Invalid argument name "n" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 61,13: Invalid variable name "c" (invalid-name)
C: 62, 8: Invalid variable name "nDiv" (invalid-name)
C: 67, 0: Invalid function name "getRomanNumeralSaving" (invalid-name)
C: 67, 0: Invalid argument name "s" (invalid-name)
C: 67, 0: Missing function docstring (missing-docstring)
C: 69, 4: Invalid variable name "preLength" (invalid-name)
C: 75, 4: Invalid variable name "newNumeral" (invalid-name)
C: 76, 4: Invalid variable name "newLength" (invalid-name)
C: 81, 0: Missing function docstring (missing-docstring)
C: 83,62: Invalid variable name "f" (invalid-name)
C: 87, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge089\challenge089.py:9:80: E501 line too long (90 > 79 characters)
D:\Development\pemjh\pemjh\challenge089\challenge089.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:56:59: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge089\challenge089.py:67:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge089\challenge089.py:81:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge090/challenge090.py _________________
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 78, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "get6Combs" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "c6" (invalid-name)
C: 10, 8: Invalid variable name "i6" (invalid-name)
C: 15, 8: Invalid variable name "i6" (invalid-name)
C: 20, 0: Invalid function name "fillRemaining" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid function name "validAddition" (invalid-name)
C: 29, 0: Invalid argument name "newFace" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 35, 0: Invalid function name "amendCubesForSquare" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "newCube1" (invalid-name)
C: 56, 8: Invalid variable name "newCube0" (invalid-name)
C: 62, 4: Invalid variable name "newCube0" (invalid-name)
C: 63, 4: Invalid variable name "newCube1" (invalid-name)
C: 71, 0: Invalid function name "buildCubes" (invalid-name)
C: 71, 0: Invalid argument name "squaresLeft" (invalid-name)
C: 71, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nextSquare" (invalid-name)
C: 77, 4: Invalid variable name "suitableCubes" (invalid-name)
C:109,16: Invalid variable name "c0" (invalid-name)
C:110,20: Invalid variable name "c1" (invalid-name)
R: 71, 0: Too many branches (13/12) (too-many-branches)
C:116, 0: Missing function docstring (missing-docstring)
C:117, 4: Invalid variable name "squareNumbers" (invalid-name)
C:119, 4: Invalid variable name "possibleNumbers" (invalid-name)
C:125, 8: Invalid variable name "c" (invalid-name)
W:119, 4: Unused variable 'possibleNumbers' (unused-variable)
W:125, 8: Unused variable 'c' (unused-variable)
C:129, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge090\challenge090.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:13:10: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge090\challenge090.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:71:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:72:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge090\challenge090.py:78:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge090\challenge090.py:116:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge090\challenge090.py:119:5: F841 local variable 'possibleNumbers' is assigned to but never used

_________________ [pylint] pemjh/challenge091/challenge091.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "bruteForce" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nTriangles" (invalid-name)
C:  5, 8: Invalid variable name "x1" (invalid-name)
C:  6,12: Invalid variable name "y1" (invalid-name)
C:  9,16: Invalid variable name "nTriangles" (invalid-name)
C: 12,16: Invalid variable name "nTriangles" (invalid-name)
C: 15,20: Invalid variable name "x2" (invalid-name)
C: 16,24: Invalid variable name "y2" (invalid-name)
C: 29,32: Invalid variable name "nTriangles" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "gridSize" (invalid-name)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge091\challenge091.py:32:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge092/challenge092.py _________________
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 87, 0: Trailing whitespace (trailing-whitespace)
C:112, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Invalid function name "getDigits" (invalid-name)
C:  6, 0: Invalid argument name "n" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "workingN" (invalid-name)
C: 11, 8: Invalid variable name "workingN" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 20, 8: Invalid variable name "workingN" (invalid-name)
C: 29,20: Invalid variable name "d" (invalid-name)
C: 31,16: Invalid variable name "workingN" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "n" (invalid-name)
C: 41, 8: Invalid variable name "workingN" (invalid-name)
C: 45,12: Invalid variable name "workingN" (invalid-name)
C: 46,19: Invalid variable name "c" (invalid-name)
C: 52,12: Invalid variable name "workingN" (invalid-name)
W: 42, 8: Unused variable 'route' (unused-variable)
C: 58, 0: Invalid function name "buildNumber" (invalid-name)
C: 58, 0: Missing function docstring (missing-docstring)
C: 61, 0: Missing function docstring (missing-docstring)
C: 73, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "prevI" (invalid-name)
C: 75, 4: Invalid variable name "nI" (invalid-name)
C: 80,12: Invalid variable name "nI" (invalid-name)
C: 83,12: Invalid variable name "prevI" (invalid-name)
C: 84,12: Invalid variable name "nI" (invalid-name)
C: 90, 0: Invalid function name "squareVal" (invalid-name)
C: 90, 0: Missing function docstring (missing-docstring)
C: 91, 4: Invalid variable name "n" (invalid-name)
C: 96, 8: Invalid variable name "n" (invalid-name)
C:100, 0: Missing function docstring (missing-docstring)
C:101, 4: Invalid variable name "n" (invalid-name)
C:108,12: Invalid variable name "n" (invalid-name)
C:110, 0: Missing function docstring (missing-docstring)
C:111, 4: Invalid variable name "nDigits" (invalid-name)
C:120, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge092\challenge092.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge092\challenge092.py:29:58: E262 inline comment should start with '# '
D:\Development\pemjh\pemjh\challenge092\challenge092.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:42:9: F841 local variable 'route' is assigned to but never used
D:\Development\pemjh\pemjh\challenge092\challenge092.py:46:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge092\challenge092.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:61:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:73:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:87:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:90:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:100:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:110:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge092\challenge092.py:112:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge092\challenge092.py:123:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge093/challenge093.py _________________
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 96, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nLeft" (invalid-name)
C: 12, 0: Invalid argument name "a" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "op" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 26, 0: Invalid argument name "l" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "v" (invalid-name)
C: 34, 0: Invalid function name "equatedNumbers" (invalid-name)
C: 34, 0: Invalid argument name "a" (invalid-name)
C: 34, 0: Invalid argument name "b" (invalid-name)
C: 34, 0: Invalid argument name "c" (invalid-name)
C: 34, 0: Invalid argument name "d" (invalid-name)
C: 34, 0: Missing function docstring (missing-docstring)
W: 40, 8: No exception type(s) specified (bare-except)
C: 39,13: More than one statement on a single line (multiple-statements)
C: 40,16: More than one statement on a single line (multiple-statements)
W: 44, 8: No exception type(s) specified (bare-except)
C: 43,13: More than one statement on a single line (multiple-statements)
C: 44,16: More than one statement on a single line (multiple-statements)
W: 48, 8: No exception type(s) specified (bare-except)
C: 47,13: More than one statement on a single line (multiple-statements)
C: 48,16: More than one statement on a single line (multiple-statements)
W: 52, 8: No exception type(s) specified (bare-except)
C: 51,13: More than one statement on a single line (multiple-statements)
C: 52,16: More than one statement on a single line (multiple-statements)
W: 56, 8: No exception type(s) specified (bare-except)
C: 55,13: More than one statement on a single line (multiple-statements)
C: 56,16: More than one statement on a single line (multiple-statements)
C: 60, 0: Missing function docstring (missing-docstring)
C: 68, 8: Invalid variable name "a" (invalid-name)
C: 69,12: Invalid variable name "b" (invalid-name)
C: 70,16: Invalid variable name "c" (invalid-name)
C: 71,20: Invalid variable name "d" (invalid-name)
C: 77,28: Invalid variable name "n" (invalid-name)
W: 90,19: Using possibly undefined loop variable 'd' (undefined-loop-variable)
W: 92,15: Using possibly undefined loop variable 'c' (undefined-loop-variable)
W: 94,11: Using possibly undefined loop variable 'b' (undefined-loop-variable)
C: 99, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge093\challenge093.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:34:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge093\challenge093.py:39:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:40:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:43:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:44:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:47:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:48:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:51:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:52:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:55:12: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:56:15: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:60:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge093\challenge093.py:77:80: E501 line too long (91 > 79 characters)
D:\Development\pemjh\pemjh\challenge093\challenge093.py:96:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge094/challenge094.py _________________
C: 11, 0: Exactly one space required after comma
    prev_2 = (4,  0)
               ^ (bad-whitespace)
C: 12, 0: Exactly one space required after comma
    prev_1 = (15,  1)
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "n" (invalid-name)
C:  6, 8: Invalid variable name "n" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
W: 38,12: Redefining built-in 'long' (redefined-builtin)
C: 31, 8: Invalid variable name "c" (invalid-name)
C: 33, 8: Invalid variable name "rt" (invalid-name)
C: 50, 0: Invalid constant name "desc" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge094\challenge094.py:9:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge095/challenge095.py _________________
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 47, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid function name "chainLengths" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 17, 8: Invalid variable name "x" (invalid-name)
C: 38,12: Invalid variable name "lChain" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge095\challenge095.py:2:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:6:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge095\challenge095.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge095\challenge095.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:47:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge095\challenge095.py:50:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge096/challenge096.py _________________
C:104, 0: Trailing whitespace (trailing-whitespace)
C:120, 0: Line too long (150/100) (line-too-long)
C:228, 0: Trailing whitespace (trailing-whitespace)
C:240, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  6, 0: Invalid function name "sortSquareLengths" (invalid-name)
C:  6, 0: Invalid argument name "a" (invalid-name)
C:  6, 0: Invalid argument name "b" (invalid-name)
C:  6, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "la" (invalid-name)
C:  8, 4: Invalid variable name "lb" (invalid-name)
C: 16, 0: Missing class docstring (missing-docstring)
C: 16, 0: Old-style class defined. (old-style-class)
C: 20, 4: Invalid argument name "s" (invalid-name)
W: 23,50: Unused variable 'i' (unused-variable)
C: 36, 4: Invalid method name "__loadData" (invalid-name)
C: 36, 4: Invalid argument name "s" (invalid-name)
C: 36, 4: Missing method docstring (missing-docstring)
C: 40,12: Invalid variable name "r" (invalid-name)
C: 42,16: Invalid variable name "c" (invalid-name)
C: 46, 4: Invalid method name "__getBox" (invalid-name)
C: 46, 4: Invalid argument name "r" (invalid-name)
C: 46, 4: Invalid argument name "c" (invalid-name)
C: 46, 4: Missing method docstring (missing-docstring)
C: 47, 8: Invalid function name "getStartIndex" (invalid-name)
C: 47, 8: Missing function docstring (missing-docstring)
C: 55, 8: Invalid variable name "rowStart" (invalid-name)
C: 57,12: Invalid variable name "columnStart" (invalid-name)
C: 61, 4: Invalid method name "__removeValueFromList" (invalid-name)
C: 61, 4: Invalid argument name "l" (invalid-name)
C: 61, 4: Missing method docstring (missing-docstring)
C: 62, 8: Invalid variable name "nRemoved" (invalid-name)
C: 64,12: Invalid variable name "sq" (invalid-name)
C: 66,16: Invalid variable name "nRemoved" (invalid-name)
R: 61, 4: Method could be a function (no-self-use)
C: 71, 4: Invalid method name "__setValue" (invalid-name)
C: 71, 4: Invalid argument name "r" (invalid-name)
C: 71, 4: Invalid argument name "c" (invalid-name)
C: 71, 4: Missing method docstring (missing-docstring)
C: 85, 8: Invalid variable name "sq" (invalid-name)
C: 96, 4: Invalid method name "__getAllBlocks" (invalid-name)
C: 96, 4: Missing method docstring (missing-docstring)
C:100,12: Invalid variable name "r" (invalid-name)
C:101,16: Invalid variable name "c" (invalid-name)
C:107, 4: Invalid method name "__processCompletedSquares" (invalid-name)
C:107, 4: Missing method docstring (missing-docstring)
C:110,12: Invalid variable name "r" (invalid-name)
C:111,16: Invalid variable name "sq" (invalid-name)
C:117, 4: Invalid method name "__processGroups" (invalid-name)
C:117, 4: Missing method docstring (missing-docstring)
C:124,16: Invalid variable name "sq" (invalid-name)
C:131,24: Invalid variable name "lSq" (invalid-name)
C:137,28: Invalid variable name "nRemoved" (invalid-name)
C:148, 4: Invalid method name "__getLocation" (invalid-name)
C:148, 4: Invalid argument name "sq" (invalid-name)
C:148, 4: Missing method docstring (missing-docstring)
C:150,12: Invalid variable name "r" (invalid-name)
C:151,16: Invalid variable name "c" (invalid-name)
C:157, 4: Invalid method name "__processOnlyInOneSquare" (invalid-name)
C:157, 4: Missing method docstring (missing-docstring)
C:176, 4: Missing method docstring (missing-docstring)
C:178,12: Invalid variable name "sRow" (invalid-name)
C:178,18: Invalid variable name "tRow" (invalid-name)
W:178,30: Access to a protected member __rows of a client class (protected-access)
C:179,16: Invalid variable name "sSquare" (invalid-name)
C:179,25: Invalid variable name "tSquare" (invalid-name)
C:183, 4: Missing method docstring (missing-docstring)
C:184, 8: Invalid variable name "progressMade" (invalid-name)
C:187,12: Invalid variable name "progressMade" (invalid-name)
C:189,12: Invalid variable name "progressMade" (invalid-name)
C:191,12: Invalid variable name "progressMade" (invalid-name)
C:195,12: Invalid variable name "unsolvedSquares" (invalid-name)
C:196,16: Invalid variable name "r" (invalid-name)
C:197,20: Invalid variable name "c" (invalid-name)
C:205,16: Invalid variable name "sq" (invalid-name)
W:211,20: Access to a protected member __setValue of a client class (protected-access)
W:214,24: Access to a protected member __solve of a client class (protected-access)
C:223, 4: Missing method docstring (missing-docstring)
C:224,12: Invalid variable name "r" (invalid-name)
C:225,16: Invalid variable name "sq" (invalid-name)
C:230, 4: Missing method docstring (missing-docstring)
C:231,12: Invalid variable name "r" (invalid-name)
C:232,16: Invalid variable name "sq" (invalid-name)
W:244, 8: Redefining built-in 'repr' (redefined-builtin)
C:245,12: Invalid variable name "r" (invalid-name)
C:247,16: Invalid variable name "sq" (invalid-name)
C:249,16: Invalid variable name "f1" (invalid-name)
C:250,16: Invalid variable name "f2" (invalid-name)
C:256, 0: Missing function docstring (missing-docstring)
W:267,12: Redefining built-in 'input' (redefined-builtin)
C:257,63: Invalid variable name "f" (invalid-name)
C:260, 8: Invalid variable name "nBroken" (invalid-name)
C:273,16: Invalid variable name "nBroken" (invalid-name)
W:260, 8: Unused variable 'nBroken' (unused-variable)
W:263,12: Unused variable 'i' (unused-variable)
W:267,46: Unused variable 'j' (unused-variable)
C:279, 0: Invalid constant name "answer" (invalid-name)
W:  3, 0: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge096\challenge096.py:3:1: F401 'sys' imported but unused
D:\Development\pemjh\pemjh\challenge096\challenge096.py:6:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:27:9: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:76:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:99:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:104:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:109:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:113:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:120:80: E501 line too long (150 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:129:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge096\challenge096.py:228:20: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:240:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge096\challenge096.py:256:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge096\challenge096.py:282:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:292:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge096\challenge096.py:293:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge097/challenge097.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid constant name "answer" (invalid-name)
W:  7, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge097\challenge097.py:7:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge098/challenge098.py _________________
C: 20, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "getMap" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W:  5, 4: Redefining built-in 'map' (redefined-builtin)
C:  6, 8: Invalid variable name "w" (invalid-name)
C:  6,11: Invalid variable name "s" (invalid-name)
C: 15, 0: Invalid function name "uniqueRight" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
W: 15,16: Redefining built-in 'map' (redefined-builtin)
C: 25, 0: Invalid function name "mapWord" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 25,18: Redefining built-in 'map' (redefined-builtin)
C: 27, 8: Invalid variable name "c" (invalid-name)
C: 32, 0: Missing function docstring (missing-docstring)
W: 81,16: Redefining built-in 'map' (redefined-builtin)
R: 32, 0: Too many local variables (19/15) (too-many-locals)
C: 35, 4: Invalid variable name "groupedWords" (invalid-name)
C: 37,62: Invalid variable name "f" (invalid-name)
C: 40,16: Invalid variable name "orderedWord" (invalid-name)
C: 46, 4: Invalid variable name "groupedWords" (invalid-name)
C: 70, 8: Invalid variable name "nWords" (invalid-name)
C: 75,12: Invalid variable name "lWord" (invalid-name)
C: 78,16: Invalid variable name "potentialSquare" (invalid-name)
C: 87,24: Invalid variable name "word2Square" (invalid-name)
C: 95, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge098\challenge098.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:20:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge098\challenge098.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:32:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge098\challenge098.py:46:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:79:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge098\challenge098.py:92:80: E501 line too long (85 > 79 characters)

_________________ [pylint] pemjh/challenge099/challenge099.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5,65: Invalid variable name "f" (invalid-name)
C:  6, 8: Invalid variable name "highestIndex" (invalid-name)
C:  7, 8: Invalid variable name "highestNumber" (invalid-name)
C:  8, 8: Invalid variable name "highestLine" (invalid-name)
C:  9,12: Invalid variable name "nL" (invalid-name)
C:  9,16: Invalid variable name "l" (invalid-name)
C: 10,12: Invalid variable name "n" (invalid-name)
C: 11,12: Invalid variable name "rootedPower" (invalid-name)
C: 13,16: Invalid variable name "highestNumber" (invalid-name)
C: 13,31: Invalid variable name "highestIndex" (invalid-name)
C: 13,45: Invalid variable name "highestLine" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
W: 19, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge099\challenge099.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge099\challenge099.py:19:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge100/challenge100.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "b" (invalid-name)
C:  3, 4: Invalid variable name "n" (invalid-name)
C:  5, 8: Invalid variable name "b" (invalid-name)
C:  5,11: Invalid variable name "n" (invalid-name)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge101/challenge101.py _________________
C:  5, 0: Line too long (123/100) (line-too-long)
C: 27, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "highestPower" (invalid-name)
C: 14, 8: Invalid variable name "workedSequence" (invalid-name)
C: 16,12: Invalid variable name "x" (invalid-name)
C: 17,12: Invalid variable name "y" (invalid-name)
C: 28,16: Invalid variable name "y" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge101\challenge101.py:5:80: E501 line too long (123 > 79 characters)
D:\Development\pemjh\pemjh\challenge101\challenge101.py:27:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge102/challenge102.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C: 52, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "enclosesOrigin" (invalid-name)
C:  4, 0: Invalid argument name "x1" (invalid-name)
C:  4, 0: Invalid argument name "y1" (invalid-name)
C:  4, 0: Invalid argument name "x2" (invalid-name)
C:  4, 0: Invalid argument name "y2" (invalid-name)
C:  4, 0: Invalid argument name "x3" (invalid-name)
C:  4, 0: Invalid argument name "y3" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
R:  4, 0: Too many arguments (6/5) (too-many-arguments)
C: 17,12: Invalid variable name "i1" (invalid-name)
C: 18,12: Invalid variable name "i2" (invalid-name)
C: 21,12: Invalid variable name "i1" (invalid-name)
C: 22,12: Invalid variable name "i2" (invalid-name)
C: 25,12: Invalid variable name "i1" (invalid-name)
C: 26,12: Invalid variable name "i2" (invalid-name)
C: 33, 0: Invalid function name "getYIntercept" (invalid-name)
C: 33, 0: Invalid argument name "x1" (invalid-name)
C: 33, 0: Invalid argument name "y1" (invalid-name)
C: 33, 0: Invalid argument name "x2" (invalid-name)
C: 33, 0: Invalid argument name "y2" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "m" (invalid-name)
C: 38, 4: Invalid variable name "c" (invalid-name)
C: 43, 0: Missing function docstring (missing-docstring)
C: 46, 4: Invalid variable name "nEnclosing" (invalid-name)
C: 47,23: Invalid variable name "f" (invalid-name)
C: 48,12: Invalid variable name "l" (invalid-name)
C: 49,12: Invalid variable name "ax" (invalid-name)
C: 49,16: Invalid variable name "ay" (invalid-name)
C: 49,20: Invalid variable name "bx" (invalid-name)
C: 49,24: Invalid variable name "by" (invalid-name)
C: 49,28: Invalid variable name "cx" (invalid-name)
C: 49,32: Invalid variable name "cy" (invalid-name)
C: 51,16: Invalid variable name "nEnclosing" (invalid-name)
C: 55, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge102\challenge102.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:33:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:43:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge102\challenge102.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:52:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge102\challenge102.py:58:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge103/challenge103.py _________________
C: 41, 0: Trailing whitespace (trailing-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "subSets" (invalid-name)
C:  1, 0: Invalid argument name "l" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 8: Invalid variable name "setA" (invalid-name)
C:  5, 8: Invalid variable name "setB" (invalid-name)
C: 14, 0: Invalid argument name "l" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "B" (invalid-name)
C: 16,11: Invalid variable name "CPart" (invalid-name)
C: 19,16: Invalid variable name "C" (invalid-name)
C: 19,19: Invalid variable name "notUsed" (invalid-name)
C: 23,24: Invalid variable name "wB" (invalid-name)
C: 23,28: Invalid variable name "wC" (invalid-name)
C: 25,24: Invalid variable name "wB" (invalid-name)
C: 25,28: Invalid variable name "wC" (invalid-name)
W: 19,19: Unused variable 'notUsed' (unused-variable)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "midPoint" (invalid-name)
C: 48, 4: Invalid variable name "sumAns" (invalid-name)
C: 49, 8: Invalid variable name "b" (invalid-name)
C: 50, 8: Invalid variable name "newSet" (invalid-name)
C: 54,16: Invalid variable name "sumAns" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge103\challenge103.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge103\challenge103.py:41:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge103\challenge103.py:51:43: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge103\challenge103.py:55:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge104/challenge104.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "myEnumerate" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Invalid function name "fiboTrunc" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "aStart" (invalid-name)
C: 10,12: Invalid variable name "bStart" (invalid-name)
C: 11, 4: Invalid variable name "aEnd" (invalid-name)
C: 11,10: Invalid variable name "bEnd" (invalid-name)
C: 13, 4: Invalid variable name "endTrunc" (invalid-name)
C: 14, 4: Invalid variable name "startTrunc" (invalid-name)
C: 18, 8: Invalid variable name "aStart" (invalid-name)
C: 18,16: Invalid variable name "bStart" (invalid-name)
C: 19, 8: Invalid variable name "aEnd" (invalid-name)
C: 19,14: Invalid variable name "bEnd" (invalid-name)
C: 22, 8: Invalid variable name "aEnd" (invalid-name)
C: 23, 8: Invalid variable name "bEnd" (invalid-name)
C: 26,12: Invalid variable name "aStart" (invalid-name)
C: 27,12: Invalid variable name "bStart" (invalid-name)
C: 29, 8: Invalid variable name "aStartRet" (invalid-name)
C: 31,12: Invalid variable name "aStartRet" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 37, 4: Invalid variable name "lowerLimit" (invalid-name)
C: 38,11: Invalid variable name "f" (invalid-name)
C: 39, 8: Invalid variable name "s" (invalid-name)
C: 40, 8: Invalid variable name "e" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused fibo imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge104\challenge104.py:1:1: F401 'fibo' imported but unused
D:\Development\pemjh\pemjh\challenge104\challenge104.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge104\challenge104.py:37:27: E261 at least two spaces before inline comment

_________________ [pylint] pemjh/challenge105/challenge105.py _________________
C: 61, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "sizedSubsets" (invalid-name)
C:  4, 0: Invalid argument name "l" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "sizeL" (invalid-name)
C: 21, 0: Invalid function name "checkForDuplicateSetSums" (invalid-name)
C: 21, 0: Invalid argument name "l" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 22, 8: Invalid variable name "setSize" (invalid-name)
C: 23, 8: Invalid variable name "sumSub" (invalid-name)
C: 30, 0: Invalid argument name "l" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 35, 4: Invalid variable name "nItems" (invalid-name)
C: 49, 0: Missing function docstring (missing-docstring)
C: 51,61: Invalid variable name "f" (invalid-name)
C: 60, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge105\challenge105.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:30:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:34:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge105\challenge105.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge105\challenge105.py:61:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge105\challenge105.py:63:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge105\challenge105.py:64:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge106/challenge106.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "incrementTrilist" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "rightIndex" (invalid-name)
C: 16, 0: Invalid function name "allSubsets" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17, 4: Invalid variable name "triList" (invalid-name)
C: 28, 0: Invalid argument name "l" (invalid-name)
C: 28, 0: Missing function docstring (missing-docstring)
C: 48, 0: Invalid function name "getRequiredCompares" (invalid-name)
C: 48, 0: Missing function docstring (missing-docstring)
C: 49, 4: Invalid variable name "allS" (invalid-name)
C: 52, 4: Invalid variable name "workingS" (invalid-name)
C: 55, 4: Invalid variable name "workingS" (invalid-name)
C: 58, 4: Invalid variable name "workingS" (invalid-name)
C: 62, 0: Missing function docstring (missing-docstring)
C: 65, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge106\challenge106.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:28:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:48:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:54:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge106\challenge106.py:62:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge106\challenge106.py:70:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge107/challenge107.py _________________
C: 22, 0: Line too long (102/100) (line-too-long)
C: 25, 0: Line too long (139/100) (line-too-long)
C: 25, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C: 44, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  4, 0: Invalid function name "skimNetwork" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "connectedRows" (invalid-name)
C:  7, 4: Invalid variable name "availableConnections" (invalid-name)
C: 22, 8: Invalid variable name "availableConnections" (invalid-name)
C: 30, 4: Invalid variable name "newGrid" (invalid-name)
W: 30,35: Unused variable 'row' (unused-variable)
C: 36, 0: Invalid function name "scoreGrid" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 8: Invalid variable name "r" (invalid-name)
C: 41,12: Invalid variable name "v" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 50,64: Invalid variable name "f" (invalid-name)
C: 56, 4: Invalid variable name "originalScore" (invalid-name)
C: 59, 4: Invalid variable name "newGrid" (invalid-name)
C: 62, 4: Invalid variable name "newScore" (invalid-name)
C: 67, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge107\challenge107.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:7:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:22:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:25:80: E501 line too long (139 > 79 characters)
D:\Development\pemjh\pemjh\challenge107\challenge107.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:44:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge107\challenge107.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge107\challenge107.py:53:80: E501 line too long (94 > 79 characters)

_________________ [pylint] pemjh/challenge108/challenge108.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge108\challenge108.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge108\challenge108.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge108\challenge108.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge109/challenge109.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def getNonDoubleOuts(n, darts, nums, known = dict()):
                                           ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "getNonDoubleOuts" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "nCount" (invalid-name)
C:  7, 8: Invalid variable name "d" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "nCount" (invalid-name)
C: 21, 0: Invalid function name "getDoubleOuts" (invalid-name)
C: 21, 0: Invalid argument name "n" (invalid-name)
C: 21, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "nCount" (invalid-name)
C: 24,14: Invalid variable name "d" (invalid-name)
C: 26,12: Invalid variable name "nCount" (invalid-name)
C: 28,12: Invalid variable name "nCount" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "nCount" (invalid-name)
C: 43, 8: Invalid variable name "nCount" (invalid-name)
C: 47, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge109\challenge109.py:21:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge109\challenge109.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge110/challenge110.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                               ^ (bad-whitespace)
C:  3, 0: No space allowed around keyword argument assignment
def primeIndices(target, indexLimit, primes, primeIndex, limit = 0, known = dict()):
                                                                          ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "primeIndices" (invalid-name)
C:  3, 0: Invalid argument name "indexLimit" (invalid-name)
C:  3, 0: Invalid argument name "primeIndex" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
W:  9, 4: Redefining name 'answer' from outer scope (line 56) (redefined-outer-name)
W: 26,12: Redefining built-in 'next' (redefined-builtin)
R:  3, 0: Too many arguments (6/5) (too-many-arguments)
C: 15, 4: Invalid variable name "newProduct" (invalid-name)
C: 33, 8: Invalid variable name "newProduct" (invalid-name)
C: 45, 0: Missing function docstring (missing-docstring)
C: 47, 4: Invalid variable name "primeLimit" (invalid-name)
C: 56, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:63: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:65: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:74: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:76: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge110\challenge110.py:3:80: E501 line too long (84 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:23:1: E112 expected an indented block
D:\Development\pemjh\pemjh\challenge110\challenge110.py:26:80: E501 line too long (98 > 79 characters)
D:\Development\pemjh\pemjh\challenge110\challenge110.py:45:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge110\challenge110.py:60:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge111/challenge111.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def isPrime(p, pc = PrimeChecker()):
                  ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "isPrime" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "pc" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 0: Invalid function name "buildNums" (invalid-name)
C: 14, 0: Missing function docstring (missing-docstring)
C: 17,16: Invalid variable name "b" (invalid-name)
C: 24,16: Invalid variable name "b" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "M" (invalid-name)
C: 31, 4: Invalid variable name "N" (invalid-name)
C: 32, 4: Invalid variable name "S" (invalid-name)
C: 35, 8: Invalid variable name "n" (invalid-name)
C: 36, 8: Invalid variable name "s" (invalid-name)
C: 38,12: Invalid variable name "m" (invalid-name)
C: 40,20: Invalid variable name "b" (invalid-name)
C: 44,28: Invalid variable name "n" (invalid-name)
C: 45,28: Invalid variable name "s" (invalid-name)
C: 51, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused roughPrimes imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge111\challenge111.py:1:1: F401 'roughPrimes' imported but unused
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:3:20: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge111\challenge111.py:14:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge111\challenge111.py:38:80: E501 line too long (95 > 79 characters)
D:\Development\pemjh\pemjh\challenge111\challenge111.py:40:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge112/challenge112.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "isBouncy" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  6, 8: Invalid variable name "d" (invalid-name)
C:  6,11: Invalid variable name "nextM" (invalid-name)
C:  9,12: Invalid variable name "nextMovement" (invalid-name)
C: 11,12: Invalid variable name "nextMovement" (invalid-name)
C: 13,12: Invalid variable name "nextMovement" (invalid-name)
C: 15, 8: Invalid variable name "m" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "currentBouncy" (invalid-name)
C: 32, 4: Invalid variable name "currentNumber" (invalid-name)
C: 36,12: Invalid variable name "currentBouncy" (invalid-name)
C: 39,54: More than one statement on a single line (multiple-statements)
C: 41, 8: Invalid variable name "currentNumber" (invalid-name)
C: 45, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge112\challenge112.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge112\challenge112.py:39:53: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge113/challenge113.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  4, 0: Unable to import 'utils.numbers' (import-error)
C:  6, 0: Missing function docstring (missing-docstring)
C: 21, 8: Invalid variable name "d" (invalid-name)
C: 22, 8: Invalid variable name "p" (invalid-name)
C: 58, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge113\challenge113.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge114/challenge114.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 14,16: Invalid variable name "nVariations" (invalid-name)
C: 17, 8: Invalid variable name "nVariations" (invalid-name)
C: 20, 8: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 27, 4: Invalid variable name "n" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge114\challenge114.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge114\challenge114.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge114\challenge114.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge115/challenge115.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, minimum, tileSizes, known = dict()):
                                                    ^ (bad-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 15,12: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 21, 8: Invalid variable name "nVariations" (invalid-name)
C: 27, 0: Invalid function name "f" (invalid-name)
C: 27, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "n" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 33, 4: Invalid variable name "b" (invalid-name)
C: 38, 8: Invalid variable name "b" (invalid-name)
C: 40, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge115\challenge115.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge115\challenge115.py:27:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge115\challenge115.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge116/challenge116.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                        ^ (bad-whitespace)
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSize, dec = True, known = dict()):
                                                      ^ (bad-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSize" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  9,12: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 15, 8: Invalid variable name "nVariations" (invalid-name)
C: 18, 8: Invalid variable name "nVariations" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "n2" (invalid-name)
C: 26, 4: Invalid variable name "n3" (invalid-name)
C: 27, 4: Invalid variable name "n4" (invalid-name)
C: 30, 0: Missing function docstring (missing-docstring)
C: 34, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:42: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:1:56: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge116\challenge116.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge116\challenge116.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge116\challenge116.py:30:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge117/challenge117.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tileSizes, known = dict()):
                                           ^ (bad-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numVariations" (invalid-name)
C:  1, 0: Invalid argument name "tileSizes" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nVariations" (invalid-name)
C:  7,12: Invalid variable name "tileSize" (invalid-name)
C: 10,16: Invalid variable name "nVariations" (invalid-name)
C: 13, 8: Invalid variable name "nVariations" (invalid-name)
C: 16, 8: Invalid variable name "nVariations" (invalid-name)
C: 22, 0: Missing function docstring (missing-docstring)
C: 23, 4: Invalid variable name "n" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:43: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:1:45: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge117\challenge117.py:17:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge117\challenge117.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge117\challenge117.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge118/challenge118.py _________________
C: 10, 0: No space allowed around keyword argument assignment
def build_sets(existing, left, lExist = 0):
                                      ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 0: Invalid argument name "lExist" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 15, 8: Invalid variable name "lLeft" (invalid-name)
C: 16, 8: Invalid variable name "lNew" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 32, 4: Invalid variable name "pc" (invalid-name)
W: 37,12: Used builtin function 'map' (bad-builtin)
C: 45, 0: Missing function docstring (missing-docstring)
C: 49, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge118\challenge118.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:38: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:10:40: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge118\challenge118.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge118\challenge118.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge118\challenge118.py:35:80: E501 line too long (97 > 79 characters)
D:\Development\pemjh\pemjh\challenge118\challenge118.py:45:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge119/challenge119.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "sumDigits" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "w" (invalid-name)
C:  5, 8: Invalid variable name "w" (invalid-name)
C:  5,11: Invalid variable name "m" (invalid-name)
C:  9, 0: Invalid function name "an" (invalid-name)
C:  9, 0: Missing function docstring (missing-docstring)
C: 16,12: Invalid variable name "p" (invalid-name)
C: 18,12: Invalid variable name "s" (invalid-name)
W: 16,12: Unused variable 'p' (unused-variable)
C: 25, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge119\challenge119.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge119\challenge119.py:25:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge120/challenge120.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "highestMod" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge120\challenge120.py:8:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge121/challenge121.py _________________
C: 21, 0: Unnecessary parens after 'not' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "winChance" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 0: Missing function docstring (missing-docstring)
C: 20, 4: Invalid variable name "lossesAllowed" (invalid-name)
C: 22, 8: Invalid variable name "lossesAllowed" (invalid-name)
C: 27, 8: Invalid variable name "wc" (invalid-name)
C: 33, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:3:30: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge121\challenge121.py:18:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge121\challenge121.py:33:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge122/challenge122.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12,16: Invalid variable name "f" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge122\challenge122.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge122\challenge122.py:22:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge123/challenge123.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getRemainder" (invalid-name)
C:  3, 0: Invalid argument name "p" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "n" (invalid-name)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 11, 8: Invalid variable name "r" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 17, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge123\challenge123.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge123\challenge123.py:6:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge124/challenge124.py _________________
C:  5, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] > b[1]))):
        ^   | (bad-continuation)
C: 12, 0: Wrong continued indentation before block.
        ((a[0] == b[0]) and (a[1] < b[1]))):
        ^   | (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 24, 8: Invalid variable name "p" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge124\challenge124.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge124\challenge124.py:5:5: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:12:9: E129 visually indented line with same indent as next logical line
D:\Development\pemjh\pemjh\challenge124\challenge124.py:15:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge125/challenge125.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "rtLimit" (invalid-name)
C:  8, 8: Invalid variable name "rtLimit" (invalid-name)
C:  9, 4: Invalid variable name "rtLimit" (invalid-name)
C: 13, 8: Invalid variable name "sq" (invalid-name)
C: 15,12: Invalid variable name "sq" (invalid-name)
C: 26, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge126/challenge126.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 11, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 16, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 20, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 24, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C: 29, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "surroundingCubes" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Invalid argument name "y" (invalid-name)
C:  1, 0: Invalid argument name "z" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "maximumResult" (invalid-name)
C: 10, 4: Invalid variable name "maximumDepth" (invalid-name)
C: 12, 8: Invalid variable name "maximumDepth" (invalid-name)
C: 15, 8: Invalid variable name "maximumA" (invalid-name)
C: 17,12: Invalid variable name "maximumA" (invalid-name)
C: 18,12: Invalid variable name "a" (invalid-name)
C: 19,12: Invalid variable name "maximumB" (invalid-name)
C: 21,16: Invalid variable name "maximumB" (invalid-name)
C: 22,16: Invalid variable name "b" (invalid-name)
C: 23,16: Invalid variable name "maximumC" (invalid-name)
C: 25,20: Invalid variable name "maximumC" (invalid-name)
C: 26,20: Invalid variable name "c" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:2:83: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge126\challenge126.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge126\challenge126.py:20:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge126\challenge126.py:24:80: E501 line too long (97 > 79 characters)

_________________ [pylint] pemjh/challenge127/challenge127.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 20,12: Redefining built-in 'next' (redefined-builtin)
C: 19, 8: Invalid variable name "c" (invalid-name)
C: 21,12: Invalid variable name "a" (invalid-name)
C: 24,12: Invalid variable name "b" (invalid-name)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge127\challenge127.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge127\challenge127.py:8:14: E231 missing whitespace after ','

_________________ [pylint] pemjh/challenge128/challenge128.py _________________
C: 23, 0: Line too long (103/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "nPrimes" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 30, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge128\challenge128.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge128\challenge128.py:19:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge128\challenge128.py:23:80: E501 line too long (103 > 79 characters)

_________________ [pylint] pemjh/challenge129/challenge129.py _________________
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 15, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "A" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 12, 4: Invalid variable name "n" (invalid-name)
C: 14, 8: Invalid variable name "n" (invalid-name)
C: 16,12: Invalid variable name "an" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
F: 25, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge129\challenge129.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge129\challenge129.py:10:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge130/challenge130.py _________________
C:  9, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "A" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 19, 8: Invalid variable name "n" (invalid-name)
C: 25, 0: Invalid constant name "answer" (invalid-name)
F: 28, 4: Unable to import 'psyco' (import-error)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge130\challenge130.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:9:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge130\challenge130.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge130\challenge130.py:14:18: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge130\challenge130.py:19:80: E501 line too long (82 > 79 characters)

_________________ [pylint] pemjh/challenge131/challenge131.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 16, 8: Invalid variable name "p" (invalid-name)
C: 18, 8: Invalid variable name "lowerCube" (invalid-name)
C: 19, 8: Invalid variable name "upperCube" (invalid-name)
C: 25,16: Invalid variable name "lowerCube" (invalid-name)
C: 30,16: Invalid variable name "upperCube" (invalid-name)
C: 38, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge131\challenge131.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge132/challenge132.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "R" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 10, 8: Invalid variable name "p" (invalid-name)
C: 13,33: More than one statement on a single line (multiple-statements)
C: 17, 0: Missing function docstring (missing-docstring)
C: 21, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge132\challenge132.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge132\challenge132.py:13:32: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge132\challenge132.py:17:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge133/challenge133.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge133\challenge133.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge133\challenge133.py:9:80: E501 line too long (96 > 79 characters)

_________________ [pylint] pemjh/challenge134/challenge134.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "jumpSize" (invalid-name)
C:  3, 0: Invalid argument name "t" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Invalid argument name "s" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "cInd" (invalid-name)
C: 21, 4: Invalid variable name "tInd" (invalid-name)
C: 29, 0: Invalid function name "f" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "s" (invalid-name)
C: 33, 4: Invalid variable name "c" (invalid-name)
C: 35, 4: Invalid variable name "t" (invalid-name)
C: 47, 0: Missing function docstring (missing-docstring)
C: 51, 8: Invalid variable name "r" (invalid-name)
C: 54, 4: Invalid variable name "p1" (invalid-name)
C: 55, 4: Invalid variable name "S" (invalid-name)
C: 56, 8: Invalid variable name "p2" (invalid-name)
C: 61, 8: Invalid variable name "n" (invalid-name)
C: 63, 8: Invalid variable name "S" (invalid-name)
C: 65, 8: Invalid variable name "p1" (invalid-name)
W: 51, 8: Unused variable 'r' (unused-variable)
C: 68, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge134\challenge134.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:22:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge134\challenge134.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:47:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge134\challenge134.py:71:1: E112 expected an indented block

_________________ [pylint] pemjh/challenge135/challenge135.py _________________
C: 12, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "getNumTarget" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 8: Invalid variable name "x" (invalid-name)
C:  8,12: Invalid variable name "n" (invalid-name)
C:  9,12: Invalid variable name "n" (invalid-name)
C: 18, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge135\challenge135.py:12:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge135\challenge135.py:18:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge136/challenge136.py _________________
C: 15, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getNumTarget" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 8: Invalid variable name "p" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge136\challenge136.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge136\challenge136.py:15:27: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge136\challenge136.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge137/challenge137.py _________________
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  8, 0: No space allowed around keyword argument assignment
def a(n, known = {0: 0, 1: 2, 2: 15}):
               ^ (bad-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W:  2, 4: Redefining name 'a' from outer scope (line 8) (redefined-outer-name)
C:  2, 4: Invalid variable name "a" (invalid-name)
C:  2, 7: Invalid variable name "b" (invalid-name)
C:  4, 8: Invalid variable name "x" (invalid-name)
C:  6, 8: Invalid variable name "a" (invalid-name)
C:  6,11: Invalid variable name "b" (invalid-name)
W:  4, 8: Unused variable 'x' (unused-variable)
W:  8, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  8, 0: Invalid function name "a" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 19, 0: Missing function docstring (missing-docstring)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge137\challenge137.py:3:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:15: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:8:17: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge137\challenge137.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge137\challenge137.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge138/challenge138.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
W: 15, 8: Redefining built-in 'next' (redefined-builtin)
C:  4, 4: Invalid variable name "b1" (invalid-name)
C:  5, 4: Invalid variable name "b2" (invalid-name)
C: 17, 8: Invalid variable name "v" (invalid-name)
C: 21,12: Invalid variable name "v" (invalid-name)
C: 27,23: More than one statement on a single line (multiple-statements)
W:  7, 8: Unused variable 'i' (unused-variable)
C: 31, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge138\challenge138.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge138\challenge138.py:27:22: E702 multiple statements on one line (semicolon)

_________________ [pylint] pemjh/challenge139/challenge139.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge139\challenge139.py:3:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge142/challenge142.py _________________
C: 32, 0: Line too long (105/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "perfectSquare" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Invalid argument name "a" (invalid-name)
C:  4, 0: Invalid argument name "b" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge142\challenge142.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge142\challenge142.py:32:80: E501 line too long (105 > 79 characters)

_________________ [pylint] pemjh/challenge144/challenge144.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "solveQuadratic" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Invalid argument name "c" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "sqPart" (invalid-name)
C:  7, 0: Invalid argument name "x" (invalid-name)
C:  7, 0: Invalid argument name "y" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C:  9, 4: Invalid variable name "impGrad" (invalid-name)
C: 12, 4: Invalid variable name "impAngle" (invalid-name)
C: 15, 4: Invalid variable name "inAngle" (invalid-name)
C: 18, 4: Invalid variable name "diffAngle" (invalid-name)
C: 21, 4: Invalid variable name "newAngle" (invalid-name)
C: 24, 4: Invalid variable name "newGradient" (invalid-name)
C: 29, 0: Invalid function name "nextStep" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 31, 4: Invalid variable name "m" (invalid-name)
C: 34, 4: Invalid variable name "c" (invalid-name)
C: 41, 4: Invalid variable name "x1" (invalid-name)
C: 41, 8: Invalid variable name "x2" (invalid-name)
C: 45, 8: Invalid variable name "xImpact" (invalid-name)
C: 47, 8: Invalid variable name "xImpact" (invalid-name)
C: 49, 4: Invalid variable name "yImpact" (invalid-name)
C: 53, 0: Missing function docstring (missing-docstring)
C: 56, 0: Missing function docstring (missing-docstring)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge144\challenge144.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:53:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge144\challenge144.py:56:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge145/challenge145.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 8: Invalid variable name "d" (invalid-name)
C:  8, 4: Invalid variable name "sevenDigits" (invalid-name)
C: 12, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge146/challenge146.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def is_pseudo_prime(n, known = {1: True, 2: True}):
                             ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value {} as argument (dangerous-default-value)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 16, 0: Missing function docstring (missing-docstring)
C: 18, 4: Invalid variable name "ns" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 28, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:29: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:1:31: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge146\challenge146.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge146\challenge146.py:18:73: E502 the backslash is redundant between brackets
D:\Development\pemjh\pemjh\challenge146\challenge146.py:19:15: E127 continuation line over-indented for visual indent

_________________ [pylint] pemjh/challenge148/challenge148.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 0: Missing function docstring (missing-docstring)
C: 31, 0: Missing function docstring (missing-docstring)
C: 36, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge148\challenge148.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge148\challenge148.py:29:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge148\challenge148.py:31:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge149/challenge149.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid argument name "l" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 29, 0: Missing function docstring (missing-docstring)
W: 35,13: Used builtin function 'map' (bad-builtin)
W: 44,13: Used builtin function 'map' (bad-builtin)
C: 48, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge149\challenge149.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge149\challenge149.py:29:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge151/challenge151.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a5" (invalid-name)
C:  1, 0: Invalid argument name "a4" (invalid-name)
C:  1, 0: Invalid argument name "a3" (invalid-name)
C:  1, 0: Invalid argument name "a2" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 22, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge151\challenge151.py:4:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:21:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge151\challenge151.py:22:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge162/challenge162.py _________________
C:  2, 0: Line too long (103/100) (line-too-long)
C:  3, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  6, 0: Invalid constant name "answer" (invalid-name)
C:  8, 0: Invalid constant name "desc" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge162\challenge162.py:2:80: E501 line too long (103 > 79 characters)
D:\Development\pemjh\pemjh\challenge162\challenge162.py:3:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge164/challenge164.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(size, previousThree, useZero, known = dict()):
                                                  ^ (bad-whitespace)
C: 15, 0: Trailing whitespace (trailing-whitespace)
C: 24, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "useZero" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  8, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nLosses" (invalid-name)
C: 33, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:50: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge164\challenge164.py:15:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge164\challenge164.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge164\challenge164.py:24:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge166/challenge166.py _________________
C: 60, 0: Line too long (102/100) (line-too-long)
C: 65, 0: Line too long (114/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "sq" (invalid-name)
R:  1, 0: Too many branches (14/12) (too-many-branches)
C: 70, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge166\challenge166.py:45:80: E501 line too long (86 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:49:80: E501 line too long (88 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:50:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:51:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:53:80: E501 line too long (96 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:55:80: E501 line too long (83 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:57:80: E501 line too long (99 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:58:80: E501 line too long (100 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:60:80: E501 line too long (102 > 79 characters)
D:\Development\pemjh\pemjh\challenge166\challenge166.py:65:80: E501 line too long (114 > 79 characters)

_________________ [pylint] pemjh/challenge173/challenge173.py _________________
C: 33, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "numOfSquares" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "nSquares" (invalid-name)
C:  3, 4: Invalid variable name "holeWidth" (invalid-name)
C:  6, 8: Invalid variable name "holeArea" (invalid-name)
C: 12, 8: Invalid variable name "surroundingWidth" (invalid-name)
C: 16,12: Invalid variable name "totalArea" (invalid-name)
C: 19,12: Invalid variable name "surroundingArea" (invalid-name)
C: 24,12: Invalid variable name "surroundingWidth" (invalid-name)
C: 25,12: Invalid variable name "nSquares" (invalid-name)
C: 27, 8: Invalid variable name "holeWidth" (invalid-name)
C: 29, 0: Missing function docstring (missing-docstring)
C: 32, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge173\challenge173.py:29:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge173\challenge173.py:33:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge174/challenge174.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def getDivisors(n, known = dict()):
                         ^ (bad-whitespace)
C: 11, 0: No space allowed around keyword argument assignment
def getNumEvenDivisors(n, known = dict()):
                                ^ (bad-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  3, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  3, 0: Invalid function name "getDivisors" (invalid-name)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  7, 4: Invalid variable name "d" (invalid-name)
W: 11, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 11, 0: Invalid function name "getNumEvenDivisors" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 4: Invalid variable name "nDiv" (invalid-name)
C: 20,12: Invalid variable name "nDiv" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 4: Invalid variable name "nSquares" (invalid-name)
C: 31, 4: Invalid variable name "nMatches" (invalid-name)
C: 32, 8: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "nMatches" (invalid-name)
W: 33,24: Used builtin function 'filter' (bad-builtin)
W: 33,24: map/filter on lambda could be replaced by comprehension (deprecated-lambda)
W: 33,46: Cell variable n defined in loop (cell-var-from-loop)
C: 37, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:3:27: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:32: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:11:34: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge174\challenge174.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge174\challenge174.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge179/challenge179.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nSame" (invalid-name)
C:  8,12: Invalid variable name "a" (invalid-name)
C: 13,12: Invalid variable name "nSame" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
C: 23, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge179\challenge179.py:19:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge183/challenge183.py _________________
C:  4, 0: No space allowed around keyword argument assignment
def pf(n, known = dict()):
                ^ (bad-whitespace)
C:  7, 0: Trailing whitespace (trailing-whitespace)
C: 12, 0: No space allowed around keyword argument assignment
def factPower(b, f, known = dict()):
                          ^ (bad-whitespace)
C: 30, 0: Line too long (106/100) (line-too-long)
C: 32, 0: Line too long (107/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
W:  4, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  4, 0: Invalid function name "pf" (invalid-name)
C:  4, 0: Invalid argument name "n" (invalid-name)
C:  4, 0: Missing function docstring (missing-docstring)
W: 12, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 12, 0: Invalid function name "factPower" (invalid-name)
C: 12, 0: Invalid argument name "b" (invalid-name)
C: 12, 0: Invalid argument name "f" (invalid-name)
C: 20,11: Invalid variable name "m" (invalid-name)
C: 26, 0: Invalid argument name "n" (invalid-name)
C: 26, 0: Invalid argument name "d" (invalid-name)
C: 26, 0: Missing function docstring (missing-docstring)
C: 28, 4: Invalid variable name "dFacts" (invalid-name)
C: 31, 4: Invalid variable name "termDen" (invalid-name)
C: 32, 4: Invalid variable name "dFacts" (invalid-name)
C: 36, 0: Invalid function name "M" (invalid-name)
C: 36, 0: Invalid argument name "N" (invalid-name)
C: 36, 0: Missing function docstring (missing-docstring)
C: 40, 0: Invalid function name "SD" (invalid-name)
C: 40, 0: Missing function docstring (missing-docstring)
C: 42, 8: Invalid variable name "N" (invalid-name)
C: 50, 0: Missing function docstring (missing-docstring)
C: 53, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:16: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:4:18: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:7:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:26: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:12:28: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge183\challenge183.py:26:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:30:80: E501 line too long (106 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:32:80: E501 line too long (107 > 79 characters)
D:\Development\pemjh\pemjh\challenge183\challenge183.py:36:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:40:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:50:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge183\challenge183.py:57:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge187/challenge187.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "nPrimes" (invalid-name)
C:  7, 4: Invalid variable name "nTwos" (invalid-name)
C: 12,12: Invalid variable name "nTwos" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge187\challenge187.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge187\challenge187.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge188/challenge188.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 12, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge188\challenge188.py:12:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge190/challenge190.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "P" (invalid-name)
C:  1, 0: Invalid argument name "m" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge190\challenge190.py:5:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge191/challenge191.py _________________
C:  1, 0: No space allowed around keyword argument assignment
def numLosses(days, previousThree, latesLeft, known = dict()):
                                                    ^ (bad-whitespace)
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 17, 0: Trailing whitespace (trailing-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def numVariations(blocks, tilePatterns, losingPatterns, known = dict()):
                                                              ^ (bad-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Line too long (105/100) (line-too-long)
C: 67, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
W:  1, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C:  1, 0: Invalid function name "numLosses" (invalid-name)
C:  1, 0: Invalid argument name "previousThree" (invalid-name)
C:  1, 0: Invalid argument name "latesLeft" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
W: 16,12: Redefining built-in 'next' (redefined-builtin)
C:  7, 4: Invalid variable name "nVariations" (invalid-name)
C: 12, 8: Invalid variable name "nVariations" (invalid-name)
C: 17,12: Invalid variable name "nVariations" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "numVariations" (invalid-name)
C: 25, 0: Invalid argument name "tilePatterns" (invalid-name)
C: 25, 0: Invalid argument name "losingPatterns" (invalid-name)
R: 25, 0: Too many local variables (16/15) (too-many-locals)
C: 29, 4: Invalid variable name "nVariations" (invalid-name)
C: 35,16: Invalid variable name "c" (invalid-name)
C: 36,16: Invalid variable name "nVariations" (invalid-name)
C: 39,16: Invalid variable name "tilePattern" (invalid-name)
C: 41,16: Invalid variable name "lTilePattern" (invalid-name)
C: 45,24: Invalid variable name "nVariations" (invalid-name)
C: 50,16: Invalid variable name "nLeft" (invalid-name)
C: 52,20: Invalid variable name "nLeft" (invalid-name)
C: 55,20: Invalid variable name "lPattern" (invalid-name)
C: 62,24: Invalid variable name "nVariations" (invalid-name)
C: 66,12: Invalid variable name "nVariations" (invalid-name)
W: 35,16: Unused variable 'c' (unused-variable)
R: 25, 0: Too many branches (13/12) (too-many-branches)
C: 72, 0: Missing function docstring (missing-docstring)
C: 74, 4: Invalid variable name "nPatterns" (invalid-name)
C: 76, 4: Invalid variable name "nLosses" (invalid-name)
C: 80, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:52: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:1:54: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:17:47: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:18:80: E501 line too long (80 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:62: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:25:64: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge191\challenge191.py:36:80: E501 line too long (89 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:45:80: E501 line too long (105 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:62:80: E501 line too long (93 > 79 characters)
D:\Development\pemjh\pemjh\challenge191\challenge191.py:67:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge191\challenge191.py:72:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge197/challenge197.py _________________
C: 21, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "f" (invalid-name)
C:  1, 0: Invalid argument name "x" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  4, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "n" (invalid-name)
C:  6, 4: Invalid variable name "u" (invalid-name)
C: 13, 8: Invalid variable name "u" (invalid-name)
W: 10, 4: Unused variable 'odd' (unused-variable)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge197\challenge197.py:4:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge197\challenge197.py:10:5: F841 local variable 'odd' is assigned to but never used
D:\Development\pemjh\pemjh\challenge197\challenge197.py:21:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge203/challenge203.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C: 25, 4: Invalid variable name "squareFree" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 29,12: Invalid variable name "p" (invalid-name)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge203\challenge203.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge203\challenge203.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge203\challenge203.py:32:17: E228 missing whitespace around modulo operator
D:\Development\pemjh\pemjh\challenge203\challenge203.py:38:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge204/challenge204.py _________________
C: 16, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getHams" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "nCount" (invalid-name)
C:  5, 8: Invalid variable name "p" (invalid-name)
C:  7, 8: Invalid variable name "pCurrent" (invalid-name)
C: 13,12: Invalid variable name "nCount" (invalid-name)
C: 14,12: Invalid variable name "nCount" (invalid-name)
C: 15,12: Invalid variable name "pCurrent" (invalid-name)
C: 19, 0: Invalid function name "hamNums" (invalid-name)
C: 19, 0: Invalid argument name "maxPrime" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 23, 4: Unused variable 'found' (unused-variable)
C: 26, 0: Missing function docstring (missing-docstring)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge204\challenge204.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge204\challenge204.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge204\challenge204.py:23:5: F841 local variable 'found' is assigned to but never used
D:\Development\pemjh\pemjh\challenge204\challenge204.py:26:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge205/challenge205.py _________________
C:  4, 0: Trailing whitespace (trailing-whitespace)
C: 30, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7, 0: Invalid function name "diceRolls" (invalid-name)
C:  7, 0: Invalid argument name "nDice" (invalid-name)
C:  7, 0: Invalid argument name "nSides" (invalid-name)
C:  7, 0: Missing function docstring (missing-docstring)
C: 10, 4: Invalid variable name "nRolls" (invalid-name)
C: 12, 8: Invalid variable name "n" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 17,10: Invalid variable name "nPete" (invalid-name)
C: 18,11: Invalid variable name "nColin" (invalid-name)
C: 20, 4: Invalid variable name "peteWin" (invalid-name)
C: 21, 4: Invalid variable name "totalRolls" (invalid-name)
C: 22, 8: Invalid variable name "n" (invalid-name)
C: 22,11: Invalid variable name "f" (invalid-name)
C: 24, 8: Invalid variable name "nWins" (invalid-name)
C: 29, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge205\challenge205.py:3:27: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge205\challenge205.py:4:28: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge205\challenge205.py:7:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge205\challenge205.py:30:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge206/challenge206.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  5, 0: Missing function docstring (missing-docstring)
C:  6, 4: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "v" (invalid-name)
C: 12, 0: Invalid function name "hasMask" (invalid-name)
C: 12, 0: Invalid argument name "n" (invalid-name)
C: 12, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "w" (invalid-name)
C: 24, 0: Missing function docstring (missing-docstring)
C: 30, 4: Invalid variable name "lowestRoot" (invalid-name)
C: 34, 8: Invalid variable name "sq" (invalid-name)
C: 36, 8: Invalid variable name "hasM" (invalid-name)
C: 36,14: Invalid variable name "wrongIndex" (invalid-name)
C: 51,12: Invalid variable name "sq" (invalid-name)
C: 58,32: More than one statement on a single line (multiple-statements)
C: 62, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused floor imported from math (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge206\challenge206.py:1:1: F401 'floor' imported but unused
D:\Development\pemjh\pemjh\challenge206\challenge206.py:5:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:12:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:24:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge206\challenge206.py:58:31: E701 multiple statements on one line (colon)

_________________ [pylint] pemjh/challenge207/challenge207.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "a" (invalid-name)
C:  6, 4: Invalid variable name "b" (invalid-name)
C:  7, 4: Invalid variable name "t" (invalid-name)
C:  8, 4: Invalid variable name "nextPower" (invalid-name)
C: 10, 8: Invalid variable name "c" (invalid-name)
C: 15,12: Invalid variable name "t" (invalid-name)
C: 16,12: Invalid variable name "nextPower" (invalid-name)
C: 20, 8: Invalid variable name "a" (invalid-name)
C: 20,11: Invalid variable name "b" (invalid-name)
C: 22, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
_________________ [pylint] pemjh/challenge211/challenge211.py _________________
C: 13, 0: Line too long (112/100) (line-too-long)
C: 54, 0: No space allowed around keyword argument assignment
def challenge211(calc = False):
                      ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  5, 0: Invalid function name "isSquare" (invalid-name)
C:  5, 0: Invalid argument name "n" (invalid-name)
C:  5, 0: Missing function docstring (missing-docstring)
C:  8, 0: Invalid function name "squareSum" (invalid-name)
C:  8, 0: Invalid argument name "n" (invalid-name)
C:  8, 0: Missing function docstring (missing-docstring)
C: 11, 0: Invalid function name "slowButRight" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 15, 0: Invalid argument name "n" (invalid-name)
C: 15, 0: Missing function docstring (missing-docstring)
C: 27, 8: Invalid variable name "d" (invalid-name)
C: 27,11: Invalid variable name "m" (invalid-name)
C: 30,12: Invalid variable name "a" (invalid-name)
C: 33,16: Invalid variable name "a" (invalid-name)
C: 34,16: Invalid variable name "d" (invalid-name)
C: 34,19: Invalid variable name "m" (invalid-name)
C: 44, 0: Missing function docstring (missing-docstring)
C: 47, 8: Invalid variable name "x" (invalid-name)
C: 48, 8: Invalid variable name "s" (invalid-name)
C: 54, 0: Missing function docstring (missing-docstring)
C: 63, 0: Invalid constant name "answer" (invalid-name)
F: 66, 4: Unable to import 'psyco' (import-error)
W:  2, 0: Unused takewhile imported from itertools (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge211\challenge211.py:2:1: F401 'takewhile' imported but unused
D:\Development\pemjh\pemjh\challenge211\challenge211.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:13:80: E501 line too long (112 > 79 characters)
D:\Development\pemjh\pemjh\challenge211\challenge211.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:44:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:54:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:24: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge211\challenge211.py:59:25: E262 inline comment should start with '# '

_________________ [pylint] pemjh/challenge214/challenge214.py _________________
C:  3, 0: No space allowed around keyword argument assignment
def totients(n, primes = None):
                       ^ (bad-whitespace)
C: 25, 0: No space allowed around keyword argument assignment
def totientChainLength(n, current, limit, steps, known = dict()):
                                                       ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid argument name "n" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C: 14, 8: Invalid variable name "p" (invalid-name)
C: 19,12: Invalid variable name "t" (invalid-name)
W: 25, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 25, 0: Invalid function name "totientChainLength" (invalid-name)
C: 25, 0: Invalid argument name "n" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
C: 51,12: Invalid variable name "v" (invalid-name)
W: 25,26: Unused argument 'current' (unused-argument)
C: 58, 0: Missing function docstring (missing-docstring)
C: 64, 8: Invalid variable name "p" (invalid-name)
C: 71, 0: Invalid constant name "answer" (invalid-name)
W:  1, 0: Unused primeFactors imported from utils.numbers (unused-import)
W:  1, 0: Unused phi imported from utils.numbers (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'phi' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:1:1: F401 'primeFactors' imported but unused
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:23: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:3:25: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:5:15: E711 comparison to None should be 'if cond is None:'
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:55: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:25:57: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge214\challenge214.py:58:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge214\challenge214.py:74:5: E265 block comment should start with '# '
D:\Development\pemjh\pemjh\challenge214\challenge214.py:75:5: E265 block comment should start with '# '

_________________ [pylint] pemjh/challenge215/challenge215.py _________________
C:  3, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C:  6, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C:  9, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 12, 0: Unnecessary parens after 'elif' keyword (superfluous-parens)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "buildRowOptions" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C: 25, 0: Invalid function name "runningCrack" (invalid-name)
C: 25, 0: Missing function docstring (missing-docstring)
W: 31, 0: Dangerous default value dict() (__builtin__.dict) as argument (dangerous-default-value)
C: 31, 0: Invalid function name "W" (invalid-name)
C: 31, 0: Invalid argument name "startRow" (invalid-name)
C: 31, 0: Missing function docstring (missing-docstring)
C: 39,16: Invalid variable name "subRow" (invalid-name)
C: 46, 0: Missing function docstring (missing-docstring)
C: 48, 4: Invalid variable name "wallWidth" (invalid-name)
C: 49, 4: Invalid variable name "wallHeight" (invalid-name)
C: 51, 4: Invalid variable name "rowLinks" (invalid-name)
W: 53,11: Used builtin function 'map' (bad-builtin)
C: 61, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge215\challenge215.py:23:19: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge215\challenge215.py:25:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:31:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:34:8: E713 test for membership should be 'not in'
D:\Development\pemjh\pemjh\challenge215\challenge215.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge215\challenge215.py:55:80: E501 line too long (81 > 79 characters)

_________________ [pylint] pemjh/challenge216/challenge216.py _________________
C:  2, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 46, 0: No space allowed around keyword argument assignment
def challenge216(skip = True):
                      ^ (bad-whitespace)
C: 49, 0: Trailing whitespace (trailing-whitespace)
C: 51, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C: 54, 0: Exactly one space required after comma
    primes[0:2] = [False,False]
                        ^ (bad-whitespace)
C: 55, 0: Trailing whitespace (trailing-whitespace)
C: 60, 0: Trailing whitespace (trailing-whitespace)
C: 62, 0: Trailing whitespace (trailing-whitespace)
C: 63, 0: Exactly one space required after comma
    t[0:2] = [False,False]
                   ^ (bad-whitespace)
C: 64, 0: Trailing whitespace (trailing-whitespace)
C: 75, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid function name "l" (invalid-name)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Invalid argument name "b" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  6, 8: Invalid variable name "v" (invalid-name)
C:  8,12: Invalid variable name "v" (invalid-name)
C: 20, 0: Invalid function name "sq" (invalid-name)
C: 20, 0: Invalid argument name "a" (invalid-name)
C: 20, 0: Invalid argument name "p" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 21, 4: Invalid variable name "q" (invalid-name)
C: 21, 7: Invalid variable name "e" (invalid-name)
C: 23, 8: Invalid variable name "e" (invalid-name)
C: 24, 8: Invalid variable name "q" (invalid-name)
C: 25, 4: Invalid variable name "n" (invalid-name)
C: 27, 8: Invalid variable name "n" (invalid-name)
C: 28, 4: Invalid variable name "z" (invalid-name)
C: 29, 4: Invalid variable name "y" (invalid-name)
C: 29, 7: Invalid variable name "r" (invalid-name)
C: 29,10: Invalid variable name "x" (invalid-name)
C: 30, 4: Invalid variable name "b" (invalid-name)
C: 31, 4: Invalid variable name "x" (invalid-name)
C: 33, 8: Invalid variable name "bb" (invalid-name)
C: 33,12: Invalid variable name "m" (invalid-name)
C: 35,12: Invalid variable name "bb" (invalid-name)
C: 36,12: Invalid variable name "m" (invalid-name)
C: 39, 8: Invalid variable name "t" (invalid-name)
C: 41,12: Invalid variable name "t" (invalid-name)
C: 42, 8: Invalid variable name "y" (invalid-name)
C: 42,11: Invalid variable name "r" (invalid-name)
C: 42,14: Invalid variable name "x" (invalid-name)
C: 43, 8: Invalid variable name "b" (invalid-name)
W: 40,12: Unused variable 'k' (unused-variable)
C: 46, 0: Missing function docstring (missing-docstring)
C: 56, 8: Invalid variable name "x" (invalid-name)
C: 58,16: Invalid variable name "y" (invalid-name)
C: 61, 4: Invalid variable name "t" (invalid-name)
C: 65, 8: Invalid variable name "x" (invalid-name)
C: 67,12: Invalid variable name "s" (invalid-name)
C: 78, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge216\challenge216.py:2:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:22: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:46:24: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge216\challenge216.py:49:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:51:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:53:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:54:25: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:55:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:60:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:62:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:63:20: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge216\challenge216.py:64:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge216\challenge216.py:75:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge220/challenge220.py _________________
C:  2, 0: Exactly one space required after comma
    c = [0,1]
          ^ (bad-whitespace)
C: 13, 0: Exactly one space required after comma
    c2 = [-c2[1],c2[0]]
                ^ (bad-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "c" (invalid-name)
C:  5, 8: Invalid variable name "c" (invalid-name)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 12, 4: Invalid variable name "c2" (invalid-name)
C: 13, 4: Invalid variable name "c2" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
W: 17,20: Used builtin function 'map' (bad-builtin)
C: 19, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge220\challenge220.py:2:11: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:13:17: E231 missing whitespace after ','
D:\Development\pemjh\pemjh\challenge220\challenge220.py:16:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge225/challenge225.py _________________
C:  2, 0: Line too long (108/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  8, 8: Invalid variable name "a" (invalid-name)
C:  8,11: Invalid variable name "b" (invalid-name)
C:  8,14: Invalid variable name "c" (invalid-name)
C: 10,12: Invalid variable name "a" (invalid-name)
C: 10,15: Invalid variable name "b" (invalid-name)
C: 10,18: Invalid variable name "c" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge225\challenge225.py:2:80: E501 line too long (108 > 79 characters)

_________________ [pylint] pemjh/challenge230/challenge230.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C: 36, 0: Trailing whitespace (trailing-whitespace)
C: 40, 0: Line too long (110/100) (line-too-long)
C: 41, 0: Line too long (110/100) (line-too-long)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid function name "D" (invalid-name)
C:  1, 0: Invalid argument name "a" (invalid-name)
C:  1, 0: Invalid argument name "b" (invalid-name)
C:  1, 0: Invalid argument name "n" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  5, 4: Invalid variable name "aSize" (invalid-name)
C:  7, 4: Invalid variable name "bSize" (invalid-name)
C:  9, 8: Invalid variable name "aSize" (invalid-name)
C:  9,15: Invalid variable name "bSize" (invalid-name)
C: 14, 4: Invalid variable name "workingN" (invalid-name)
C: 22, 8: Invalid variable name "firstSize" (invalid-name)
C: 25,12: Invalid variable name "workingN" (invalid-name)
C: 33, 8: Invalid variable name "containingStr" (invalid-name)
C: 35, 8: Invalid variable name "containingStr" (invalid-name)
W:  2, 4: Unused variable 'size' (unused-variable)
C: 39, 0: Missing function docstring (missing-docstring)
C: 40, 4: Invalid variable name "a" (invalid-name)
C: 41, 4: Invalid variable name "b" (invalid-name)
C: 44,15: Invalid variable name "n" (invalid-name)
C: 49, 0: Invalid constant name "answer" (invalid-name)
W: 52, 4: Unused import sys (unused-import)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge230\challenge230.py:2:5: F841 local variable 'size' is assigned to but never used
D:\Development\pemjh\pemjh\challenge230\challenge230.py:13:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:36:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge230\challenge230.py:39:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge230\challenge230.py:40:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:41:80: E501 line too long (110 > 79 characters)
D:\Development\pemjh\pemjh\challenge230\challenge230.py:52:5: F401 'sys' imported but unused

_________________ [pylint] pemjh/challenge231/challenge231.py _________________
C: 43, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Invalid function name "getFirstMultipleOnOrAfter" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "m" (invalid-name)
C: 10, 0: Invalid function name "getFirstMultipleOnOrBefore" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 11, 4: Invalid variable name "m" (invalid-name)
C: 17, 0: Invalid function name "numInRange" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 23, 0: Missing function docstring (missing-docstring)
C: 24, 4: Invalid variable name "n" (invalid-name)
C: 33, 8: Invalid variable name "p" (invalid-name)
C: 43,12: Invalid variable name "numRange" (invalid-name)
C: 49,12: Invalid variable name "denRange" (invalid-name)
C: 53,12: Invalid variable name "inRange" (invalid-name)
C: 59,16: Invalid variable name "inRange" (invalid-name)
C: 62,16: Invalid variable name "inRange" (invalid-name)
W: 36, 8: Unused variable 'index' (unused-variable)
C: 69, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge231\challenge231.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:23:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge231\challenge231.py:36:9: F841 local variable 'index' is assigned to but never used
D:\Development\pemjh\pemjh\challenge231\challenge231.py:43:71: W291 trailing whitespace

_________________ [pylint] pemjh/challenge234/challenge234.py _________________
C: 22, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Wrong continued indentation.
                          next**2 if next**2 < limit + 1 else limit + 1,
                          ^| (bad-continuation)
C: 24, 0: Wrong continued indentation.
                          current))
                          ^| (bad-continuation)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  9, 0: Missing function docstring (missing-docstring)
W: 19, 8: Redefining built-in 'next' (redefined-builtin)
C: 41, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge234\challenge234.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:9:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge234\challenge234.py:22:49: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge234\challenge234.py:23:27: E128 continuation line under-indented for visual indent
D:\Development\pemjh\pemjh\challenge234\challenge234.py:24:27: E128 continuation line under-indented for visual indent

_________________ [pylint] pemjh/challenge235/challenge235.py _________________
C: 13, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
C:  3, 4: Invalid variable name "r" (invalid-name)
C:  4, 4: Invalid variable name "dr" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  7, 8: Invalid variable name "s" (invalid-name)
C:  9,12: Invalid variable name "r" (invalid-name)
C: 11,12: Invalid variable name "r" (invalid-name)
C: 12, 8: Invalid variable name "dr" (invalid-name)
C: 16, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge235\challenge235.py:13:1: W293 blank line contains whitespace

_________________ [pylint] pemjh/challenge243/challenge243.py _________________
C: 38, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
F:  1, 0: Unable to import 'utils.numbers' (import-error)
C:  3, 0: Missing function docstring (missing-docstring)
C:  8, 0: Missing function docstring (missing-docstring)
C: 15, 0: Missing function docstring (missing-docstring)
C: 22, 4: Invalid variable name "d" (invalid-name)
C: 24,23: More than one statement on a single line (multiple-statements)
C: 26, 8: Invalid variable name "d" (invalid-name)
C: 37,20: Invalid variable name "m" (invalid-name)
C: 38,20: Invalid variable name "d" (invalid-name)
C: 46, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge243\challenge243.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:8:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:15:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge243\challenge243.py:24:22: E701 multiple statements on one line (colon)
D:\Development\pemjh\pemjh\challenge243\challenge243.py:38:34: W291 trailing whitespace
D:\Development\pemjh\pemjh\challenge243\challenge243.py:39:50: E225 missing whitespace around operator
D:\Development\pemjh\pemjh\challenge243\challenge243.py:51:1: W391 blank line at end of file

_________________ [pylint] pemjh/challenge250/challenge250.py _________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Missing function docstring (missing-docstring)
W: 12,12: Unused variable 'j' (unused-variable)
C: 20, 0: Missing function docstring (missing-docstring)
C: 24, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge250\challenge250.py:14:80: E501 line too long (81 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:15:80: E501 line too long (82 > 79 characters)
D:\Development\pemjh\pemjh\challenge250\challenge250.py:20:1: E302 expected 2 blank lines, found 1

_________________ [pylint] pemjh/challenge259/challenge259.py _________________
C: 22, 0: No space allowed around keyword argument assignment
def get_totals(start, end, known = {}):
                                 ^ (bad-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  3, 0: Invalid argument name "a" (invalid-name)
C:  3, 0: Missing function docstring (missing-docstring)
C:  4, 4: Invalid variable name "g" (invalid-name)
C: 10, 0: Invalid argument name "a" (invalid-name)
C: 10, 0: Invalid argument name "b" (invalid-name)
C: 10, 0: Missing function docstring (missing-docstring)
C: 13, 0: Invalid argument name "a" (invalid-name)
C: 13, 0: Invalid argument name "b" (invalid-name)
C: 13, 0: Missing function docstring (missing-docstring)
C: 16, 0: Invalid argument name "a" (invalid-name)
C: 16, 0: Invalid argument name "b" (invalid-name)
C: 16, 0: Missing function docstring (missing-docstring)
C: 19, 0: Invalid argument name "a" (invalid-name)
C: 19, 0: Invalid argument name "b" (invalid-name)
C: 19, 0: Missing function docstring (missing-docstring)
W: 22, 0: Dangerous default value {} as argument (dangerous-default-value)
C: 22, 0: Missing function docstring (missing-docstring)
C: 55, 0: Invalid constant name "answer" (invalid-name)
C: 57, 0: Missing function docstring (missing-docstring)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge259\challenge259.py:3:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:10:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:13:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:16:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:19:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:33: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:22:35: E251 unexpected spaces around keyword / parameter equals
D:\Development\pemjh\pemjh\challenge259\challenge259.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge259\challenge259.py:57:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge259\challenge259.py:63:80: E501 line too long (80 > 79 characters)

_________________ [pylint] pemjh/challenge265/challenge265.py _________________
C: 10, 0: Trailing whitespace (trailing-whitespace)
C: 14, 0: Trailing whitespace (trailing-whitespace)
C: 16, 0: Trailing whitespace (trailing-whitespace)
C: 19, 0: Trailing whitespace (trailing-whitespace)
C: 23, 0: Trailing whitespace (trailing-whitespace)
C: 27, 0: Unnecessary parens after 'if' keyword (superfluous-parens)
C: 32, 0: Trailing whitespace (trailing-whitespace)
C: 34, 0: Trailing whitespace (trailing-whitespace)
C: 38, 0: Trailing whitespace (trailing-whitespace)
C: 42, 0: Trailing whitespace (trailing-whitespace)
C: 45, 0: Trailing whitespace (trailing-whitespace)
C: 48, 0: Trailing whitespace (trailing-whitespace)
C: 53, 0: Trailing whitespace (trailing-whitespace)
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "h" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  2, 4: Invalid variable name "d" (invalid-name)
C:  2, 7: Invalid variable name "m" (invalid-name)
C:  3, 4: Invalid variable name "s" (invalid-name)
C:  4, 4: Invalid variable name "d" (invalid-name)
C:  4, 7: Invalid variable name "m" (invalid-name)
C:  5, 4: Invalid variable name "s" (invalid-name)
C:  6, 4: Invalid variable name "d" (invalid-name)
C:  6, 7: Invalid variable name "m" (invalid-name)
C:  7, 4: Invalid variable name "s" (invalid-name)
C:  8, 4: Invalid variable name "s" (invalid-name)
C: 11, 0: Invalid argument name "n" (invalid-name)
C: 11, 0: Invalid argument name "d" (invalid-name)
C: 11, 0: Missing function docstring (missing-docstring)
C: 13, 4: Invalid variable name "b" (invalid-name)
C: 17, 0: Invalid argument name "n" (invalid-name)
C: 17, 0: Missing function docstring (missing-docstring)
C: 20, 0: Invalid function name "getSequences" (invalid-name)
C: 20, 0: Missing function docstring (missing-docstring)
C: 26, 8: Invalid variable name "b" (invalid-name)
C: 30,16: Invalid variable name "s" (invalid-name)
C: 35, 0: Invalid function name "S" (invalid-name)
C: 35, 0: Invalid argument name "n" (invalid-name)
C: 35, 0: Missing function docstring (missing-docstring)
C: 49, 0: Missing function docstring (missing-docstring)
C: 52, 0: Invalid constant name "answer" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\challenge265\challenge265.py:10:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:11:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:14:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:16:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:17:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:19:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:20:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:22:20: E261 at least two spaces before inline comment
D:\Development\pemjh\pemjh\challenge265\challenge265.py:23:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:32:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:34:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:35:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:38:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:42:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:45:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:48:1: W293 blank line contains whitespace
D:\Development\pemjh\pemjh\challenge265\challenge265.py:49:1: E302 expected 2 blank lines, found 1
D:\Development\pemjh\pemjh\challenge265\challenge265.py:53:1: W293 blank line contains whitespace

_____________________ [pylint] pemjh/utilities/numbers.py _____________________
C: 92, 0: Unnecessary parens after 'while' keyword (superfluous-parens)
C:  1, 0: Missing module docstring (missing-docstring)
C:  7, 0: Invalid function name "getPrimitiveTriples" (invalid-name)
C: 10, 4: Invalid variable name "n" (invalid-name)
C: 16, 8: Invalid variable name "m" (invalid-name)
C: 23,20: Invalid variable name "a" (invalid-name)
C: 24,20: Invalid variable name "b" (invalid-name)
C: 25,20: Invalid variable name "c" (invalid-name)
C: 36,12: Invalid variable name "m" (invalid-name)
C: 37, 8: Invalid variable name "n" (invalid-name)
C: 40, 0: Missing function docstring (missing-docstring)
C: 41, 8: Invalid variable name "n" (invalid-name)
C: 63, 0: Invalid function name "rootConvergentGenerator" (invalid-name)
C: 63, 0: Missing function docstring (missing-docstring)
C: 64, 4: Invalid variable name "A" (invalid-name)
C: 65, 4: Invalid variable name "A_1" (invalid-name)
C: 67, 4: Invalid variable name "B" (invalid-name)
C: 68, 4: Invalid variable name "B_1" (invalid-name)
C: 70, 8: Invalid variable name "b" (invalid-name)
C: 71, 8: Invalid variable name "newA" (invalid-name)
C: 72, 8: Invalid variable name "newB" (invalid-name)
C: 75, 8: Invalid variable name "A_1" (invalid-name)
C: 75,13: Invalid variable name "A" (invalid-name)
C: 75,16: Invalid variable name "B_1" (invalid-name)
C: 75,21: Invalid variable name "B" (invalid-name)
C: 78, 0: Invalid function name "continueGenerator" (invalid-name)
C: 78, 0: Missing function docstring (missing-docstring)
C: 80, 4: Invalid variable name "b" (invalid-name)
C:103, 8: Invalid variable name "newB" (invalid-name)
C:105, 8: Invalid variable name "nSubtracts" (invalid-name)
C:107,12: Invalid variable name "newB" (invalid-name)
C:108,12: Invalid variable name "nSubtracts" (invalid-name)
C:110, 8: Invalid variable name "b" (invalid-name)
C:130, 0: Invalid function name "polytopicNumbers" (invalid-name)
C:130, 0: Invalid argument name "f" (invalid-name)
C:130, 0: Missing function docstring (missing-docstring)
C:132, 8: Invalid variable name "n" (invalid-name)
C:139, 0: Missing function docstring (missing-docstring)
W:151, 8: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:144, 4: Invalid function name "applyMultiple" (invalid-name)
C:144, 4: Missing function docstring (missing-docstring)
W:144,38: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:160, 0: Invalid function name "numPermutations" (invalid-name)
C:160, 0: Invalid argument name "numString" (invalid-name)
C:160, 0: Missing function docstring (missing-docstring)
C:161, 4: Invalid variable name "maximumPermutations" (invalid-name)
C:163, 4: Invalid variable name "tempString" (invalid-name)
C:166, 8: Invalid variable name "c" (invalid-name)
C:168, 8: Invalid variable name "cCount" (invalid-name)
C:173, 8: Invalid variable name "tempString" (invalid-name)
C:178, 0: Invalid argument name "x" (invalid-name)
C:178, 0: Missing function docstring (missing-docstring)
C:185, 0: Missing function docstring (missing-docstring)
C:186, 4: Invalid variable name "a" (invalid-name)
C:187, 4: Invalid variable name "b" (invalid-name)
C:190, 8: Invalid variable name "a" (invalid-name)
C:190,11: Invalid variable name "b" (invalid-name)
C:193, 0: Invalid function name "getNumDivisors" (invalid-name)
C:193, 0: Invalid argument name "n" (invalid-name)
C:193, 0: Missing function docstring (missing-docstring)
C:194, 4: Invalid variable name "nDivisors" (invalid-name)
C:196, 4: Invalid variable name "potentialDivisor" (invalid-name)
C:197, 4: Invalid variable name "remainingN" (invalid-name)
C:199, 8: Invalid variable name "divideCount" (invalid-name)
C:201,12: Invalid variable name "divideCount" (invalid-name)
C:202,12: Invalid variable name "remainingN" (invalid-name)
C:205,12: Invalid variable name "nDivisors" (invalid-name)
C:207, 8: Invalid variable name "potentialDivisor" (invalid-name)
C:212, 0: Invalid function name "getNumDivisorsHelped" (invalid-name)
C:212, 0: Invalid argument name "n" (invalid-name)
C:212, 0: Missing function docstring (missing-docstring)
C:217, 8: Invalid variable name "nDivisors" (invalid-name)
C:219, 8: Invalid variable name "potentialDivisor" (invalid-name)
C:220, 8: Invalid variable name "remainingN" (invalid-name)
C:223,16: Invalid variable name "divideCount" (invalid-name)
C:225,20: Invalid variable name "divideCount" (invalid-name)
C:226,20: Invalid variable name "remainingN" (invalid-name)
C:229,20: Invalid variable name "nDivisors" (invalid-name)
C:233,20: Invalid variable name "nDivisors" (invalid-name)
C:234,20: Invalid variable name "remainingN" (invalid-name)
C:236,12: Invalid variable name "potentialDivisor" (invalid-name)
C:243, 0: Invalid argument name "n" (invalid-name)
C:243, 0: Invalid argument name "includeN" (invalid-name)
C:243, 0: Missing function docstring (missing-docstring)
C:263, 0: Invalid argument name "n" (invalid-name)
C:263, 0: Missing function docstring (missing-docstring)
C:269, 0: Invalid function name "millerRabinPrime" (invalid-name)
C:269, 0: Invalid argument name "n" (invalid-name)
C:269, 0: Missing function docstring (missing-docstring)
C:274, 8: Invalid variable name "s" (invalid-name)
C:275, 8: Invalid variable name "d" (invalid-name)
C:277,12: Invalid variable name "d" (invalid-name)
C:278,12: Invalid variable name "s" (invalid-name)
W:289, 8: Else clause on loop without a break statement (useless-else-on-loop)
C:282,12: Invalid variable name "a" (invalid-name)
W:280,39: Unused variable 'i' (unused-variable)
C:295, 0: Invalid function name "storedPrimes" (invalid-name)
C:295, 0: Invalid argument name "n" (invalid-name)
C:295, 0: Missing function docstring (missing-docstring)
W:302,20: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
W:309, 4: No exception type(s) specified (bare-except)
C:297,73: Invalid variable name "f" (invalid-name)
C:299,12: Invalid variable name "nPrimes" (invalid-name)
C:314, 8: Invalid variable name "p" (invalid-name)
C:318, 0: Invalid function name "generateStoredPrimes" (invalid-name)
C:318, 0: Invalid argument name "n" (invalid-name)
C:318, 0: Missing function docstring (missing-docstring)
W:326,12: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:321,69: Invalid variable name "f" (invalid-name)
E:332,25: Undefined variable 'sievedPrimes_sieve' (undefined-variable)
E:340,25: Undefined variable 'sievedPrimes_sieve' (undefined-variable)
W:334,20: Unused variable 'i' (unused-variable)
R:318, 0: Too many branches (13/12) (too-many-branches)
C:368, 0: Invalid argument name "n" (invalid-name)
C:368, 0: Missing function docstring (missing-docstring)
C:373, 4: Invalid variable name "s" (invalid-name)
C:377, 4: Invalid variable name "m" (invalid-name)
C:386, 8: Invalid variable name "m" (invalid-name)
C:390, 0: Invalid function name "sievedPrimes_New" (invalid-name)
C:390, 0: Invalid argument name "n" (invalid-name)
C:390, 0: Missing function docstring (missing-docstring)
C:392, 8: Invalid variable name "p" (invalid-name)
C:396, 0: Invalid function name "sievedPrimes" (invalid-name)
C:396, 0: Invalid argument name "n" (invalid-name)
C:396, 0: Missing function docstring (missing-docstring)
C:405, 4: Invalid function name "filterNum" (invalid-name)
C:405, 4: Missing function docstring (missing-docstring)
W:405,18: Redefining built-in 'filter' (redefined-builtin)
C:407, 8: Invalid variable name "myMultiple" (invalid-name)
C:421,16: Invalid variable name "nextPrime" (invalid-name)
C:429,20: Invalid variable name "nextPrime" (invalid-name)
C:433,20: Invalid variable name "nextPrime" (invalid-name)
C:438, 0: Invalid function name "primeFactors" (invalid-name)
C:438, 0: Invalid argument name "n" (invalid-name)
C:438, 0: Missing function docstring (missing-docstring)
C:439, 4: Invalid variable name "workingN" (invalid-name)
C:440, 8: Invalid variable name "p" (invalid-name)
C:445,12: Invalid variable name "workingN" (invalid-name)
C:449, 0: Missing function docstring (missing-docstring)
W:453, 8: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:458, 0: Invalid function name "combinedRow" (invalid-name)
C:458, 0: Invalid argument name "t" (invalid-name)
C:458, 0: Invalid argument name "b" (invalid-name)
C:458, 0: Missing function docstring (missing-docstring)
C:461, 4: Invalid variable name "topRow" (invalid-name)
C:462, 4: Invalid variable name "bottomRow" (invalid-name)
C:466, 8: Invalid variable name "nextNum" (invalid-name)
C:467, 8: Invalid variable name "leftNum" (invalid-name)
C:468, 8: Invalid variable name "rightNum" (invalid-name)
C:477, 0: Invalid function name "getTriangleRouteLength" (invalid-name)
C:477, 0: Missing function docstring (missing-docstring)
C:480, 8: Invalid variable name "bottomRow" (invalid-name)
C:483, 8: Invalid variable name "currentRow" (invalid-name)
C:485, 8: Invalid variable name "newRow" (invalid-name)
C:495, 0: Invalid function name "roughPrimes" (invalid-name)
C:495, 0: Missing function docstring (missing-docstring)
C:506, 8: Invalid attribute name "_highestFound" (invalid-name)
C:503, 0: Missing class docstring (missing-docstring)
C:503, 0: Old-style class defined. (old-style-class)
C:509, 4: Invalid method name "_factorInPrimes" (invalid-name)
C:509, 4: Invalid argument name "n" (invalid-name)
C:509, 4: Missing method docstring (missing-docstring)
C:511,12: Invalid variable name "p" (invalid-name)
C:518, 4: Invalid method name "isPrime" (invalid-name)
C:518, 4: Invalid argument name "n" (invalid-name)
C:518, 4: Missing method docstring (missing-docstring)
W:537,16: Redefining name 'prime' from outer scope (line 449) (redefined-outer-name)
C:532,12: Invalid variable name "nextTested" (invalid-name)
C:534,16: Invalid variable name "nextTested" (invalid-name)
C:538,20: Invalid variable name "p" (invalid-name)
R:503, 0: Too few public methods (1/2) (too-few-public-methods)
C:554, 0: Invalid function name "isPrime" (invalid-name)
C:554, 0: Invalid argument name "n" (invalid-name)
C:554, 0: Missing function docstring (missing-docstring)
C:571, 0: Invalid function name "lowestCommonTerms" (invalid-name)
C:571, 0: Invalid argument name "n" (invalid-name)
C:571, 0: Invalid argument name "d" (invalid-name)
C:571, 0: Missing function docstring (missing-docstring)
C:572, 4: Invalid variable name "n2" (invalid-name)
C:573, 4: Invalid variable name "d2" (invalid-name)
C:577,12: Invalid variable name "n2" (invalid-name)
C:578,12: Invalid variable name "d2" (invalid-name)
C:584, 0: Invalid argument name "a" (invalid-name)
C:584, 0: Invalid argument name "b" (invalid-name)
C:584, 0: Missing function docstring (missing-docstring)
C:588, 4: Invalid variable name "bIna" (invalid-name)
C:588,10: Invalid variable name "r" (invalid-name)
W:588, 4: Unused variable 'bIna' (unused-variable)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
________________________________ FLAKE8-check _________________________________
D:\Development\pemjh\pemjh\utilities\numbers.py:332:26: F821 undefined name 'sievedPrimes_sieve'
D:\Development\pemjh\pemjh\utilities\numbers.py:340:26: F821 undefined name 'sievedPrimes_sieve'

_____________________ [pylint] pemjh/utilities/strings.py _____________________
C:  1, 0: Missing module docstring (missing-docstring)
C:  1, 0: Invalid argument name "s" (invalid-name)
C:  1, 0: Missing function docstring (missing-docstring)
C:  7,12: Invalid variable name "n" (invalid-name)
C:  7,15: Invalid variable name "c" (invalid-name)
C:  8,16: Invalid variable name "p" (invalid-name)
---------------------------- Captured stderr call -----------------------------
No config file found, using default configuration
-------------- coverage: platform win32, python 2.7.10-final-42 ---------------
Name                              Stmts   Miss Branch BrMiss  Cover   Missing
-----------------------------------------------------------------------------
pemjh\challenge001\challenge001       7      3      4      3    45%   4, 9-10
pemjh\challenge002\challenge002      12     10      8      7    15%   2-3, 6-16
pemjh\challenge003\challenge003      17     13     10      5    33%   5-23, 28-29
pemjh\challenge004\challenge004      19     16     10      9    14%   5-31, 36-37
pemjh\challenge005\challenge005      24     21     18     17    10%   2-34, 39-40
pemjh\challenge006\challenge006      13     10      4      3    24%   2-18, 23-24
pemjh\challenge007\challenge007      18     13      9      8    22%   5-19, 24-25
pemjh\challenge008\challenge008      16     13     10      9    15%   2-39, 44-45
pemjh\challenge009\challenge009      14     11      8      7    18%   4-16, 21-22
pemjh\challenge010\challenge010      14      9     10      9    25%   6-13, 18-19
pemjh\challenge011\challenge011      39     36     26     25     6%   2-56, 61-62
pemjh\challenge012\challenge012      31     28     14      9    18%   2-3, 7-44
pemjh\challenge013\challenge013      11      8      4      3    27%   2-109, 114-115
pemjh\challenge014\challenge014      29     25     12     11    12%   2-20, 24-36, 41-43
pemjh\challenge015\challenge015      21     19      8      5    17%   2-3, 7-32
pemjh\challenge016\challenge016      12      9      4      3    25%   2-12, 17-18
pemjh\challenge017\challenge017      33     29     16     15    10%   2-39, 42-104, 109-110
pemjh\challenge018\challenge018      26     24      4      3    10%   2-3, 6-31
pemjh\challenge019\challenge019      32     25     18     17    16%   2, 6-9, 12-15, 19-28, 33-40, 45-46
pemjh\challenge020\challenge020      16     12      6      5    23%   2-5, 9-16, 21-22
pemjh\challenge021\challenge021      21     19     14     13     9%   2-3, 7-33
pemjh\challenge022\challenge022      28     21     10      9    21%   5-14, 17-24, 28-32, 37-38
pemjh\challenge023\challenge023      24     18     16     14    20%   2-3, 7-21, 24, 27-29, 34
pemjh\challenge024\challenge024      14     12      6      5    15%   2-3, 7-18
pemjh\challenge025\challenge025      15     13     10      9    12%   2-3, 5-19
pemjh\challenge026\challenge026      21     17     10      9    16%   4-23, 28-29
pemjh\challenge027\challenge027      27     25     14     11    12%   2-3, 6-36
pemjh\challenge028\challenge028      14     11      4      3    22%   2-13, 18-19
pemjh\challenge029\challenge029      14     11      6      5    20%   2-12, 17-18
pemjh\challenge030\challenge030      19     16     10      9    14%   3-16, 21-22
pemjh\challenge031\challenge031      16     12      6      5    23%   2-14, 19, 22-23
pemjh\challenge032\challenge032      20     18     10      9    10%   2-3, 7-27
pemjh\challenge033\challenge033      33     31     18     17     6%   2-3, 7-48
pemjh\challenge034\challenge034      30     28     14     11    11%   2-3, 7-46
pemjh\challenge035\challenge035      38     36     24     23     5%   2-3, 6-59
pemjh\challenge036\challenge036      22     18     10      9    16%   2-7, 11-24, 29-30
pemjh\challenge037\challenge037      27     25     18     15    11%   2-3, 7-36
pemjh\challenge038\challenge038      20     15     10      9    20%   4, 7-21, 26-27
pemjh\challenge039\challenge039      27     23     14     13    12%   2-23, 26-34, 39-40
pemjh\challenge040\challenge040      15     12      6      5    19%   2-13, 18-19
pemjh\challenge041\challenge041      17     15      8      7    12%   2-3, 6-23
pemjh\challenge042\challenge042      30     24     14     13    16%   5-9, 12-36, 41-42
pemjh\challenge043\challenge043      14     12      6      5    15%   2-3, 6-27
pemjh\challenge044\challenge044      27     21     14     13    17%   4, 7-11, 14-29, 34-35
pemjh\challenge045\challenge045      25     19     12      7    30%   2, 5, 9-21, 24-29, 34-35
pemjh\challenge046\challenge046      23     20     12      9    17%   4-5, 8-32
pemjh\challenge047\challenge047      37     34     22     19    10%   4-5, 8-50
pemjh\challenge048\challenge048       7      4      2      1    44%   2-3, 8-10
pemjh\challenge049\challenge049      24     21     16     15    10%   4-5, 8-32
pemjh\challenge050\challenge050      24     22     12     11     8%   2-3, 6-30
pemjh\challenge051\challenge051      38     35     24     21    10%   4-5, 8-50
pemjh\challenge052\challenge052      20     16      8      7    18%   2, 5-22, 27-28
pemjh\challenge053\challenge053      16     14     10      9    12%   2-3, 6-20
pemjh\challenge054\challenge054      71     61     44     43    10%   5-12, 16-19, 22-24, 39-93, 98-111, 115-131, 136
pemjh\challenge055\challenge055      23     19     12      9    20%   2-12, 15-21, 26-27
pemjh\challenge056\challenge056      14     11      8      7    18%   2-11, 16-17
pemjh\challenge057\challenge057      15     12      8      7    17%   2-15, 20-21
pemjh\challenge058\challenge058      26     24     12      9    13%   2-3, 6-38
pemjh\challenge059\challenge059      29     22     19     18    17%   6-21, 27-45, 48-49
pemjh\challenge060\challenge060      75     73     37     36     3%   2-3, 7-119
pemjh\challenge061\challenge061      65     59     42     41     7%   4, 7-22, 28-99, 104
pemjh\challenge062\challenge062      23     19      8      5    23%   4-29, 34
pemjh\challenge063\challenge063      18     14      6      3    29%   4-22, 27-28
pemjh\challenge064\challenge064      24     23      8      8     3%   3-39
pemjh\challenge065\challenge065      20     18      8      7    11%   2-3, 6-37
pemjh\challenge066\challenge066      15     14      8      8     4%   5-23
pemjh\challenge067\challenge067      17     13      6      5    22%   5-6, 11-25
pemjh\challenge068\challenge068      48     43     32     31     8%   2-5, 8-21, 24-65, 70
pemjh\challenge069\challenge069      20     18     10      9    10%   2-3, 6-24
pemjh\challenge070\challenge070      24     22     12     11     8%   2-3, 5-28
pemjh\challenge071\challenge071      25     21     12     11    14%   4-27, 32
pemjh\challenge072\challenge072      10      8      4      3    21%   2-3, 7-14
pemjh\challenge073\challenge073      31     28     16     15     9%   4-5, 8-42
pemjh\challenge074\challenge074      33     28     10      9    14%   2-3, 6-23, 26-36, 41
pemjh\challenge075\challenge075      16     15      8      8     4%   3-27
pemjh\challenge076\challenge076      20     16     10      9    17%   2-17, 30-32, 37
pemjh\challenge077\challenge077      20     19     12     10     9%   3-34
pemjh\challenge078\challenge078      20     17     12     11    13%   2-19, 24
pemjh\challenge079\challenge079       8      3      2      1    60%   9, 14-15
pemjh\challenge080\challenge080      26     21     12     11    16%   5-26, 29-34, 39
pemjh\challenge081\challenge081      32     26     13     12    16%   5-17, 20-41, 46
pemjh\challenge082\challenge082      34     27     12     11    17%   7-37, 41-48, 53
pemjh\challenge083\challenge083      45     38     20     19    12%   6-14, 17-25, 29-75, 80
pemjh\challenge084\challenge084      74     67     48     47     7%   4-6, 10-50, 54-66, 69-109, 114
pemjh\challenge085\challenge085      34     30     16     11    18%   3-10, 13-46, 51
pemjh\challenge086\challenge086      31     25     14     11    20%   2, 6-17, 20-23, 28-39, 44
pemjh\challenge087\challenge087      30     28     14     13     7%   2-3, 5-40
pemjh\challenge088\challenge088      24     19     12     11    17%   5-19, 22-31, 36
pemjh\challenge089\challenge089      51     42     26     25    13%   18-31, 35-51, 54-65, 69-79, 83-85, 90
pemjh\challenge090\challenge090      78     68     50     49     9%   5-18, 21-27, 30-33, 36-69, 74-114, 117-127, 132
pemjh\challenge091\challenge091      23     19     20     19    12%   2-30, 33-35, 40
pemjh\challenge092\challenge092      96     94     50     45     5%   2-3, 6-124
pemjh\challenge093\challenge093      67     59     50     49     8%   4-10, 14-24, 27-32, 35-58, 61-97, 102
pemjh\challenge094\challenge094      35     30     12     11    13%   2-7, 11-48, 54
pemjh\challenge095\challenge095      35     30     22     21    11%   3-10, 14-48, 51-56, 61
pemjh\challenge096\challenge096     181    155    116    115     9%   7-14, 22-34, 40-44, 47-59, 62-69, 73-94, 97-105, 108-115, 118-146, 150-155, 158-174, 178-181, 184-221, 224-228, 231-235, 238-241, 244-254, 257-277, 294
pemjh\challenge097\challenge097       6      3      2      1    50%   2, 7-8
pemjh\challenge098\challenge098      62     54     34     33     9%   5-13, 16-23, 26-30, 33-93, 98
pemjh\challenge099\challenge099      17     12      7      6    25%   5-14, 19-20
pemjh\challenge100\challenge100       9      6      4      3    31%   2-6, 11
pemjh\challenge101\challenge101      26     23     18     17     9%   2-38, 43
pemjh\challenge102\challenge102      34     27     14     13    17%   9-31, 35-41, 45-53, 59
pemjh\challenge103\challenge103      40     35     30     29     9%   3-12, 16-34, 37-56, 61
pemjh\challenge104\challenge104      34     33     15     15     2%   3-50
pemjh\challenge105\challenge105      40     32     22     21    15%   5-19, 22-28, 32-47, 51-58, 65
pemjh\challenge106\challenge106      37     30     16     15    15%   2-14, 17-26, 29-46, 49-60, 63, 68
pemjh\challenge107\challenge107      38     31     12     11    16%   6-34, 37-45, 48-65, 70
pemjh\challenge108\challenge108      35     34     16     16     2%   3-59
pemjh\challenge109\challenge109      37     32     18     17    11%   2-19, 23-29, 32-45, 50
pemjh\challenge110\challenge110      35     34     16     16     2%   3-59
pemjh\challenge111\challenge111      38     37     31     31     1%   3-54
pemjh\challenge112\challenge112      32     28     20     17    13%   2-27, 30-43, 48
pemjh\challenge113\challenge113      16     14      6      5    14%   2-3, 6-61
pemjh\challenge114\challenge114      24     19     12     11    17%   2-24, 27-28, 31-32, 37
pemjh\challenge115\challenge115      30     25     14     13    14%   2-25, 28-29, 32-38, 43
pemjh\challenge116\challenge116      24     19     10      9    18%   2-22, 25-28, 31-32, 37
pemjh\challenge117\challenge117      21     16     10      9    19%   2-20, 23-24, 27-28, 33
pemjh\challenge118\challenge118      36     35     14     14     2%   2-52
pemjh\challenge119\challenge119      24     19     10      9    18%   2-7, 12-23, 26-28, 33
pemjh\challenge120\challenge120      10      6      4      3    36%   2-6, 9-10, 15
pemjh\challenge121\challenge121      26     25     10     10     3%   3-39
pemjh\challenge122\challenge122      15     12     12     11    15%   2-23, 28
pemjh\challenge123\challenge123      16     15      6      6     5%   3-20
pemjh\challenge124\challenge124      21     20     14     14     3%   3-41
pemjh\challenge125\challenge125      21     18     12     11    12%   2-24, 29
pemjh\challenge126\challenge126      31     27     24     23     9%   2, 6-36, 41
pemjh\challenge127\challenge127      23     22     15     15     3%   3-35
pemjh\challenge128\challenge128      23     22     10     10     3%   3-33
pemjh\challenge129\challenge129      22     18     10      9    16%   2-8, 11-20, 25-27
pemjh\challenge130\challenge130      21     20      8      8     3%   3-30
pemjh\challenge131\challenge131      22     21     10     10     3%   3-41
pemjh\challenge132\challenge132      16     15      8      8     4%   3-24
pemjh\challenge133\challenge133      10      9      2      2     8%   3-16
pemjh\challenge134\challenge134      42     41     20     20     2%   3-72
pemjh\challenge135\challenge135      15     11     10      9    20%   2-16, 19, 25
pemjh\challenge136\challenge136      19     18     10     10     3%   3-26
pemjh\challenge137\challenge137      16     11      6      5    27%   2-6, 10-17, 20, 25
pemjh\challenge138\challenge138      23     22     14     14     3%   3-34
pemjh\challenge139\challenge139      11     10      6      6     6%   3-19
pemjh\challenge142\challenge142      26     21     18     17    14%   2, 5, 8-34, 39
pemjh\challenge144\challenge144      34     26      6      5    23%   4-5, 9-27, 31-51, 54, 57-67, 72
pemjh\challenge145\challenge145      11      8      4      3    27%   2-10, 15
pemjh\challenge146\challenge146      18     13     14     13    19%   2-6, 9, 17-26, 31
pemjh\challenge148\challenge148      22     17      6      5    21%   2-8, 11-29, 32-34, 39
pemjh\challenge149\challenge149      32     26     12     11    16%   2, 5, 9-27, 30-46, 51
pemjh\challenge151\challenge151      21     17     14     13    14%   2-20, 23, 28
pemjh\challenge162\challenge162       7      3      4      3    45%   2-4, 11
pemjh\challenge164\challenge164      20     16     10      9    17%   3-23, 27-31, 36
pemjh\challenge166\challenge166      40     37     33     32     5%   3-68, 73
pemjh\challenge173\challenge173      21     17      6      5    19%   2-27, 30, 35
pemjh\challenge174\challenge174      27     26     14     14     2%   3-40
pemjh\challenge179\challenge179      18     14      8      7    19%   3-17, 20-21, 26
pemjh\challenge183\challenge183      39     38     12     12     2%   2-56
pemjh\challenge187\challenge187      16     15      8      8     4%   3-22
pemjh\challenge188\challenge188      15     11      6      5    24%   2-10, 13, 18
pemjh\challenge190\challenge190       7      3      6      5    38%   2, 6, 11
pemjh\challenge191\challenge191      48     43     34     33     7%   2-23, 27-70, 73-78, 83
pemjh\challenge197\challenge197      19     15      8      7    19%   2, 5-22, 27
pemjh\challenge203\challenge203      27     26     16     16     2%   3-44
pemjh\challenge204\challenge204      21     20      8      8     3%   3-32
pemjh\challenge205\challenge205      25     20     10      9    17%   2-4, 8-14, 17-27, 32
pemjh\challenge206\challenge206      45     37     16     13    18%   6-10, 13-22, 26-60, 65
pemjh\challenge207\challenge207      20     17      6      5    15%   3-20, 25
pemjh\challenge211\challenge211      46     45     24     24     1%   2-68
pemjh\challenge214\challenge214      45     44     26     26     1%   3-76
pemjh\challenge215\challenge215      45     39     32     31     9%   2-23, 26-29, 32-44, 48-59, 64
pemjh\challenge216\challenge216      67     61     48     47     6%   4-18, 21-44, 47-76, 81
pemjh\challenge220\challenge220      17     13      6      5    22%   2-14, 17, 22
pemjh\challenge225\challenge225      14     11      8      7    18%   4-14, 19
pemjh\challenge230\challenge230      34     30     12     11    11%   2-37, 40-47, 52-53
pemjh\challenge231\challenge231      41     40     14     14     2%   3-72
pemjh\challenge234\challenge234      25     24     10     10     3%   3-44
pemjh\challenge235\challenge235      15     12      8      7    17%   2-14, 19
pemjh\challenge243\challenge243      33     32     20     20     2%   3-49
pemjh\challenge250\challenge250      16     12      8      7    21%   2-18, 21-22, 27
pemjh\challenge259\challenge259      42     32     18     17    18%   4-8, 11, 14, 17, 20, 23-53, 58-63, 66
pemjh\challenge265\challenge265      35     27     10      9    20%   2-9, 13-15, 18, 21-33, 37-47, 50, 55
pemjh\main                           51     33     20     15    32%   7-8, 13-28, 39-57, 63, 66-68
pemjh\utilities\__init__              0      0      0      0   100%   
pemjh\utilities\numbers             394    359    207    199     7%   10-37, 41-60, 64-75, 79-127, 131-136, 140-154, 161-175, 179-182, 186-190, 194-209, 214-240, 244-260, 264-266, 270-292, 296-315, 319-365, 369-387, 391-393, 398-435, 439-446, 450-455, 461-474, 478-492, 496-500, 505-507, 510-516, 520-549, 555-568, 572-581, 585-594
pemjh\utilities\strings               8      7      6      6     7%   2-10
-----------------------------------------------------------------------------
TOTAL                              5362   4638   2784   2575    11%   
Coverage HTML written to dir htmlcov
Traceback (most recent call last):
  File "E:\software_tools\python\pypy-2.6.1-win32\lib-python\2.7\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "E:\software_tools\python\pypy-2.6.1-win32\lib-python\2.7\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\Development\pemjh\.tox\pypy\bin\py.test.EXE\__main__.py", line 9, in <module>
    sys.exit(main())
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\config.py", line 41, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\main.py", line 116, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\main.py", line 109, in wrap_session
    exitstatus=session.exitstatus)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 393, in execute
    return wrapped_call(method(*args), self.execute)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 109, in wrapped_call
    wrap_controller.send(call_outcome)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\terminal.py", line 362, in pytest_sessionfinish
    self.config.hook.pytest_terminal_summary(terminalreporter=self)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 521, in __call__
    return self._docall(self.methods, kwargs)
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 528, in _docall
    firstresult=self.firstresult).execute()
  File "d:\development\pemjh\.tox\pypy\site-packages\_pytest\core.py", line 394, in execute
    res = method(*args)
  File "d:\development\pemjh\.tox\pypy\site-packages\pytest_cov\plugin.py", line 177, in pytest_terminal_summary
    % (self.options.cov_fail_under, total))
CoverageError: Required test coverage of 100% not reached. Total coverage: 11.45%
ERROR: InvocationError: 'D:\\Development\\pemjh\\.tox\\pypy\\bin\\py.test.EXE --pylint --flake8 --showlocals --full-trace --durations=0 --doctest-modules --cov=pemjh --cov-report=term-missing --cov-report=html --cov-fail-under=100'
___________________________________ summary ___________________________________
ERROR:   py27: commands failed
ERROR:   py27_64: InvocationError: D:\Development\pemjh\.venv\py27_64\Scripts\python.exe -m virtualenv --python D:\Development\pemjh\.venv\py27_64\Scripts\python.exe py27_64 (see D:\Development\pemjh\.tox\py27_64\log\py27_64-0.log)
ERROR:   py34: commands failed
ERROR:   py34_64: InvocationError: D:\Development\pemjh\.venv\py27_64\Scripts\python.exe -m virtualenv --python D:\Development\pemjh\.venv\py27_64\Scripts\python.exe py34_64 (see D:\Development\pemjh\.tox\py34_64\log\py34_64-0.log)
ERROR:   pypy: commands failed
